<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Le guide de survie Ã  la programmation en noyau Linux</title>
<!-- 2018-09-13 Thu 18:02 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Burel StÃ©phane" />
<meta  name="description" content="Comment crÃ©er des modules noyau pour Linux"
 />
<meta  name="keywords" content="linux, kernel, kernel module, kernel programming, noyau, module noyau, programmation noyau linux, dÃ©veloppement noyau linux" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/foundation.min.css"></link>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/org-export.css"></link>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/style.css"></link>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<a name="top" id="top"></a>
</div>
<div id="content">
<h1 class="title">Le guide de survie Ã  la programmation en noyau Linux</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a>
<ul>
<li><a href="#sec-1-1">PaternitÃ©</a></li>
<li><a href="#sec-1-2">Versions et Notes</a></li>
<li><a href="#sec-1-3">Remerciements</a></li>
<li><a href="#sec-1-4">Qu'est ce qu'un module noyau ?</a></li>
<li><a href="#sec-1-5">Paquet de module noyau</a></li>
<li><a href="#sec-1-6">Quels modules sont prÃ©sents dans mon noyau ?</a></li>
<li><a href="#sec-1-7">Ai-je besoin de tÃ©lÃ©charger et de compiler le noyau linux ?</a></li>
<li><a href="#sec-1-8">Avant de commencer</a></li>
</ul>
</li>
<li><a href="#sec-2">En-tÃªte</a></li>
<li><a href="#sec-3">Exemples</a></li>
<li><a href="#sec-4">Hello World</a>
<ul>
<li><a href="#sec-4-1">Votre tout premier module</a></li>
<li><a href="#sec-4-2">Salut et Au revoir</a></li>
<li><a href="#sec-4-3">Les macros __init et __exit</a></li>
<li><a href="#sec-4-4">Licences et Documentation du Module</a></li>
<li><a href="#sec-4-5">Passer un argument Ã  votre module</a></li>
<li><a href="#sec-4-6">CrÃ©er un module depuis plusieurs fichiers</a></li>
<li><a href="#sec-4-7">CrÃ©er des modules pour un noyau prÃ©compilÃ©</a></li>
</ul>
</li>
<li><a href="#sec-5">Avant-propos</a>
<ul>
<li><a href="#sec-5-1">OÃ¹ la vie d'un module commence et oÃ¹ elle se termine</a></li>
<li><a href="#sec-5-2">Fonctions disponibles pour votre module</a></li>
<li><a href="#sec-5-3">Mode utilisateur, mode noyau</a></li>
<li><a href="#sec-5-4">Convention de nommage</a></li>
<li><a href="#sec-5-5">Espace de code</a></li>
<li><a href="#sec-5-6">Les pilotes de pÃ©riphÃ©riques</a></li>
</ul>
</li>
<li><a href="#sec-6">Pilote de pÃ©riphÃ©rique en mode caractÃ¨re</a>
<ul>
<li><a href="#sec-6-1">La structure `file_operations`</a></li>
<li><a href="#sec-6-2">La structure `file`</a></li>
<li><a href="#sec-6-3">Enregistrer un pÃ©riphÃ©rique</a></li>
<li><a href="#sec-6-4">Supprimer un pÃ©riphÃ©rique</a></li>
<li><a href="#sec-6-5">chardev.c</a></li>
<li><a href="#sec-6-6">Ecrire des modules pour plusieurs versions du noyau.</a></li>
</ul>
</li>
<li><a href="#sec-7">Le systÃ¨me de fichier /proc</a>
<ul>
<li><a href="#sec-7-1">Lire et Ã©crire un fichier /proc</a></li>
<li><a href="#sec-7-2">GÃ©rer un fichier /proc avec un systÃ¨me de fichier standard</a></li>
<li><a href="#sec-7-3">GÃ©rer un fichier /proc avec seq_file</a></li>
</ul>
</li>
<li><a href="#sec-8">sysfs : Interagissez avec votre module</a></li>
<li><a href="#sec-9">Interagir avec un fichier de pÃ©riphÃ©rique</a></li>
<li><a href="#sec-10">Les appels systÃ¨me</a></li>
<li><a href="#sec-11">Processus bloquants et threads</a>
<ul>
<li><a href="#sec-11-1">Sleep</a></li>
<li><a href="#sec-11-2">AchÃ¨vements</a></li>
</ul>
</li>
<li><a href="#sec-12">Eviter les collisions et les interblocages</a>
<ul>
<li><a href="#sec-12-1">Mutex</a></li>
<li><a href="#sec-12-2">Verrou tournant</a></li>
<li><a href="#sec-12-3">Verrou lecture/Ã©criture</a></li>
<li><a href="#sec-12-4">OpÃ©rations atomiques</a></li>
</ul>
</li>
<li><a href="#sec-13">Remplacer les macros Print</a>
<ul>
<li><a href="#sec-13-1">Remplacement</a></li>
<li><a href="#sec-13-2">Faire clignoter les LEDS du clavier</a></li>
</ul>
</li>
<li><a href="#sec-14">TÃ¢ches ordonnancÃ©es</a>
<ul>
<li><a href="#sec-14-1">Tasklets</a></li>
<li><a href="#sec-14-2">Files de travaux</a></li>
</ul>
</li>
<li><a href="#sec-15">Gestionnaire d'interruptions</a>
<ul>
<li><a href="#sec-15-1">Gestionnaire d'interruptions</a></li>
<li><a href="#sec-15-2">DÃ©tection de pression de bouton</a></li>
<li><a href="#sec-15-3">Partie immergÃ©e d'une interruption</a></li>
</ul>
</li>
<li><a href="#sec-16">Cryptage</a>
<ul>
<li><a href="#sec-16-1">Fonction de hachage</a></li>
<li><a href="#sec-16-2">Cryptage par clÃ© symÃ©trique</a></li>
</ul>
</li>
<li><a href="#sec-17">Standardisation des interfaces : Le modÃ¨le de pÃ©riphÃ©rique</a></li>
<li><a href="#sec-18">Optimisation</a>
<ul>
<li><a href="#sec-18-1">Conditions likely et unlikely</a></li>
</ul>
</li>
<li><a href="#sec-19">PiÃ¨ges rÃ©currents</a>
<ul>
<li><a href="#sec-19-1">Utilisation de bibliothÃ¨ques standards.</a></li>
<li><a href="#sec-19-2">DÃ©sactiver les interruptions</a></li>
<li><a href="#sec-19-3">Ne vous jetez pas dans la gueule du loup</a></li>
</ul>
</li>
<li><a href="#sec-20">Que faire ensuite ?</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Le guide de survie Ã  la programmation en noyau Linux est un livre libre. Vous pouvez le reproduire et le modifier sous respect de l'Open Software License, version 3.0.
</p>

<p>
Cet ouvrage est distribuÃ© avec l'espoir qu'il vous sera utile, mais aucune financiÃ¨re ni d'utilisation.
</p>

<p>
Les auteurs encouragent la distribution sans condition de cet ouvrage pour un usage personnel, ou mÃªme Ã  fin commerciale, Ã  condition que toute l'information concernant les droits d'auteur et autres droits d'exclusivitÃ© soient respectÃ©s et que la licence utilisÃ©e reste compatible avec les descriptions de la licence Open Software License. En rÃ©sumÃ©, vous pouvez copier cet ouvrage, le distribuer Ã  des fins non lucratives ou commerciales. Aucune permission explicite n'est requise de l'auteur pour la reproduction de cet ouvrage quelqu'en soit le format, papier ou Ã©lectronique tant que vous respectez sa licence.
</p>

<p>
Tout travail ou traduction Ã  partir de ce document doit Ãªtre placÃ© sous une licence compatible avec les descriptions de la licence Open Software License, et les droits d'exclusivitÃ© du document original doivent Ãªtre prÃ©servÃ©s dans le document final. Si vous avez contribuÃ© Ã  amÃ©liorer ce document, vous devez rendre votre travail disponible et ouvert pour une mise Ã  jour. Merci de rendre vos travaux, traductions et mises Ã  jours Ã  disposition du gestionnaire de ce document, Peter Jay Salzman \&lt;p@dirac.org\&gt;. Ceci permettra de fusionner vos travaux avec la version originale, afin de toujours fournir Ã  la communautÃ© Linux une version mise Ã  jour.
</p>

<p>
Si vous publiez cet ouvrage Ã  des fins commerciales, des dons, des droits d'auteur et des copies physiques seront grandement apprÃ©ciÃ©es par les auteurs et le [Linux Documentation Project](<a href="http://www.tldp.org">http://www.tldp.org</a>) (LDP). Contribuer de cette sorte dÃ©montre votre soutien au logiciel libre et au LDP. Si vous avez des questions ou des commentaires, merci de contacter (en anglais) l'adresse dÃ©crite plus-haut.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">PaternitÃ©</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Le guide de survie Ã  la programmation en noyau Linux a Ã©tÃ© Ã  l'origine Ã©crit pour le noyau dans sa version 2.2 par Ori Pomerantz. Mais Ã  terme, Ori n'a plus eu le temps pour maintenir ce document Ã  jour. AprÃ¨s tout, le noyau Linux est un logiciel trÃ¨s volatile. Peter Jay Salzman prit en main la mise Ã  jour de ce document et l'a mis Ã  jour pour la version 2.6. Finalement, Peter non plus n'a plus eu de temps Ã  accorder Ã  ce projet, alors Michael Burian est devenu un co-gestionnaire de ce document et l'a actualisÃ© pour les verions 2.6. Bob Mottran a ensuite mis Ã  jour les exemples pour les versions 3.8 et postÃ©rieures, puis a rajoutÃ© le chapitre sur les sysfs et mis Ã  jour d'autre chapitres. StÃ©phane Burel a traduit les travaux de ces auteurs en franÃ§ais.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Versions et Notes</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Comme prÃ©cisÃ© plus haut, le noyau Linux est un logiciel trÃ¨s volatile. Depuis les origines du guide que vous lisez, et alors que les nouvelles versions de Linux dÃ©filaient, la question s'est toujours posÃ©e de savoir si telle ou telle information obsolÃ¨te devait Ãªtre enlevÃ©e ou si on devait la garder Ã  titre historique. Michael Burian et Bob Mottran ont dÃ©cidÃ© de crÃ©er une nouvelle branche du guide pour chaque version stable. Ainsi la version du guide 4.15.x traitera du noyau 4.15.x et la version 2.6.x traitera du noyau 2.6. Le but de ce guide n'est donc pas de retenir des informations historiques. Un personne qui cherche une vieille information devra donc lire le guide dans la version qui lui convient.
</p>

<p>
Le code source fourni et les notes gÃ©nÃ©rales devraient contenter toutes les architectures et versions, mais je ne peux cependant pas vous l'assurer.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Remerciements</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Les personnes suivantes ont contribuÃ© aux corrections du prÃ©sent document et leurs suggestions ont Ã©tÃ© utiles : Ignacio Martin, David Porter, Daniele Paolo Scarpazza, Dimo Velev, Francois Audeon, Horst Schirmeier, Bob Mottram et Roman Lakeev.
</p>

<p>
Merci Ã©galement Ã  Jacqueline Toulet pour sa relecture de la traduction franÃ§aise de ce document.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Qu'est ce qu'un module noyau ?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Vous souhaitez donc Ã©crire un module noyau. Vous connaissez le C, vous avez crÃ©Ã© quelques programmes que vous avez lancÃ© en tant que simple processus, et vous souhaitez maintenant mettre les mains dans le cambouis, lÃ  ou un simple pointeur mal maÃ®trisÃ© peut rÃ©duire Ã  nÃ©ant tout votre travail, et oÃ¹ un plantage de votre programme conduit au mieux au redÃ©marrage de votre machine, au pire Ã  la fin du monde.
</p>

<p>
Vous cherchez donc Ã  crÃ©er un module noyau.
</p>

<p>
Un module noyau est un morceau code qui peut Ãªtre chargÃ© et dÃ©chargÃ© du noyau Ã  la demande. Il Ã©tend les services du noyau sans avoir besoin de redÃ©marrer le systÃ¨me. Par exemple, les pilotes de pÃ©riphÃ©riques forment une classe de modules qui permettent au noyau d'interagir avec les pÃ©riphÃ©riques connectÃ©s au systÃ¨me. Sans les modules, il faudrait crÃ©er un noyau monolithique, d'un seul bloc, et insÃ©rer toutes les nouveautÃ©s directement dans l'image du noyau. Non seulement on aurait donc des noyaux bien plus gros, cette technique a aussi l'inconvÃ©nient de nÃ©cessiter une rÃ©installation et un redÃ©marrage du noyau Ã  chaque fois que l'on cherche une nouvelle fonctionnalitÃ©.
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Paquet de module noyau</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Les distributions Linux fournissent les commandes <b>modprobe</b>, <b>insmod</b> et <b>depmod</b> pour utiliser un paquet.
</p>

<p>
Sur Debian:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get install build-essential kmod
</pre>
</div>

<p>
Sur Parabola:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo pacman -S gcc kmod
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Quels modules sont prÃ©sents dans mon noyau ?</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Vous pouvez savoir les modules qui sont actuellement chargÃ©s dans votre noyau en utilisant la commande <b>lsmod</b>.
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod
</pre>
</div>

<p>
La liste des modules sont stockÃ©s au sein du fichier /proc/modules, pouvez vous donc les voir avec la commande suivante :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo cat /proc/modules
</pre>
</div>

<p>
Cette liste pouvant Ãªtre trÃ¨s longue, peut-Ãªtre prÃ©fÃ©rerez vous chercher un module particulier. Pour chercher le module <i>fat</i> :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep fat
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Ai-je besoin de tÃ©lÃ©charger et de compiler le noyau linux ?</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Pour suivre ce cours, ce n'est pas une nÃ©cessitÃ©. Mais Ã§a reste conseillÃ© de travailler sur une version de test qui tourne sur une machine virtuelle afin d'Ã©viter de ruiner votre systÃ¨me et de tout perdre en cas de maladresse du lecteur. Les auteurs de ce guide ne sont pas tenus pour responsable dans un tel cas de figure.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Avant de commencer</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Avant de plonger dans le vif du sujet, je tiens Ã  vous signaler qu'il existe tellement de versions diffÃ©rentes de Linux que vous pouvez rencontrez des problÃ¨mes qui ne sont pas signalÃ©es dans ce guide. Selon le cas, crÃ©er votre premier module "hello world", le compiler et l'insÃ©rer dans le noyau peut Ãªtre la tÃ¢che la plus ardue de tout ce guide. Ce qui implique qu'une fois que vous aurez les pieds dans l'eau, ce qui suivra vous semblera plus simple. Ne dÃ©sespÃ©rez jamais ! C'est la clÃ© pour programmer dans le noyau Linux.
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-8-0-1" name="sec-1-8-0-1"></a>Version des Modules<br  /><div class="outline-text-5" id="text-1-8-0-1">
<p>
Un module compilÃ© pour un noyau donnÃ© ne se chargera pas sur un noyau diffÃ©rent, Ã  moins que vous activiez l'option CONFIG_MODVERSIONS dans ce dit noyau. Nous irons plus en profondeur dans ce concept plus tard dans ce guide. Jusqu'Ã  ce que nous traitions le sujet, les exemples fournis peuvent ne pas marcher si vous utilisez un noyau avec cette option activÃ©e. Et la plupart des distributions Linux activent cette option par dÃ©faut. Si vous avez des problÃ¨mes en chargeant les modules en raison de la version de votre noyau, recompilez un noyau qui a dÃ©sactivÃ© cette option.
</p>
</div>
</li>

<li><a id="sec-1-8-0-2" name="sec-1-8-0-2"></a>Utilisation d'une console.<br  /><div class="outline-text-5" id="text-1-8-0-2">
<p>
Il vous est vivement recommandÃ© de noter, compiler et charger tous les exemples prÃ©sents dans ce guide. Et il est Ã©galement recommandÃ© de le faire Ã  partir d'une console. Vous ne devriez pas utiliser d'environnement graphique.
</p>

<p>
Les modules ne peuvent pas afficher de message Ã  l'Ã©cran Ã  la maniÃ¨re d'un printf(), mais ils peuvent enregistrer des informations et des alertes, qui finiront affichÃ©s sur votre Ã©cran, mais dans le seul cas oÃ¹ vous utilisez une console. Si vous insÃ©rez un module depuis un terminal graphique, les informations et les alertes seront enregistrÃ©es, mais seulement dans votre journal systemd. Vous ne pourrez pas le lire Ã  moins de regarder votre journal journalctl. Afin d'avoir directement, et en temps rÃ©el, accÃ¨s Ã  toutes ces informations, vous devriez travailler Ã  partir d'une console.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">En-tÃªte</h2>
<div class="outline-text-2" id="text-2">
<p>
Avant de pouvoir crÃ©er quoi que ce soit, vous aurez besoin d'installer les en-tÃªtes de votre noyau.
</p>

<p>
Sur Parabola GNU/Linux:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo pacman -S linux-libre-headers
</pre>
</div>

<p>
Sur Debian:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get update
apt-cache search linux-headers-$(<span class="org-sh-quoted-exec">uname</span> -r)
</pre>
</div>

<p>
Ceci vous dira quels fichiers d'en-tÃªte sont disponibles. Par exemple :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get install kmod linux-headers-4.15.2-1-amd64
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Exemples</h2>
<div class="outline-text-2" id="text-3">
<p>
Tous les documents de ce guide sont disponibles dans le sous-rÃ©pertoire <i>examples</i>. Pour essayer et pour compiler :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> examples
make
</pre>
</div>

<p>
Si vous avez des erreurs de compilation vous avez peut-Ãªtre un noyau plus rÃ©cent ou avez besoin d'installer les fichiers d'en-tÃªte correspondants.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Hello World</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Votre tout premier module</h3>
<div class="outline-text-3" id="text-4-1">
<p>
La plupart des personnes qui commencent Ã  programmer dÃ©butent avec un "<i>hello world</i>". Je ne sais pas quelles malÃ©dictions encourent celles et ceux qui brisent cette tradition, et j'ai trop peur de l'apprendre. Nous commencerons donc avec quelques exemples "<i>hello world</i>" qui vous montreront les diffÃ©rents aspects des bases nÃ©cessaire Ã  l'Ã©criture d'un module noyau.
</p>

<p>
Voici le module le plus simple.
</p>

<p>
CrÃ©ez un rÃ©pertoire d'essai :
</p>

<div class="org-src-container">

<pre class="src src-sh">mkdir -p ~/develop/kernel/hello-1
<span class="org-builtin">cd</span> ~/develop/kernel/hello-1
</pre>
</div>

<p>
Recopiez ceci au sein de votre Ã©diteur et sauvegardez le sous <b>hello-1.c</b>:
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-1.c - Module noyau &#195;&#169;l&#195;&#169;mentaire.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello world 1.\n"</span>);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Un retour non nul signifie que init_module a &#195;&#169;chou&#195;&#169;. Dans ce cas,</span>
<span class="org-comment">     * le module ne peut pas &#195;&#170;tre charg&#195;&#169;.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye world 1.\n"</span>);
}
</pre>
</div>

<p>
Vous aurez maintenant besoin d'un Makefile. Si vous recopiez ceci, n'oubliez pas de changer les espaces en tabulations :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o

<span class="org-makefile-targets">all</span>:
        make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
        make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
Puis finalement :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
</pre>
</div>

<p>
Si tout se passe bien, vous devriez ensuite avoir un module compilÃ© <b>hello-1.ko</b>. Vous pouvez lire les informations de ce module avec la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo modinfo hello-1.ko
</pre>
</div>

<p>
Ã€ ce moment, la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
Ne doit rien vous renvoyer. Vous pouvez essayer de charger votre module flambant-neuf avec :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo insmod hello-1.ko
</pre>
</div>

<p>
Le trait d'union sera converti en sous-tiret, donc si vous ressayer la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
Vous devriez maintenant voir votre module chargÃ©. Il peut Ãªtre enlevÃ© avec la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod hello_1
</pre>
</div>

<p>
Vous remarquez donc, comme prÃ©cisÃ© plus haut, que le trait d'union du nom de votre module a Ã©tÃ© remplacÃ© par un sous-tiret. Pour voir ce qui s'est passÃ© dans le journal :
</p>

<div class="org-src-container">

<pre class="src src-sh">journalctl --since <span class="org-string">"1 hour ago"</span> | grep kernel
</pre>
</div>

<p>
Vous connaissez maintenant la base de la crÃ©ation, de la compilation, de l'installation et la suppression de modules. Nous allons maintenant Ã©tudier comment fonctionne un module.
</p>

<p>
Les modules noyau doivent contenir au moins deux fonctions : une fonction de dÃ©part (ou d'initialisation) appelÃ©e <b>init_module()</b> qui est appelÃ©e par la commande insmod, et une fonction de fin (ou de nettoyage) appelÃ©e <b>cleanup_module()</b> qui est appelÃ©e par la commande rmmod. Une nouveautÃ© apportÃ©e par la version 2.3.13 du noyau vous permet d'utiliser maintenant les noms que vous souhaitez pour vos fonctions de dÃ©part et de fin. On Ã©tudiera cette option dans la rubrique 2.3. De fait, la nouvelle mÃ©thode doit Ãªtre prÃ©fÃ©rÃ©e, mais vous pouvez rencontrer quelques irrÃ©ductibles traditionalistes qui prÃ©fÃ¨rent encore travailler Ã  l'ancienne et utiliser les fonctions init_module() et cleanup_module() pour leurs fonctions de dÃ©part et de fin.
</p>

<p>
GÃ©nÃ©ralement, la fonction de dÃ©part met en place une fonction gestionnaire pour une fonctionnalitÃ© du noyau, ou alors remplace l'une des fonctions du noyau avec le code de votre module (dans quel cas, le module exÃ©cute habituellement son code avant d'appeler le code originel). Et la fonction de nettoyage quant Ã  elle est censÃ©e dÃ©faire tous les changements apportÃ©s la fonction de dÃ©part, afin de pouvoir dÃ©charger le module de maniÃ¨re propre et sÃ©curisÃ©e.
</p>

<p>
Enfin, chaque module du noyau doit maintenant inclure le fichier linux/module.h. On a besoin d'inclure Ã©galement le fichier <b>linux/kernel.h</b> pour avoir accÃ¨s Ã  la macro pr_alert() de journalisation, fonction que l'on traitera dans la rubrique 2.1.1.
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-1-0-1" name="sec-4-1-0-1"></a>Note Ã  propos du style de code<br  /><div class="outline-text-5" id="text-4-1-0-1">
<p>
Un autre point qu'il faut prÃ©ciser Ã  quiconque commence avec la programmation au cÅ“ur du noyau linux, c'est qu'il faut respecter les conventions de codes du noyau. Ã€ ce titre, vous devez utiliser comme indentation des tabulations, et non pas des espaces. C'est l'une des nombreuses conventions du noyau, et vous devez respecter ces conventions du noyau si vous voulez soumettre publiquement votre code.
</p>
</div>
</li>

<li><a id="sec-4-1-0-2" name="sec-4-1-0-2"></a>Introduction aux macros de notations<br  /><div class="outline-text-5" id="text-4-1-0-2">
<p>
Au commencement, ce guide comprenait des fonctions <b>printk</b>, normalement suivies d'une prioritÃ© telle que KERN_INFO ou KERN_DEBUG. Mais ces expressions peuvent maintenant Ãªtre abrÃ©gÃ©es grÃ¢ce Ã  l'usage de macros telles que <b>pr_info</b> ou <b>pr_debug</b>. Ces macros servent juste Ã  simplifier votre code et Ã  Ã©viter l'oubli de prioritÃ©. Elles peuvent Ãªtre trouvÃ©es au sein du fichier <b>linux/printk.h</b>. Prenez le temps de lire ces dÃ©finitions, afin de voir toutes les prioritÃ©s disponibles.
</p>
</div>
</li>

<li><a id="sec-4-1-0-3" name="sec-4-1-0-3"></a>Ã€ propos de la compilation<br  /><div class="outline-text-5" id="text-4-1-0-3">
<p>
Les modules noyau doivent Ãªtre compilÃ©s d'une maniÃ¨re lÃ©gÃ¨rement diffÃ©rente d'un programme utilisateur standard. Les premiÃ¨res versions du noyau exigeaient de nous un soin particulier vis-Ã -vis des paramÃ¨tres de compilation, habituellement stockÃ©s dans les Makefiles. Bien que hiÃ©rarchisÃ©s, de nombreux paramÃ¨tres redondants dans les Makefiles de sous-niveaux les rendaient de plus en plus gros et difficiles Ã  mettre Ã  jour. Heureusement, il existe dÃ©sormais une maniÃ¨re simplifiÃ©e de gÃ©rer la compilation, appelÃ©e kbuild, et le processus de compilation des modules externes chargeables Ã  la volÃ©e est maintenant entiÃ¨rement intÃ©grÃ©e aux mÃ©canismes de compilation standard du noyau. Pour en apprendre davantage sur la compilation de modules qui ne font pas officiellement partie du noyau (tel que tous les exemples que vous trouverez dans ce guide), regardez le fichier <b>linux/Documentation/kbuild/modules.txt</b>.
</p>

<p>
Vous trouverez Ã©galement des dÃ©tails complÃ©mentaires sur les Makefiles pour les modules noyau dans le fichier <b>linux/Documentation/kbuild/makefiles.txt</b>. Lisez ce fichier et ceux qui y sont liÃ©s avant de commencer Ã  modifier un Makefile; vous Ã©conomiserez beaucoup de temps.
</p>

<blockquote>
<p>
Voici un petit exercice pour le lecteur : Vous voyez le commentaire plus haut concernant la valeur renvoyÃ©e par la fonction init_module()? Changez cette valeur pour une valeur quelconque nÃ©gative, recompilez et rechargez le module. Que se passe-t-il ?
</p>
</blockquote>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Salut et Au revoir</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Comme je l'ai prÃ©cisÃ© prÃ©cÃ©demment, dans les premiÃ¨res versions du noyau, vous deviez utiliser les fonctions <b>init_module</b> et <b>cleanup_module</b>, comme dans le premier exemple. Mais dÃ©sormais, vous pouvez appeler vos fonctions comme bon vous semble en utilisant les macros <b>module_init</b> et <b>module_exit</b>. Ces macros sont dÃ©finies dans <b>linut/init.h</b>. La seule nÃ©cessitÃ© est que les fonctions soient dÃ©finies avant d'appeler ces macros, ou vous vous retrouverez avec des erreurs de compilations. Voici un exemple de cette technique :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-2.c - Exemple montrant l'usage des macros module_init() et</span>
<span class="org-comment"> *              module_exit (). Ces macros sont &#195;  pr&#195;&#169;f&#195;&#169;rer aux fonctions</span>
<span class="org-comment"> *              init_module() et cleanup_module().</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_2_init(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world 2\n"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_2_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 2\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_2_init);
<span class="org-function-name">module_exit</span>(hello_2_exit);
</pre>
</div>

<p>
Nous avons maintenant deux modules noyau Ã  notre actif. Ajouter un autre module Ã  notre Makefile se fait aussi simplement que Ã§a :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o
<span class="org-variable-name">obj-m</span> += hello-2.o
<span class="org-makefile-targets">all</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
Maintenant, jetons un Å“il au fichier linux/drivers/car/Makefile pour un exemple de Makefile en situation rÃ©elle.
</p>

<p>
Comme vous pouvez le voir, certains modules sont connectÃ©s en dur au noyau (obj-y), mais oÃ¹ sont passÃ©s tous les obj-m ? Les lecteurs Ã  l'aise avec le bash verront rapidement oÃ¹ je veux en venir. Pour les dÃ©butants, les nombreuses lignes obj-$(CONFIG_EXEMPLE) que vous pouvez voir s'Ã©tendent soit en obj-y, soit en obj-m, selon que la variable CONFIG_EXEMPLE soit Ã©gale Ã  y ou Ã  m. Ces variables sont affectÃ©es dans le fichier linux/.config, au moment oÃ¹ vous lancez make menuconfig ou une autre commande pour configurer votre noyau avant de le compiler.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Les macros __init et __exit</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Ces macros sont une nouveautÃ© du noyau 2.2. Vous observerez les changements dans les dÃ©finitions des fonctions de dÃ©part et de fin. La macro <b>__init</b> conduit la fonction d'entrÃ©e Ã  Ãªtre supprimÃ©e du noyau afin que son espace mÃ©moire soit libÃ©rÃ©, une fois que la fonction d'entrÃ©e s'est terminÃ©e. Comme cette fonction n'est faite que pour Ãªtre appelÃ©e qu'une fois, ce mÃ©canisme est sensÃ©. Cette fonctionnalitÃ© n'est cependant disponible que pour les pilotes compilÃ©s avec votre noyau et n'aura aucun effet sur votre module.
</p>

<p>
Il existe Ã©galement une macro <b>__initdata</b> donc le fonctionnement est semblable Ã  <b>__init</b> mais pour les variables d'initialisation plutÃ´t que pour les fonctions.
</p>

<p>
Il existe Ã©galement la macro <b>__exit</b>, qui permet d'ignorer la fonction de sortie au moment de la compilation de votre noyau. Si vous considÃ©rez que cette fonction ne doit pas Ãªtre appelÃ©e puisqu'elle ne peut Ãªtre enlevÃ©e de votre noyau, lÃ  encore ce mÃ©canisme est utile. Encore une fois, cette fonctionnalitÃ© n'a de sens que pour les pilotes compilÃ©s avec votre noyau et n'aura aucun effet sur votre module.
</p>

<p>
Ces macros sont dÃ©finies dans le fichier <b>linux/init.h</b> et ne servent qu'Ã  Ã©conomiser l'espace mÃ©moire du noyau. Quand vous lancer votre noyau vous aurez peut-Ãªtre l'occasion de votre un message tel que "Freeing unused kernel memory : 236k freed" C'est prÃ©cisÃ©mment de ce mÃ©canisme qu'il s'agit.
</p>


<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-3.c - Illustre l'usage des macros __init, __initdata et __exit.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">hello3_data</span> __initdata = 3;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_3_init(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world %d\n"</span>, hello3_data);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_3_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 3\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_3_init);
<span class="org-function-name">module_exit</span>(hello_3_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Licences et Documentation du Module</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Soyons honnÃªte : Quel genre de fou charge dans son noyau des modules propriÃ©taires ? Si c'est votre cas, vous avez peut-Ãªtre dÃ©jÃ  vu ce message :
</p>

<div class="org-src-container">

<pre class="src src-txt"># insmod xxxxxx.o
Warning: loading xxxxxx.ko will taint the kernel: no license
  See http://www.tux.org/lkml/#export-tainted for information about tainted modules
Module xxxxxx loaded, with warnings
</pre>
</div>

<p>
Vous pouvez utiliser certaines macros pour indiquer la licence pour votre module. A titre exhaustif, vous pouvez utiliser "GPL", "GPL v2", "GPL and additional rights", "Dual BSD/GPL", "Dual MIT/GPL", "Dual MPL/GPL" comme licence libre. Toutes les autres sont "Proprietary", et ne sont donc pas considÃ©rÃ©es comme libres. Ces macros sont dÃ©finies dans le fichier <b>linux/module.h</b>.
</p>

<p>
La macro pour indiquer la licence de votre module est <b>MODULE_LICENSE</b>. Cette macro, ainsi que d'autres servant Ã  dÃ©crire le module sont illustrÃ©es dans l'exemple suivant.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-4.c - Illustre la documentation des modules.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"A sample driver"</span>);
MODULE_SUPPORTED_DEVICE(<span class="org-string">"testdevice"</span>);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> init_hello_4(<span class="org-type">void</span>)
{
        pr_info(<span class="org-string">"Hello, world 4\n"</span>);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> cleanup_hello_4(<span class="org-type">void</span>)
{
        pr_info(<span class="org-string">"Goodbye, world 4\n"</span>);
}

<span class="org-function-name">module_init</span>(init_hello_4);
<span class="org-function-name">module_exit</span>(cleanup_hello_4);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Passer un argument Ã  votre module</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Les modules peuvent recevoir un argument via une ligne de commande, mais pas de la maniÃ¨re d'un programme utilisateur.
</p>

<p>
Afin de permettre Ã  votre module de recevoir des arguments, vous devez dÃ©clarer des variables globales qui recevront ces arguments. Vous devrez ensuite utiliser la macro module_param (laquelle est dÃ©finie dans le fichier linux/moduleparam.h) afin d'activer ce mÃ©canisme. Quand votre module sera lancÃ©, la commande insmod va affecter ces variables globales avec les valeurs donnÃ©es (par exemple ./insmod mymodule.ko variable=5). Les variables ainsi que les macros que je viens de dÃ©crire doivent Ãªtre placÃ©es au dÃ©but de votre module pour des raisons de lisibilitÃ©. L'exemple suivant dÃ©montrera ce point plus facilement qu'un long discours.
</p>

<p>
La macro module_param() prend 3 arguments : le nom de la variable, son type et la permission du fichier correspondant (qui sera crÃ©Ã© pour chaque argument) crÃ©Ã© avec sysfs. Les entiers peuvent Ãªtre signÃ©s ou non signÃ©s. Si vous souhaitez utiliser des tableaux d'entiers ou des chaÃ®nes de caractÃ¨res, vous chercherez les macros module_param_array() et module_param_string().
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-variable-name">myint</span> = 3;
<span class="org-function-name">module_param</span>(myint, <span class="org-type">int</span>, 0);
</pre>
</div>

<p>
Le mÃ©canisme pour les tableaux d'arguments est maintenant diffÃ©rents des premiÃ¨res versions de Linux. Pour garder une trace du nombre de paramÃ¨tres vous devez passer, en troisiÃ¨me argument, un pointeur vers une variable qui contiendra un compteur. Vous pouvez Ã©galement ignorer ce compteur et passer la valeur NULL Ã  la place. Voici un exemple traitant ces deux mÃ©thodes :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-variable-name">myintarray</span>[2];
<span class="org-function-name">module_param_array</span>(myintarray, <span class="org-type">int</span>, <span class="org-constant">NULL</span>, 0); <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'arguments n'est pas pris en compte </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">short</span> <span class="org-variable-name">myshortarray</span>[4];
<span class="org-type">int</span> <span class="org-variable-name">count</span>;
<span class="org-function-name">module_parm_array</span>(myshortarray, <span class="org-type">short</span>, &amp;count, 0); <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'arguments est pris en compte </span><span class="org-comment-delimiter">*/</span>
</pre>
</div>

<p>
Un bon usage consiste Ã  utiliser des valeurs par dÃ©faut pour vos variables, tel qu'un port ou une adresse d'entrÃ©e/sortie par dÃ©faut. Si les variables contiennent les valeurs par dÃ©faut, alors vous lancez une mÃ©canisme d'autodÃ©tection (qui sera expliquÃ© plus tard). Sinon vous gardez la valeur passÃ©e en argument. Cet aspect sera clarifiÃ© par la suite.
</p>

<p>
Ensuite, il existe une macro de fonction, <b>MODULE_PARAM_DESC()</b>, qui est utilisÃ©e pour documenter les arguments que votre module peut prendre. Cette macro a besoin de deux paramÃ¨tres : un nom de variable et une chaÃ®ne de caractÃ¨res qui dÃ©crit cette variable.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-5.c - Montre comment recevoir des arguments de la ligne de commande.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/moduleparam.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/stat.h&gt;</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Peter Jay Salzman"</span>);

<span class="org-keyword">static</span> <span class="org-type">short</span> <span class="org-type">int</span> <span class="org-variable-name">myshort</span> = 1;
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myint</span> = 420;
<span class="org-keyword">static</span> <span class="org-type">long</span> <span class="org-type">int</span> <span class="org-variable-name">mylong</span> = 9999;
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">mystring</span> = <span class="org-string">"blah"</span>;
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myintArray</span>[2] = { -1, -1 };
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">arr_argc</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * module_param(foo, int, 0000)</span>
<span class="org-comment"> * Le premier param&#195;&#168;tre est le nom du param&#195;&#168;tre</span>
<span class="org-comment"> * Le second est son type</span>
<span class="org-comment"> * Le dernier argument d&#195;&#169;crit les drapeaux de permissions du fichier au sein</span>
<span class="org-comment"> *   du sysfs qui sera cr&#195;&#169;&#195;&#169; plus tard (si toutefois cette valeur n'est pas</span>
<span class="org-comment"> *   nulle).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-function-name">module_param</span>(myshort, <span class="org-type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
<span class="org-function-name">MODULE_PARM_DESC</span>(myshort, <span class="org-string">"Un entier short"</span>);
<span class="org-function-name">module_param</span>(myint, <span class="org-type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
<span class="org-function-name">MODULE_PARM_DESC</span>(myint, <span class="org-string">"Un entier"</span>);
<span class="org-function-name">module_param</span>(mylong, <span class="org-type">long</span>, S_IRUSR);
<span class="org-function-name">MODULE_PARM_DESC</span>(mylong, <span class="org-string">"Un entier long"</span>);
<span class="org-function-name">module_param</span>(mystring, charp, 0000);
<span class="org-function-name">MODULE_PARM_DESC</span>(mystring, <span class="org-string">"Une cha&#195;&#174;ne de caract&#195;&#168;res"</span>);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * module_param_array(name, type, num, perm);</span>
<span class="org-comment"> * Le premier param&#195;&#168;tre est le nom du param&#195;&#168;tre (ici le nom du tableau)</span>
<span class="org-comment"> * Le second est le type des &#195;&#169;l&#195;&#169;ments au sein de ce tableau</span>
<span class="org-comment"> * Le troisi&#195;&#168;me argument est un pointeur vers une variable qui contiendra</span>
<span class="org-comment"> *   suite &#195;  l'appel de cette fonction le nombre d'&#195;&#169;l&#195;&#169;ments initialis&#195;&#169; par</span>
<span class="org-comment"> *   l'utilisateur</span>
<span class="org-comment"> * Le dernier argument d&#195;&#169;crit les drapeaux de permissions du fichier au sein</span>
<span class="org-comment"> *   du sysfs qui sera cr&#195;&#169;&#195;&#169; plus tard (si toutefois cette valeur n'est pas</span>
<span class="org-comment"> *   nulle).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-function-name">module_param_array</span>(myintArray, <span class="org-type">int</span>, &amp;arr_argc, 0000);
<span class="org-function-name">MODULE_PARM_DESC</span>(myintArray, <span class="org-string">"Un tableau d'entiers"</span>);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_5_init(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    pr_info(<span class="org-string">"Hello, world 5\n=============\n"</span>);
    pr_info(<span class="org-string">"myshort is a short integer: %hd\n"</span>, myshort);
    pr_info(<span class="org-string">"myint is an integer: %d\n"</span>, myint);
    pr_info(<span class="org-string">"mylong is a long integer: %ld\n"</span>, mylong);
    pr_info(<span class="org-string">"mystring is a string: %s\n"</span>, mystring);
    <span class="org-keyword">for</span> (i = 0; i &lt; (<span class="org-keyword">sizeof</span> myintArray / <span class="org-keyword">sizeof</span> (<span class="org-type">int</span>)); i++)
    {
        pr_info(<span class="org-string">"myintArray[%d] = %d\n"</span>, i, myintArray[i]);
    }
    pr_info(<span class="org-string">"got %d arguments for myintArray.\n"</span>, arr_argc);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_5_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 5\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_5_init);
<span class="org-function-name">module_exit</span>(hello_5_exit);
</pre>
</div>

<p>
Je vous recommande d'essayer ce code :
</p>

<div class="org-src-container">

<pre class="src src-txt"># sudo insmod hello-5.ko mystring="bebop" mybyte=255 myintArray=-1
mybyte is an 8 bit integer: 255
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: bebop
myintArray is -1 and 420

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mystring="supercalifragilisticexpialidocious" \
&gt; mybyte=256 myintArray=-1,-1
mybyte is an 8 bit integer: 0
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious
myintArray is -1 and -1

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mylong=hello
hello-5.o: invalid argument syntax for mylong: 'h'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">CrÃ©er un module depuis plusieurs fichiers</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Vous aurez parfois besoin de diviser le code source de votre module en plusieurs fichiers.
</p>

<p>
Voila l'exemple d'un module avec une telle organisation :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  start.c - Illustration d'un module d&#195;&#169;coup&#195;&#169; en plusieurs fichiers</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Ce code ex&#195;&#169;cute du code noyau </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Et il appelle des fonctions pour modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world\n"</span>);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Le second fichier :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  start.c - Illustration d'un module d&#195;&#169;coup&#195;&#169; en plusieurs fichiers</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Ce code ex&#195;&#169;cute du code noyau </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Et il appelle des fonctions pour modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    pr_info(<span class="org-string">"Short is the life of a kernel module\n"</span>);
}
</pre>
</div>

<p>
Et finalement : Le Makefile
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o
<span class="org-variable-name">obj-m</span> += hello-2.o
<span class="org-variable-name">obj-m</span> += hello-3.o
<span class="org-variable-name">obj-m</span> += hello-4.o
<span class="org-variable-name">obj-m</span> += hello-5.o
<span class="org-variable-name">obj-m</span> += startstop.o
<span class="org-variable-name">startstop-objs</span> := start.o stop.o

<span class="org-makefile-targets">all</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
VoilÃ  le Makefile complet pour tous les exemples que nous avons traitÃ©s jusqu'ici. Les cinq premiÃ¨res lignes ne vous Ã©tonneront pas, mais pour le dernier exemple vous aurez besoin de deux lignes. Nous inventons d'abord un nom d'objet pour tous nos fichiers combinÃ©s, puis on indique au Makefile quels objets forment le module.
</p>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">CrÃ©er des modules pour un noyau prÃ©compilÃ©</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Nous vous recommandons fortement de recompiler votre noyau, afin que vous puissiez activer de nombreuses fonctionnalitÃ©s utiles pour le dÃ©bogage, par exemple forcer l'enlÃ¨vement du noyau de votre module : (<b>MODULE_FORCE_UNLOAD</b>): cette option vous permettra de dÃ©charger votre module du noyau mÃªme quand ce dernier estime qu'il est dangereux de le dÃ©charger, via la commande <b>sudo rmmod -f module</b>. Cette option vous fera Ã©conomiser beaucoup de temps et de redÃ©marrage durant le dÃ©veloppement de votre module. Si vous ne dÃ©sirez pas recompiler votre noyau, vous pouvez envisager d'utiliser une machine virtuelle. Si vous commettez une erreur vous pourrez donc facilement redÃ©marrer ou restaurer votre machine virtuelle Ã  son Ã©tat initial.
</p>

<p>
Il existe Ã©galement de nombreux cas dans lesquels vous prÃ©fÃ©rerez charger votre module dans un noyau prÃ©compilÃ©, tel que ceux fournis avec la plupart des distributions Linux, ou un noyau que vous avez dÃ©jÃ  compilÃ© vous-mÃªme. Dans certaines circonstances, vous aurez besoin de compiler et d'insÃ©rer vos modules dans un noyau que vous ne pouvez pas recompiler, ou sur une machine qu'il ne vaut mieux pas redÃ©marrer. Si vous pensez que ce genre de situation ne vous arrivera jamais, vous pouvez passer Ã  la suite et considÃ©rer le reste de ce chapitre comme une grosse note de bas de page.
</p>

<p>
Maintenant, si vous avez installÃ© le code source du noyau, utilisez-le pour compiler votre module et si vous essayez d'insÃ©rer votre module au sein du noyau, dans la plupart des cas vous subirez l'erreur suivante :
</p>

<div class="org-src-container">

<pre class="src src-txt">insmod: error inserting 'poet_atkm.ko': -1 Invalid module format
</pre>
</div>

<p>
Des informations moins laconiques sont enregistrÃ©es dans le journal systemd :
</p>

<div class="org-src-container">

<pre class="src src-txt">Jun  4 22:07:54 localhost kernel: poet_atkm: version magic '2.6.5-1.358custom 686
REGPARM 4KSTACKS gcc-3.3' should be '2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3'
</pre>
</div>

<p>
En d'autres mots, votre noyau refuse d'accepter votre module car les versions (on parle de version magics) ne correspondent pas. D'ailleurs, les versions sont enregistrÃ©es dans votre module compilÃ© sous la forme d'une chaÃ®ne de caractÃ¨res statique, commenÃ§ant pas vermagic:. Cette version est insÃ©rÃ©e dans votre module au moment oÃ¹ ce dernier est liÃ© au fichier <b>init/vermagic.o</b>. Afin d'observer la version et les autres chaÃ®nes de caractÃ¨res stockÃ©es au sein d'un module, vous pouvez utilisez la commande modinfo :
</p>

<div class="org-src-container">

<pre class="src src-txt"># sudo modinfo hello-4.ko
license:        GPL
author:         Bob Mottram &lt;bob@freedombone.net&gt;
description:    A sample driver
vermagic:       4.15.2-1.358 amd64 REGPARM 4KSTACKS gcc-4.9.2
depends:
</pre>
</div>

<p>
Pour rÃ©gler le problÃ¨me soulevÃ© plus haut, nous pouvons avoir recours Ã  l'option <b>&#x2013;force-vermagic</b>, mais cette solution est potentiellement dangereuse, et inacceptable pour un module dont le dÃ©veloppement est en phase de production. En consÃ©quence, nous voulons compiler nos modules dans un environnement qui est identique Ã  celui dans le quel notre noyau a Ã©tÃ© compilÃ©. Comment procÃ©der est l'objet de ce chapitre.
</p>

<p>
Avant tout, assurez-vous d'avoir le code source de votre noyau Ã  portÃ©e de main, et dans la mÃªme version que celle de votre noyau actuel, ou du noyau de votre machine virtuelle. Ensuite, trouvez le fichier de configuration qui a Ã©tÃ© utilisÃ© pour compiler votre noyau. Habituellement, vous pouvez le trouver dans votre rÃ©pertoire <i>boot, sous un nom tel que config-4.7.xxx. Vous voulez peut-Ãªtre juste le copier dans votre code source : *cp /boot/config-`uname -r` /usr/src/linux-`uname -r`</i>.config*.
</p>

<p>
Concentrons-nous maintenant sur le message d'erreur prÃ©cÃ©dent : en regardant de plus prÃ¨s les versions, on constate que mÃªme si les deux fichiers de configurations sont exactement identiques, il existe une lÃ©gÃ¨re diffÃ©rence dans les versions, et cette diffÃ©rence suffit Ã  empÃªcher votre module d'Ãªtre insÃ©rÃ© dans votre noyau. Cette petite diffÃ©rence, Ã  savoir la chaÃ®ne de caractÃ¨res modifiÃ©e dans la version du module vient de la modification apportÃ©e par le Makefile de certaines distributions. Examinez donc le fichier <b>/usr/src/linux/Makefile</b>, et assurez-vous que la version spÃ©cifiÃ©e corresponde bien Ã  votre noyau actuel. Par exemple, votre Makefile peut commencer par :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">VERSION</span> = 4
<span class="org-variable-name">PATCHLEVEL</span> = 7
<span class="org-variable-name">SUBLEVEL</span> = 4
<span class="org-variable-name">EXTRAVERSION</span> = -1.358custom
</pre>
</div>

<p>
Dans ce cas, vous devez restaurer la valeur du symbole <b>EXTRAVERSION</b> Ã  -1.358. Nous vous suggÃ©rons cependant de garder une sauvegarde du Makefile utilisÃ© pour compiler votre noyau, lequel est disponible dans <b>/lib/modules/4.15.2-1.358/build</b>. Une simple commande <b>cp /lib/modules/`uname-r`/build/Makefile /usr/src/linux-`uname -r`</b> devrait suffir. De plus si vous avez dÃ©jÃ  commencÃ© Ã  compiler un noyau avec le (mauvais) Makefile prÃ©cÃ©dent, vous devriez relancer la compilation, ou alors modifier le symbole UTS_RELEASE dans le fichier <b>/usr/src/linux-4.15.2/include/linux/version.h</b> pour qu'il corresponde au contenu du fichier <b>/lib/modules/4.15.2/build/include/linux/version.h</b> (ou alors Ã©craser le second avec le premier).
</p>

<p>
Maintenant relancez la commande make pour mettre Ã  jour la configuration et les versions :
</p>

<div class="org-src-container">

<pre class="src src-txt"># make
CHK     include/linux/version.h
UPD     include/linux/version.h
SYMLINK include/asm -&gt; include/asm-i386
SPLIT   include/linux/autoconf.h -&gt; include/config/*
HOSTCC  scripts/basic/fixdep
HOSTCC  scripts/basic/split-include
HOSTCC  scripts/basic/docproc
HOSTCC  scripts/conmakehash
HOSTCC  scripts/kallsyms
CC      scripts/empty.o
</pre>
</div>

<p>
Vous n'avez pas besoin de recompiler la totalitÃ© de votre noyau, vous pouvez interrompre la compilation avec un Ctrl+C aprÃ¨s la ligne SPLIT, parce qu'Ã  ce moment, tous les fichiers dont vous avez besoin ont dÃ©jÃ  Ã©tÃ© recompilÃ©s. Vous pouvez revenir dans le rÃ©pertoire de votre module et le recompiler : Il sera recrÃ©Ã© conformÃ©ment aux exigences des paramÃ¨tres de votre noyau actuel et pourra donc Ãªtre chargÃ© sans erreurs.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Avant-propos</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">OÃ¹ la vie d'un module commence et oÃ¹ elle se termine</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Un programme est d'habitude intÃ©grÃ© dans une fonction `main()`, y entre, exÃ©cute un certain nombre d'instructions avant de se terminer. Les modules du noyau ne fonctionnent pas de cette maniÃ¨re. Un module commence avec la fonction de dÃ©part, que ce soit la fonction init_module ou la fonction spÃ©cifiÃ©e par la macro module_init. C'est la fonction d'entrÃ©e pour mes modules; elle informe le noyau des fonctionnalitÃ©s que ce module fournit, et paramÃ¨tre le noyau pour lancer les fonctions du module quand nÃ©cessaire. Ensuite, la fonction de dÃ©part se termine et le module ne fait plus rien tant que le noyau n'a pas dÃ©cidÃ© d'appeler le code fournit par le module.
</p>

<p>
Tous les modules se terminent par une fonction de fin, soit en <b>cleanup_module</b>, soit la fonction spÃ©cifiÃ©e par l'appel de la macro <b>module_exit</b>. C'est la fonction de sortie de votre module; elle doit dÃ©faire tous les changements apportÃ©s par votre fonction de dÃ©part. La fonction de fin doit enlever toutes les fonctionnalitÃ©s que la fonction de dÃ©part avait enregistrÃ©es.
</p>

<p>
Tous les modules doivent avoir une fonction de dÃ©part et une fonction de fin. Comme il y a de nombreuses faÃ§ons d'appeler ces fonctions, je m'emploierai Ã  faire de mon mieux pour parler de fonction de dÃ©part et de sortie, mais si par mÃ©garde j'emploie les termes de fonction d'entrÃ©e et de sortie ou de fonction init_module et cleanup_module, vous saurez de quoi je veux parler.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Fonctions disponibles pour votre module</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Les dÃ©veloppeurs utilisent sans arrÃªt des fonctions qu'ils n'ont pas eux-mÃªmes dÃ©finies. Un exemple flagrant est la fonction <b>printf()</b> Vous utilisez des bibliothÃ¨ques de fonctions qui sont fournies par la bibliothÃ¨que standard du C, libc. Votre code n'appelle pas rÃ©ellement ces fonctions avant l'Ã©dition de lien, qui s'assure que le code est disponible, et modifie les appels des fonctions recherchÃ©es pour qu'il pointe effectivement vers le code concernÃ©.
</p>

<p>
Ici aussi, les modules sont diffÃ©rents. Dans l'exemple hello world, vous avez peut-Ãªtre remarquÃ© que nous avons utilisÃ© une fonction, <b>pr_info()</b> mais que nous n'avons pas inclut de bibliothÃ¨que d'entrÃ©e/sortie. C'est parce que les modules sont des fichiers objets dont les symboles sont affectÃ©s au moment de l'insertion de votre module. La dÃ©finition de ces symboles vient du noyau lui-mÃªme. Les seuls fonctions externes que vous pouvez utiliser sont celles fournies pas le noyau. Si vous Ãªtes curieux et souhaitez savoir quels symboles sont exportÃ©s par votre noyau, vous pouvez regarder <b>/proc/kallsyms</b>.
</p>

<p>
Il faut garder Ã  l'esprit la diffÃ©rence entre fonctions de bibliothÃ¨ques et appels systÃ¨me. Les fonctions de bibliothÃ¨ques sont situÃ©es Ã  un niveau plus haut, tournent dans l'espace utilisateur et fournissent une interface plus accessible que les fonctions qui font rÃ©ellement tout le boulot : les appels systÃ¨me. Les appels systÃ¨me sont fournis par le noyau et tournent dans l'espace noyau sur demande de l'utilisateur. La fonction de bibliothÃ¨que printf() peut vous sembler Ãªtre une fonction trÃ¨s gÃ©nÃ©raliste, mais en rÃ©alitÃ© tout ce qu'elle fait est de formater les informations passÃ©es dans une chaÃ®ne de caractÃ¨res et ensuite Ã©crire la chaÃ®ne de caractÃ¨res en utilisant l'appel systÃ¨me bas niveau write(), lequel envoit les donnÃ©es Ã  Ã©crire vers l'affichage standard.
</p>

<p>
Vous souhaitez voir Ã  quels appels systÃ¨me fait appel un simple printf() ? Rien de plus simple ! Compilez le programme suivant avec la commande <b>gcc -Wall -o hello hello.c</b> :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">void</span>)
{
    printf(<span class="org-string">"hello"</span>);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Lancez l'exÃ©cutable avec <b>strace ./hello</b>. ImpressionÃ© ? Chacune des lignes que vous voyez correspond Ã  un appel systÃ¨me. <a href="https://strace.io/">strace</a> est un programme trÃ¨s utile qui vous dÃ©taille la liste des appels systÃ¨me Ã©mis, avec quels arguments et quelles sont les valeurs retournÃ©es. C'est un outil inestimable pour comprendre Ã  quels fichiers un programme accÃ¨de. Ã€ la fin, vous devriez voir une ligne semblable Ã  (1, "hello", 5hello). Voici le visage derriÃ¨re le masque d'un printf(). Vous n'Ãªtiez peut-Ãªtre pas trÃ¨s familiarisÃ© avec la fonction write(), puisque la plupart des dÃ©veloppeurs utilisent des bibliothÃ¨ques utilisateurs pour les entrÃ©es/sorties (tel que fopen, fputs, fclose). Si c'est la cas, jetez un coup d'oeil au manuel man 2 write. La deuxiÃ¨me section des manuels (man 2) correspond aux appels systÃ¨me (tel que kill() ou read()). La troisiÃ¨me section quant Ã  elle contient des appels Ã  des bibliothÃ¨ques utilisateurs (comme cosh() ou random()).
</p>

<p>
Vous pouvez mÃªme Ã©crire des modules pour remplacer les appels systÃ¨me du noyau, ce qu'on fera trÃ¨s prochainement. Les pirates utilisent souvent cette technique pour introduire un cheval de Troie au sein d'un systÃ¨me, mais vous pouvez utiliser votre module pour faire des choses bien pus innocentes, comme Ã©crire "You hou, Ã§a chatouille !" Ã  chaque fois que quelqu'un demande Ã  supprimer un fichier sur votre systÃ¨me.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Mode utilisateur, mode noyau</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Il existe bien des maniÃ¨res de rÃ©sumer un systÃ¨me d'exploitation. L'une d'entre elles est de le voir comme un gestionnaire de ressources, que ces ressources en questions soient une carte graphique, un disque dur ou mÃªme la mÃ©moire. Plusieurs programmes rentrent souvent en compÃ©tition avec la mÃªme ressource. Alors que je viens juste de sauvegarder ce document, updatedb a commencÃ© a mettre Ã  jour sa base de donnÃ©e locale. Mon Ã©diteur de texte et updatedb doivent tous les deux utiliser mon disque dur, en mÃªme temps. Le noyau doit gÃ©rer ces demandes concurrentes, et ne pas donner Ã  l'utilisateur tous les accÃ¨s ressources quand ce dernier le souhaite. Pour rÃ©pondre Ã  cete exigeance, un processeur peut gÃ©rer plusieurs modes. Chaque mode donne certains droits sur le systÃ¨me. Par exemple, l'architecture Intel 80386 d'Intel gÃ¨re ainsi quatre niveaux de privilÃ¨ges diffÃ©rents. Unix n'en utilise que deux : le niveau le plus haut (niveau 0, aussi appelÃ© mode noyau, ou superviseur), et le niveau le plus bas, appelÃ© niveau utilisateur.
</p>

<p>
Revenons sur les diffÃ©rences entre bibliothÃ¨ques utilisateur et appels systÃ¨me. Le plus souvent, vous utilisez une fonction d'une bibliothÃ¨que utilisateur en mode utilisateur. Cette fonction appelle un ou plusieurs appels systÃ¨me, et ces derniers, exÃ©cutÃ©s sur demande de l'utilisateur, sont lancÃ©s en mode noyau, puisqu'ils font partie du noyau. Au retour des appels systÃ¨me, l'exÃ©cution est de nouveau transfÃ©rÃ©e en mode utilisateur.
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Convention de nommage</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Quand vous Ã©crivez un petit programme en C, vous utilisez des variables avec un nom cohÃ©rent et qui sont facilement comprÃ©hensibles pour le lecteur. Mais si vous Ã©crivez des fonctions qui seront insÃ©rÃ©es dans un noyau, toutes vos variables globales seront confondues avec toutes les variables globales du systÃ¨me. Et comme deux variables ne peuvent Ãªtre homonymes, des conflits peuvent apparaÃ®tre. Quand un programme utilise de nombreuses variables globales qui ne sont pas assez prÃ©cises et que des conflits apparaissent, alors on parle de pollution de nommage. De maniÃ¨re gÃ©nÃ©rale, dans les projets imposants, un effort particulier doit Ãªtre portÃ© pour respecter une convention de nommage, afin de nommer les variables et les macros de maniÃ¨re unique et standardisÃ©e.
</p>

<p>
Quand vous Ã©crivez du code pour le noyau, mÃªme le plus petit module peut Ãªtre liÃ© avec tout le noyau, et le faire entiÃ¨rement dÃ©railler, alors il faut prendre ce problÃ¨me au sÃ©rieux. La meilleure maniÃ¨re de procÃ©der est de dÃ©clarer toutes vos variables de maniÃ¨res statiques et d'utiliser des prÃ©fixes bien dÃ©finis pour vos symboles. La convention pour le noyau est de crÃ©er des prÃ©fixes en minuscule. Et si vous ne voulez pas dÃ©clarer toutes vos variables en statiques, vous avez la possibilitÃ© de dÃ©clarer une table des symboles et de l'enregistrer dans le noyau. Nous y reviendrons plus tard.
</p>

<p>
Le fichier <b>/proc/kallsyms</b> dÃ©tient tous les symboles dont le noyau a conscience qui sont donc accessible depuis votre module, tant que ce dernier partage l'espace du noyau.
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Espace de code</h3>
<div class="outline-text-3" id="text-5-5">
<p>
La gestion de la mÃ©moire est un sujet trÃ¨s compliquÃ©, et la majoritÃ© du livre de O'Reilly's <b>Understanding The Linux Kernel</b> se rÃ©sume Ã  expliquer la gestion de mÃ©moire de Linux ! Pour continuer ce cours, vous n'aurez pas besoin d'Ãªtre des experts en gestion de mÃ©moire, mais il est important de savoir certaines choses avant de commencer Ã  crÃ©er de vrais modules.
</p>

<p>
Si vous ne vous Ãªtes jamais vraiment demandÃ© le mÃ©canisme derriÃ¨re une segfault, vous serez surpris de savoir que les pointeurs ne pointent pas vraiment vers un emplacement mÃ©moire rÃ©el. Quand un processus est crÃ©Ã©, le noyau lui attribue une partie de la mÃ©moire physique, que le processus va utiliser pour stocker son code d'exÃ©cution, ses variables, sa pile, ses allocations etc. Cette mÃ©moire commence Ã  l'adresse 0x0 (pour 0) et s'Ã©tend tant qu'elle en a besoin. L'espace mÃ©moire de deux processus ne peuvent pas se confondre. Imaginons donc un processus P1 qui accÃ¨de Ã  une adresse donnÃ©e, disons 0x7fca. Ce dernier n'accÃ©dera pas Ã  l'adresse physique rÃ©elle 0x7fca, mais Ã  un index qui porte ce nom, et qui pointe vers la zone mÃ©moire fournie par le noyau Ã  P1, Ã  une sorte de curseur dÃ©terminÃ© par la valeur 0x7fca. Un second processus P2 qui souhaite accÃ©der Ã  la mÃªme adresse 0x7fca, n'accÃ©dera donc pas du tout Ã  la mÃªme adresse physique que celle demandÃ©e par P1. Pour le commun des mortels, un processus ne peut pas accÃ©der Ã  l'espace mÃ©moire d'un autre processus, mais il y a pour les initiÃ©s une maniÃ¨re de procÃ©der qu'on va traiter un peu plus tard.
</p>

<p>
De mÃªme que chaque processus a son propre espace dans la mÃ©moire, le noyau a son espace rÃ©servÃ©. Comme un module est un code qui est insÃ©rÃ© dynamiquement, puis supprimÃ© du noyau, alors le module partage l'espace de code du noyau, et c'est donc dans cet espace que son code est insÃ©rÃ©. Par consÃ©quent, si votre module commet une erreur de segmentation, c'est tout le noyau qui est responsable de cette erreur. Et si par erreur vous dÃ©passer de votre espace mÃ©moire, c'est dans le noyau que vous Ã©crirez, et les rÃ©percussions peuvent Ãªtre catastrophiques. Soyez donc trÃ¨s attentifs car une erreur ici peut causer la mort dÃ©finitive de tout votre systÃ¨me.
</p>

<p>
Je tiens aussi Ã  insister sur le fait que ceci est vrai pour tous les systÃ¨mes d'exploitation conÃ§us sur base d'un noyau monolithique. Mais il existe aussi ce qu'on appelle les micro-noyaux, qui sont des systÃ¨mes d'exploitation oÃ¹ les modules ont un espace mÃ©moire qui leur est propre. Le GNU Hurd et le QNX Neutrino sont des exemples de micro-noyaux.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Les pilotes de pÃ©riphÃ©riques</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Les pilotes de pÃ©riphÃ©riques forment une catÃ©gorie de modules, qui fournissent des fonctionnalitÃ©s au matÃ©riel telle qu'un port sÃ©rie. Sur Unix, chaque pÃ©riphÃ©rique matÃ©riel est reprÃ©sentÃ© par un fichier, appelÃ© fichier de pÃ©riphÃ©rique dans le rÃ©pertoire /dev. Ce fichier fournit des moyens pour communiquer avec le matÃ©riel. Le pilote de pÃ©riphÃ©rique fournit donc au programme utilisateur une communication avec le matÃ©riel. Ainsi, le pilote de pÃ©riphÃ©rique de carte son es1370.o doit connecter le fichier de pÃ©riphÃ©rique /dev/sound Ã  la carte son Ensoniq IS1370. L'intÃ©rÃªt, c'est qu'un programme utilisateur comme mp3blaster pourra utiliser /dev/sound sans se soucier du modÃ¨le de carte son prÃ©sent sur la machine.
</p>

<p>
Dans Unix, tout est fichier. Votre pÃ©riphÃ©rique et son pilote seront tous deux reprÃ©sentÃ©s par leur propre fichier. Par la suite, il peut m'arriver d'employer le terme fichier de pÃ©riphÃ©rique pour parler du fichier associÃ© Ã  un pÃ©riphÃ©rique, et de fichier de pilote, ou juste pilote, pour parler du fichier associÃ© au pilote de votre pÃ©riphÃ©rique.
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-6-0-1" name="sec-5-6-0-1"></a>NumÃ©ros majeurs et numÃ©ros mineurs<br  /><div class="outline-text-5" id="text-5-6-0-1">
<p>
Jetons un Å“il Ã  certains fichiers associÃ©s aux pÃ©riphÃ©riques.
Voici les fichiers de pÃ©riphÃ©riques qui reprÃ©sentent les trois premiÃ¨res partitions d'un disque dur SATA :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">ls -l /dev/sda[1-3]</span>
brw-rw---- 1 root disk 8, 1 Mar 27 13:09 sda1
brw-rw---- 1 root disk 8, 2 Mar 27 13:09 sda2
brw-rw---- 1 root disk 8, 3 Mar 27 13:09 sda3
</pre>
</div>

<p>
Observez les colonnes de chiffres sÃ©parÃ©s par une virgule. Le premier chiffre est le numÃ©ro majeur du pÃ©riphÃ©rique. Le second chiffre est le numÃ©ro mineur. Le numÃ©ro majeur vous prÃ©cise quel pilote est utilisÃ© pour accÃ©der au matÃ©riel. Ã€ chaque pilote est donc attribuÃ© un numÃ©ro majeur unique, et tous les pÃ©riphÃ©riques partageant un numÃ©ro majeur partagent Ã©galement un pilote commun. Dans notre exemple, tous les numÃ©ro majeurs sont 8, parce que tous ces pÃ©riphÃ©riques sont contrÃ´lÃ©s par le mÃªme pilote.
</p>

<p>
Le numÃ©ro mineur quant Ã  lui est utilisÃ© par le pilote pour faire une distinction entre tous les pÃ©riphÃ©riques qu'il contrÃ´le. Pour revenir sur l'exemple plus haut, bien que les pÃ©riphÃ©riques aient un numÃ©ro majeur en commun, ils ont tous un numÃ©ro mineur diffÃ©rent parce que les pilote les voit comme des matÃ©riels diffÃ©rents.
</p>

<p>
Le monde des fichiers de pÃ©riphÃ©rique se divise en deux catÃ©gories : ceux en mode caractÃ¨re, et ceux en mode bloc. La diffÃ©rence vient du fait que les fichiers de pÃ©riphÃ©riques en mode bloc possÃ¨dent un tampon pour ses requÃªtes, afin qu'ils puissent choisir avec soin dans quel ordre rÃ©pondre Ã  ces requÃªtes. Cette stratÃ©gie est trÃ¨s importante dans le cas d'un pÃ©riphÃ©rique de stockage, comme un disque dur, oÃ¹ il est plus rapide de lire et d'Ã©crire des espaces mÃ©moire voisins, plutÃ´t que de rÃ©aliser les requÃªtes dans n'importe quel ordre. Une autre diffÃ©rence est que les fichiers de pÃ©riphÃ©riques en mode bloc ne peuvent recevoir et renvoyer que des donnÃ©es sous la forme de blocs (dont la taille varie selon le pÃ©riphÃ©rique) alors que les fichiers pÃ©riphÃ©riques en mode caractÃ¨re sont autorisÃ©s Ã  lire et Ã  Ã©crire autant d'octets qu'ils le souhaitent. La plupart des fichiers de pÃ©riphÃ©riques sont en mode caractÃ¨re, parce qu'ils n'ont pas besoin d'un tampon et qu'ils ne travaillent pas avec une taille fixe de donnÃ©e. Vous pouvez savoir quel est le type d'un fichier de pÃ©riphÃ©rique en regardant le premier caractÃ¨re affichÃ© sur une ligne par la commande `ls -l`. Si elle commence par un 'b', alors la ligne dÃ©crit un fichier de pÃ©riphÃ©rique en mode bloc. Si elle commence par un 'c', alors il s'agit du mode caractÃ¨re. Les fichiers de pÃ©riphÃ©riques vus prÃ©cÃ©demment sont donc en mode bloc. VoilÃ  quelques fichiers pÃ©riphÃ©riques de mode caractÃ¨re (les ports sÃ©ries) :
</p>

<div class="org-src-container">

<pre class="src src-sh">crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
</pre>
</div>

<p>
Si vous souhaitez savoir quels numÃ©ros majeurs ont dÃ©jÃ  Ã©tÃ© assignÃ©s, alors jetez un Å“il au fichier `/usr/src/linux/Documentation/devices.txt`.
</p>

<p>
Quand le systÃ¨me a Ã©tÃ© installÃ©, tous ces fichiers de pÃ©riphÃ©riques ont Ã©tÃ© crÃ©Ã©s par la commande mknod. Pour crÃ©er un nouveau fichier pÃ©riphÃ©rique en mode caractÃ¨re appelÃ© 'chocolat' avec les numÃ©ros majeurs et mineurs respectivement 12 et 2, vous n'avez qu'Ã  utiliser la commande mknod /dev/chocolat c 12 2. Vous n'Ãªtes pas obligÃ© d'insÃ©rer votre fichier de pÃ©riphÃ©rique dans le dossier /dev, mais comme c'est une convention utilisÃ©e par Linux, vous devriez le faire si vous souhaitez Ã©viter le bÃ»cher. Bien sÃ»r, quand vous crÃ©ez un fichier de pÃ©riphÃ©rique Ã  des fins d'essais ou de dÃ©bogage, vous pouvez le crÃ©er dans votre rÃ©pertoire de travail. Assurez-vous cependant de le placer au bon endroit quand vous aurez terminÃ© votre module.
</p>

<p>
Je souhaiterais cependant insister sur le fait qu'au moment oÃ¹ on accÃ¨de Ã  un fichier de pÃ©riphÃ©rique, le noyau utilise le numÃ©ro majeur du fichier pour dÃ©terminer quel pilote il doit utiliser. Cela veut donc dire que le noyau n'a pas Ã  se prÃ©occuper du numÃ©ro mineur, mais c'est le pilote de pÃ©riphÃ©rique qui regarde ce dernier afin de savoir quel Ã  quel matÃ©riel il doit accÃ©der.
</p>

<p>
D'ailleurs, quand je parle de "matÃ©riel", je veux parler d'une chose plus abstraite qu'une carte PCI que vous pouvez tenir dans votre main. Par exemple, regardez ces deux fichiers de pÃ©riphÃ©riques :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">ls -l mmcblk0*</span>
brw-rw---- 1 root disk 179, 0 Apr  7 23:45 mmcblk0
brw-rw---- 1 root disk 179, 1 Apr  7 23:45 mmcblk0p1
</pre>
</div>

<p>
Maintenant vour savez que ces deux fichiers de pÃ©riphÃ©riques sont des pÃ©riphÃ©riques de blocs et qu'ils sont gÃ©rÃ©s par le mÃªme pilote (numÃ©ro majeur 179). Vous savez peut-Ãªtre Ã©galement qu'ils ne reprÃ©sentent tous deux qu'une seule et mÃªme carte SD connectÃ©e Ã  votre ordinateur. Pourquoi alors deux fichiers pour une seule carte SD ? Une reprÃ©sente la carte SD dans son ensemble, et l'autre une partition de votre carte (mÃªme si cette derniÃ¨re ne contient qu'une partition). Donc mÃªme si techniquement ces deux fichiers ne reprÃ©sentent qu'un seul matÃ©riel physique, le noyau voit deux matÃ©riaux diffÃ©rents. Soyez donc avertis que le mot "matÃ©riel", peut, dans notre cas, Ã©voquer quelque chose d'abstrait.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Pilote de pÃ©riphÃ©rique en mode caractÃ¨re</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">La structure `file_operations`</h3>
<div class="outline-text-3" id="text-6-1">
<p>
La structure `file_operations` est dÃ©finie dans le fichier `linux/fs.h`, et contient des pointeurs vers des fonctions dÃ©finies par le pilote et qui effectue diverses opÃ©rations sur le pÃ©riphÃ©rique. Chaque champ de cette structure correspond Ã  une requÃªte particuliÃ¨re et permet au pilote d'appeler la bonne fonction selon la demande.
</p>

<p>
Par exemple, chaque pilote en mode caractÃ¨re peut dÃ©finir une fonction qui lit une information depuis le pÃ©riphÃ©rique. La structure `file_operations` contient l'adresse de la fonction de votre module qui va permettre d'effectuer cette opÃ©ration. Voici Ã  quoi ressemble une telle dÃ©finition pour le noyau 3.0 :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> {
    <span class="org-keyword">struct</span> <span class="org-type">module</span> *<span class="org-variable-name">owner</span>;
    loff_t (*llseek) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span>, <span class="org-type">int</span>);
    ssize_t (*read) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">char</span> <span class="org-variable-name">__user</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
    ssize_t (*write) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">__user</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
    ssize_t (*aio_read) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">iovec</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">loff_t</span>);
    ssize_t (*aio_write) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">iovec</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">loff_t</span>);
    <span class="org-type">int</span> (*iterate) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">dir_context</span> *);
    <span class="org-type">unsigned</span> <span class="org-type">int</span> (*poll) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">poll_table_struct</span> *);
    <span class="org-type">long</span> (*unlocked_ioctl) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">int</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">long</span> (*compat_ioctl) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">int</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">int</span> (*mmap) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">vm_area_struct</span> *);
    <span class="org-type">int</span> (*open) (<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
    <span class="org-type">int</span> (*flush) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">fl_owner_t</span> <span class="org-variable-name">id</span>);
    <span class="org-type">int</span> (*release) (<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
    <span class="org-type">int</span> (*fsync) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span>, <span class="org-type">loff_t</span>, <span class="org-type">int</span> <span class="org-variable-name">datasync</span>);
    <span class="org-type">int</span> (*aio_fsync) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-type">int</span> <span class="org-variable-name">datasync</span>);
    <span class="org-type">int</span> (*fasync) (<span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>);
    <span class="org-type">int</span> (*lock) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> *);
    ssize_t (*sendpage) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">page</span> *, <span class="org-type">int</span>, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *, <span class="org-type">int</span>);
    <span class="org-type">unsigned</span> <span class="org-type">long</span> (*get_unmapped_area)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">int</span> (*check_flags)(<span class="org-type">int</span>);
    <span class="org-type">int</span> (*flock) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> *);
    ssize_t (*splice_write)(<span class="org-keyword">struct</span> <span class="org-type">pipe_inode_info</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span> *, <span class="org-type">size_t</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span>);
    ssize_t (*splice_read)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span> *, <span class="org-keyword">struct</span> <span class="org-type">pipe_inode_info</span> *, <span class="org-type">size_t</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span>);
    <span class="org-type">int</span> (*setlease)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">long</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> **);
    <span class="org-type">long</span> (*fallocate)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-type">int</span> <span class="org-variable-name">mode</span>, <span class="org-type">loff_t</span> <span class="org-variable-name">offset</span>,
              <span class="org-type">loff_t</span> <span class="org-variable-name">len</span>);
    <span class="org-type">int</span> (*show_fdinfo)(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">f</span>);
};
</pre>
</div>

<p>
Toutes les opÃ©rations ne sont pas implantÃ©es par un pilote. Par exemple, un pilote qui gÃ¨re une carte graphique n'a pas besoin de lire un rÃ©pertoire. Le champ correspondant Ã  la lecture de rÃ©pertoire d'un pilote de carte graphique devrait Ãªtre assignÃ© Ã  la valeur NULL, afin que le noyau ait conscience que cette opÃ©ration n'est pas gÃ©rÃ©e par le pilote en question.
</p>

<p>
Il existe une extension de gcc qui vous permet d'assigner cette structure de maniÃ¨re plus confortable. Voici une autre maniÃ¨re, dÃ©jÃ  un peu plus moderne, de crÃ©er cette structure :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">fops</span> = {
        read: device_read,
        write: device_write,
        open: device_open,
        release: device_release
};
</pre>
</div>

<p>
Il existe Ã©galement une maniÃ¨re plus gracieuse depuis C99 d'assigner des Ã©lÃ©ments Ã  une structure, qui doit Ãªtre prÃ©fÃ©rÃ©e aux autre pour des raisons de lisibilitÃ© et de portabilitÃ©.
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">fops</span> = {
        .read = device_read,
        .write = device_write,
        .open = device_open,
        .release = device_release
};
</pre>
</div>

<p>
Cette mÃ©thode est claire, et vous devez avoir conscience que les membres de la structure qui ne sont pas explicitement assignÃ©s sont assignÃ©s Ã  NULL par gcc.
</p>

<p>
L'instance de la struct <b>file_operations</b> (et qui est donc utilisÃ©e pour implanter des fonctions de lecture, d'Ã©criture, d'ouverture&#x2026;) d'un module est communÃ©ment appelÃ©e fops.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">La structure `file`</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Chaque pÃ©riphÃ©rique est reprÃ©sentÃ© dans le noyau par une structure <b>file</b>, laquelle est dÃ©finie par <b>linux/fs.h</b>. Gardez en tÃªte que cette structure reste au niveau du noyau, et l'utilisateur n'y a jamais accÃ¨s. Il ne faut pas le confondre avec la structure FILE, qui est dÃ©finie par la glibc et qui, elle, ne devrait jamais apparaÃ®tre dans une fonction dans l'espace noyau. La structure <b>file</b> a un nom traÃ®tre : cette structure ne rÃ©prÃ©sente pas un "vrai" fichier sur le disque (ce dernier est reprÃ©sentÃ© par la structure <b>inode</b>).
</p>

<p>
L'instance de la struct <b>file</b> d'un module est communÃ©ment appelÃ© filp. Mais vous la verrez parfois porter le nom de file (struct <b>file</b> file). Je vous dÃ©conseille d'utiliser un tel nom.
</p>

<p>
Continuez et regardez dans vos sources la dÃ©finition de la structure <b>file</b>. La plupart des variables que vous voyez, comme la <b>dentry</b>, ne sont pas utilisÃ©es par les pilotes de pÃ©riphÃ©riques, et vous pouvez les ignorer. C'est parce que les pilotes ne remplissent pas directement de structure <b>file</b> mais ils ne font qu'utiliser les membres d'une structure <b>file</b> crÃ©Ã©e ailleurs.
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Enregistrer un pÃ©riphÃ©rique</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Comme nous l'avons dit plus tÃ´t, on peut accÃ©der Ã  un pÃ©riphÃ©rique Ã  travers des fichiers le reprÃ©sentant, appelÃ©s fichiers de pÃ©riphÃ©riques, localisÃ©s par convention dans le rÃ©pertoire <b>/dev</b>. Le numÃ©ro majeur vous renvoie Ã  quel pilote gÃ¨re le fichier de pÃ©riphÃ©rique. Le numÃ©ro mineur n'est utilisÃ© que par le pilote pour diffÃ©rencier les diffÃ©rents pÃ©riphÃ©riques sur lesquels il opÃ¨re.
</p>

<p>
Ajouter un pilote Ã  votre systÃ¨me veut dire l'enregistrer dans votre noyau. Ce qui revient Ã  y assigner un numÃ©ro majeur au moment de l'initialisation du module. C'est ce que vous faites en utilisant la fonction <b>register_chrdev</b>, dÃ©finie dans <b>linux/fs.h</b> :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">register_chrdev</span>(<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">major</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>, <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> *<span class="org-variable-name">fops</span>);
</pre>
</div>

<p>
Ici, <b>unsigned int major</b> est le numÃ©ro majeur que vous souhaitez avoir, <b>const char \</b> name* est le nom de votre pÃ©riphÃ©rique tel qu'il apparaÃ®tra dans le rÃ©pertoire <b>/proc/devices</b> et <b>struct file_operations \*fops</b> est un pointeur vers la structure <b>file_operations</b> de votre pilote. Un retour nÃ©gatif de cette fonction signifie que l'enregistrement a Ã©chouÃ©. Notez que nous n'avons pas fourni le numÃ©ro mineur Ã  cette fonction, pour la simple et bonne raison que le noyau ne se prÃ©occupe pas du numÃ©ro mineur. Encore une fois, il n'y a que notre pilote qui gÃ¨re le numÃ©ro mineur.
</p>

<p>
La vraie question maintenant est : comment demander un numÃ©ro majeur qui n'est pas dÃ©jÃ  utilisÃ© ? Une maniÃ¨re serait de regarder la liste de nos pÃ©riphÃ©riques et d'en choisir un non utilisÃ©. C'est une mauvaise solution parce que vous ne savez pas si le numÃ©ro que vous avez choisi ne sera pas utilisÃ© plus tard. La meilleure chose Ã  faire pour rÃ©gler ce problÃ¨me est de demander au noyau de vous assigner un numÃ©ro majeur dynamiquement.
</p>

<p>
Si vous passez le numÃ©ro majeur 0 Ã  la fonction `register_chrdev`, alors la valeur renvoyÃ©e sera le numÃ©ro majeur qui vous est allouÃ©. L'inconvÃ©nient de cette solution est que vous ne pouvez pas crÃ©er un fichier de pÃ©riphÃ©rique en avance, puisque vous ne savez pas alors quel numÃ©ro majeur vous allez utiliser. Il existe cependant des maniÃ¨res de contourner ce problÃ¨me. Par exemple, le pilote lui-mÃªme peut afficher la valeur assignÃ©e, et nous pouvons crÃ©er le fichier Ã  la main. Une autre maniÃ¨re de procÃ©der est la suivante : le pÃ©riphÃ©rique fraÃ®chement enregistrÃ© aura une ligne dÃ©diÃ©e dans le fichier <b>/proc/devices</b>, et on peut soit crÃ©er un fichier Ã  la main, soit crÃ©er un script shell pour lire ce fichier et ensuite crÃ©er le fichier de pÃ©riphÃ©rique correspondant. Une autre mÃ©thode est que notre fichier de pÃ©riphÃ©rique soit crÃ©Ã© par notre pilote en utilisant la fonction <b>device_create</b> aprÃ¨s une insertion rÃ©ussie, et qu'elle appelle la fonction <b>device_destroy</b>  durant l'appel de la fonction de sortie de votre module.
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Supprimer un pÃ©riphÃ©rique</h3>
<div class="outline-text-3" id="text-6-4">
<p>
On ne peut pas permettre qu'un module noyau soit enlevÃ© du noyau quand le superviseur le souhaite. Si jamais le fichier de pÃ©riphÃ©rique est ouvert par un processus et qu'Ã  ce moment on supprime le module du noyau, alors utiliser ce fichier conduirait Ã  faire un appel d'une fonction (par exemple pour une fonction de lecture/Ã©criture) Ã  une adresse mÃ©moire qui Ã©tait pointÃ©e par le fichier de pÃ©riphÃ©rique avant que ce dernier ne soit supprimÃ© du noyau. Dans le meilleur des cas, vous aurez droit Ã  un message d'erreur. Dans le pire cas, un autre module a Ã©tÃ© chargÃ© et vous accÃ©dez Ã  une autre fonction du noyau et les rÃ©sultats peuvent Ãªtre catastrophiques. Dans tous les cas, vous voulez Ã©viter que cette situation arrive.
</p>

<p>
En temps normal, quand vous refusez d'autoriser quelque chose, vous renvoyer un code d'erreur (un chiffre nÃ©gatif). Mais c'est impossible avec la fonction <b>cleanup_module</b> car celle-ci ne renvoie rien. Cependant, il existe un compteur qui garde une trace de tous les processus qui utilisent votre module. Vous pouvez voir sa valeur en regardant le troisiÃ¨me champ du fichier <b>/proc/modules</b>. Si cette valeur n'est pas nulle, alors la commande <b>rmmod</b> va Ã©chouer. Vous n'avez pas cependant Ã  vous en prÃ©occuper dans la fonction <b>cleanup_module</b> car cette vÃ©rification est faite pour vous par l'appel systÃ¨me <b>sys_delete_module</b> (dÃ©fini dans <b>linux/module.c</b>). Vous ne devriez par accÃ©der directement Ã  ce compteur, mais des fonctions dÃ©finies dans le fichier <b>linux/module.h</b> vous permettent de dÃ©crÃ©menter, d'incrÃ©menter ou d'obtenir la valeur de ce compteur :
</p>

<div class="org-src-container">

<pre class="src src-bash">* try_module_get(THIS_MODULE): IncrÃ©mente le compteur d'utilisation.
* module_put(THIS_MODULE): DecrÃ©mente le compteur d'utilisation.
</pre>
</div>

<p>
Il est essentiel de garder ce compteur Ã  jour. Si vous perdez sa valeur correcte, vous ne serez jamais Ã  mÃªme de dÃ©charger le module, et il ne vous restera plus qu'Ã  redÃ©marrer votre machine. Et je peux vous garantir que Ã§a vous arrivera tÃ´t ou tard durant votre dÃ©veloppement.
</p>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">chardev.c</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Le prochain code crÃ©e un pilote en mode caractÃ¨re appelÃ© <b>chardev</b>.
Vous pouvez lire son fichier de pÃ©riphÃ©rique via la commande suivante :
</p>

<div class="org-src-container">

<pre class="src src-bash">cat /proc/devices
</pre>
</div>

<p>
Et le pilote vous renverra le nombre de fois que le fichier de pÃ©riphÃ©rique a Ã©tÃ© lu. Notre module ne gÃ¨re pas l'Ã©criture vers notre fichier (tel que <b>echo "hi" &gt; /dev/hello</b>), mais il prend en compte ces essais et informe l'utilisateur que cette opÃ©ration n'est pas gÃ©rÃ©e. Ne vous inquiÃ©tez pas si vous ne savez pas comment gÃ©rer le tampon lors d'une Ã©criture sur notre fichier, ce n'est pas notre problÃ¨me. On ne fait ici que lire une donnÃ©e et afficher un accusÃ© de rÃ©ception.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  chardev.c: Cr&#195;&#169;e un p&#195;&#169;riph&#195;&#169;rique de type caract&#195;&#168;re en mode lecture-seule</span>
<span class="org-comment"> *  qui contient le nombre de lecture du fichier dev</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/device.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/uaccess.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/io.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/poll.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/cdev.h&gt;</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  Prototypes - Dans le meilleur des mondes, contenu dans un fichier .h</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>);
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>);
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">char</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">const</span> <span class="org-type">char</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SUCCESS</span> 0
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_NAME</span> <span class="org-string">"chardev"</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Nom du p&#195;&#169;riph&#195;&#169;rique tel qu'il apparait</span>
<span class="org-comment">                                 * dans in /proc/devices </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">BUF_LEN</span> 80              <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille maximum du message lu depuis le</span>
<span class="org-comment">                                 * p&#195;&#169;riph&#195;&#169;rique. </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Les variables globales sont d&#195;&#169;clar&#195;&#169;es statiques, et sont donc globales aux</span>
<span class="org-comment"> * yeux du code contenu dans le fichier.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> Major;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#195;&#169;ro majeur attribu&#195;&#169; &#195;  notre pilote </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Device_Open</span> = 0;     <span class="org-comment-delimiter">/* </span><span class="org-comment">Le fichier est-il d&#195;&#169;j&#195;  ouvert ?       *</span>
<span class="org-comment">                                 * Variable utilis&#195;&#169;e pour &#195;&#169;viter les     *</span>
<span class="org-comment">                                 * acc&#195;&#168;s concurrents au p&#195;&#169;riph&#195;&#169;riques    </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">msg</span>[BUF_LEN];       <span class="org-comment-delimiter">/* </span><span class="org-comment">La r&#195;&#169;ponse du p&#195;&#169;riph&#195;&#169;rique en cas de  *</span>
<span class="org-comment">                                 * lecture                               </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">msg_Ptr</span>;

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">class</span> *<span class="org-variable-name">cls</span>;

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">chardev_fops</span> = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#195;&#169;e au chargement du module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    Major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);

    <span class="org-keyword">if</span> (Major &lt; 0) {
        pr_alert(<span class="org-string">"Registering char device failed with %d\n"</span>, Major);
        <span class="org-keyword">return</span> Major;
    }

    pr_info(<span class="org-string">"I was assigned major number %d.\n"</span>, Major);

    cls = class_create(THIS_MODULE, DEVICE_NAME);
    device_create(cls, <span class="org-constant">NULL</span>, MKDEV(Major, 0), <span class="org-constant">NULL</span>, DEVICE_NAME);

    pr_info(<span class="org-string">"Device created on /dev/%s\n"</span>, DEVICE_NAME);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#195;&#169;e au d&#195;&#169;chargement du module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Supprime le p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    unregister_chrdev(Major, DEVICE_NAME);
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonctions :</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169;e quand un processus essaie d'ouvrir le fichier du p&#195;&#169;roph&#195;&#169;rique</span>
<span class="org-comment"> * par exemple "cat /dev/mycharfile"</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">counter</span> = 0;

    <span class="org-keyword">if</span> (Device_Open)
        <span class="org-keyword">return</span> -EBUSY;

    Device_Open++;
    sprintf(msg, <span class="org-string">"I already told you %d times Hello world!\n"</span>, counter++);
    msg_Ptr = msg;
    try_module_get(THIS_MODULE);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169;e quand un processus ferme le fichier associ&#195;&#169; au p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    Device_Open--; <span class="org-comment-delimiter">/* </span><span class="org-comment">Nous sommes maintenant pr&#195;&#170;t pour l'appel suivant </span><span class="org-comment-delimiter">*/</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * D&#195;&#169;cr&#195;&#169;mente le compteur d'utilisation du fichier,</span>
<span class="org-comment">     * sans quoi une fois que vous aurez ouvert votre</span>
<span class="org-comment">     * fichier, vous ne pourrez plus jamais d&#195;&#169;charger</span>
<span class="org-comment">     * votre module</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    module_put(THIS_MODULE);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169;e quand un processus, qui a d&#195;&#169;j&#195;  ouvert le fichier, essaie de lire</span>
<span class="org-comment"> * son contenu.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">Voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">Tampon &#195;  remplir         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille du tampon         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nombres d'octets &#195;&#169;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">int</span> <span class="org-variable-name">bytes_read</span> = 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si la t&#195;&#170;te de lecture atteint la fin du message,</span>
<span class="org-comment">     * Renvoyer la valeur 0 signifie la "fin du fichier"</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (*msg_Ptr == 0)
        <span class="org-keyword">return</span> 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Insertion des donn&#195;&#169;es dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (length &amp;&amp; *msg_Ptr) {

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Le tampon est dans l'espace m&#195;&#169;moire de l'utilisateur, mais pas</span>
<span class="org-comment">         * dans l'espace noyau. C'est pourquoi l'assignement via pointeur '*'</span>
<span class="org-comment">         * ne fonctionnera pas. Nous devons donc utiliser la fonction put_user</span>
<span class="org-comment">         * qui copie des donn&#195;&#169;es depuis l'espace noyau vers l'espace</span>
<span class="org-comment">         * utilisateur.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        put_user(*(msg_Ptr++), buffer++);

        length--;
        bytes_read++;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La plupart des fonctions de lecture renvoient le nombre d'octets</span>
<span class="org-comment">     * &#195;&#169;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> bytes_read;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169;e quand un processus &#195;&#169;crit dans le fichier associ&#195;&#169; au p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> * par exemple: echo "hi" &gt; /dev/hello</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>,
                            <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buff</span>,
                            <span class="org-type">size_t</span> <span class="org-variable-name">len</span>,
                            <span class="org-type">loff_t</span> * <span class="org-variable-name">off</span>)
{
    pr_alert(<span class="org-string">"Sorry, this operation isn't supported.\n"</span>);
    <span class="org-keyword">return</span> -EINVAL;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Ecrire des modules pour plusieurs versions du noyau.</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Les appels systÃ¨me, qui font l'interface primaire entre le noyau et les processus, restent gÃ©nÃ©ralement similaires selon les versions de Linux. Un nouvel appel systÃ¨me peut Ãªtre rajoutÃ©, mais, sauf exception rarissime, les appels systÃ¨me dÃ©jÃ  implantÃ©s ne seront pas modifiÃ©s. Cette stratÃ©gie est nÃ©cessaire pour la compatibilitÃ©; une nouvelle version Linux doit faire fonctionner des processus crÃ©Ã©s pour une version plus vieille. Dans la plupart des cas, les fichiers de pÃ©riphÃ©rique resteront les mÃªmes. Cependant, les interfaces internes au noyau peuvent changer entre chaque version.
</p>

<p>
Les versions du noyau sont dÃ©finies par trois numÃ©ros x.y.z. Le numÃ©ro x reprÃ©sente le numÃ©ro majeur, le numÃ©ro y reprÃ©sente le numÃ©ro mineur et le numÃ©ro z reprÃ©sente la correction. Le numÃ©ro x n'est qu'un symbole et deux versions diffÃ©rentes n'impliquent pas nÃ©cessairement un changement profond du noyau. Ainsi, le changement du noyau de la version 2.6 en 3.0 n'a rien apportÃ© de rÃ©volutionnaire au noyau, alors que le changement de version 2.4 en 2.6 a, lui, apportÃ© beaucoup de changement, sans que le numÃ©ro majeur ne change.
</p>

<p>
Les versions mineures du noyau Linux sont divisÃ©es entre les versions stables (y est un numÃ©ro pair) et les versions de dÃ©veloppements (y est un numÃ©ro impair). Ces derniÃ¨res contiennent toutes les idÃ©es originales, y compris celles qui seront par la suite reconsidÃ©rÃ©es comme des erreurs, ou qui seront modifiÃ©es. Par consÃ©quent, si vous travaillez avec ces versions instables, sachez que les interfaces sur lesquelles vous travaillez risquent de changer, c'est pourquoi vous ne pouvez donc pas trop compter sur elles. C'est la raison pour laquelle je ne traiterai pas ces versions instables dans ce livre : elles impliquent trop de changement qui ne seront qu'Ã©phÃ©mÃ¨res et Ã§a conduirait Ã  trop de travail pour mettre Ã  jour ce livre. Les versions stables cependant reposent sur une interface immuable, quel que soit le numÃ©ro de correction (le numÃ©ro z).
</p>

<p>
DiffÃ©rentes versions du noyau impliquent de multiples disparitÃ©s, et si vous souhaitez crÃ©er du code qui soit compatible avec de nombreuses versions du noyau, vous devrez alors utiliser des consignes conditionnelles de compilation. La maniÃ¨re de procÃ©der et de comparer deux macros : LINUX_VERSION_CODE et KERNEL_VERSION. Pour une version du noyau x.y.z, la valeur de cette macro sera (x\*(2^16))+(y\*(2^8))+z.
</p>

<p>
Les versions prÃ©cÃ©dentes de ce guide vous montraient prÃ©cisÃ©ment comment Ã©crire du code compatible avec des versions antÃ©rieures, mais nous avons dÃ©cidÃ© de briser cette tradition. Les lecteurs dÃ©sireux d'un tel savoir devraient donc lire une version de ce guide qui corresponde Ã  leur noyau. On a donc dÃ©cidÃ© d'une gestion de version pour ce guide identique au noyau (en ce qui concerne les numÃ©ros majeurs et mineurs). En ce qui concerne les correctifs, nous utilisons nos propres correctifs indÃ©pendamment du noyau. Si vous cherchez un guide pour le noyau 2.6.39, vous devrez donc chercher le guide dans sa version 2.6.z (le numÃ©ro de correction importe peu). Assurez-vous juste d'avoir le correctif le plus Ã  jour du guide, et du noyau.
</p>

<p>
Vous aurez peut-Ãªtre remarquÃ© que certaines versions du noyau comportent quatre numÃ©ros de versions. Dans ce cas, les trois premiÃ¨res versions ont le mÃªme sens qu'avant, mais la quatriÃ¨me indique des mises Ã  jours de sÃ©curitÃ©, en attendant qu'un correctif stable sorte.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Le systÃ¨me de fichier /proc</h2>
<div class="outline-text-2" id="text-7">
<p>
Dans Linux, il y existe des mÃ©canismes pour que le noyau et ses modules envoient des informations aux processus : le systÃ¨me de fichier /proc. Ã€ l'origine crÃ©Ã© pour permettre un accÃ¨s aisÃ© aux informations des processus (d'oÃ¹ le nom), ce mÃ©canisme est dÃ©sormais utilisÃ© de toute part dans le noyau quand ce dernier doit signaler quelque chose, tel que <b>proc/modules</b>, qui fournit la liste des modules, ou <b>proc/meminfo</b> qui affiche des statistiques d'utilisation de la mÃ©moire.
</p>

<p>
La maniÃ¨re d'utiliser le systÃ¨me de fichier proc est similaire Ã  la mÃ©thode utilisÃ©e avec les pilotes de pÃ©riphÃ©riques : une structure est crÃ©Ã©e, laquelle contient toutes les informations requises par le fichier <b>/proc</b>, y compris des pointeurs vers les fonctions qui vont gÃ©rer notre fichier (dans notre cas, il n'existe qu'un pointeur : celui qui est appelÃ© quand un programme essaie de lire le fichier <b>/proc</b>). Ensuite, init_module enregistre la structure au sein du noyau et cleanup_module la supprime.
</p>

<p>
Un systÃ¨me de fichier standard dÃ©crira des documents qui seront localisÃ©s sur le disque plutÃ´t qu'en mÃ©moire (contrairement au systÃ¨me de fichier <b>/proc</b>).  Dans le cas d'un fichier sur le disque, l'index du noeud (inode) contiendra un pointeur vers la position, au sein du disque, oÃ¹ le fichier dÃ©crit par l'inode est localisÃ©. L'inode possÃ¨de Ã©galement certaines informations relatives au fichier, tel que les permissions du fichier.
</p>

<p>
Parce qu'aucun code ne sera appelÃ© quand le fichier sera ouvert, ou fermÃ©, on ne peut mettre en place les fonctions try_module_get et try_module_put dans notre module. C'est pourquoi il n'existe aucun moyen d'Ã©viter les consÃ©quences, si un fichier est ouverte, puis que le module est enlevÃ© du noyau.
</p>

<p>
VoilÃ  un exemple Ã©lÃ©mentaire qui vous montre comment utiliser un fichier <b>/proc</b>. C'est le "HelloWorld" du systÃ¨me de fichier <b>/proc</b>. Cette mÃ©thode contient trois parties. La premiÃ¨re, c'est de crÃ©er le fichier <b>/proc/helloworld</b> dans la fonction init_module. La seconde, c'est de renvoyer une valeur (et un tampon) quand le fichier <b>/proc/helloworld</b> est lu, via la fonction de rappel <b>procfile_read</b>. La troisiÃ¨me, c'est de supprimer le fichier <b>/proc/helloworld</b> dans la fonction cleanup_module.
</p>

<p>
Le fichier <b>/proc/helloworld</b> sera crÃ©Ã© via la fonction <b>proc_create</b> quand le module sera chargÃ©. La valeur renvoyÃ©e est une <b>struct proc_dir_entry</b>, et elle sera utilisÃ©e pour configurer le fichier <b>/proc/helloworld</b> (par exemple, pour y inscrire le propriÃ©taire du fichier). Une valeur nulle renvoyÃ©e signifie que la crÃ©ation a Ã©chouÃ©.
</p>

<p>
Ã€ chaque fois que le fichier <b>/proc/helloworld</b> sera lu, alors la fonction <b>procfile_read</b> sera appelÃ©e. Deux paramÃ¨tres de cette function sont trÃ¨s importants : le tampon (le premier paramÃ¨tre) et le curseur (le troisiÃ¨me paramÃ¨tre). Ainsi, sera modifiÃ© le contenu du tampon passÃ© par le processus lecteur du fichier (par exemple, une commande cat) en fonction du curseur, qui dÃ©signe la position actuelle de la tÃªte de lecture au sein du fichier. Attention cependant, si la fonction ne renvoie pas une valeur nulle, alors cette fonction sera rappelÃ©e. Ainsi, si cette fonction ne renvoie jamais 0, alors cette fonction sera appelÃ©e en boucle infiniment.
</p>

<div class="org-src-container">

<pre class="src src-txt"># cat /proc/helloworld
HelloWorld!
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> procfs1.c</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">procfs_name</span> <span class="org-string">"helloworld"</span>

<span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Notre Fichier Proc </span><span class="org-comment-delimiter">*/</span>


<span class="org-type">ssize_t</span> <span class="org-function-name">procfile_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filePointer</span>,<span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                      <span class="org-type">size_t</span> <span class="org-variable-name">buffer_length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>=0;
    <span class="org-keyword">if</span>(strlen(buffer) ==0) {
        pr_info(<span class="org-string">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span class="org-string">"HelloWorld!\n"</span>,<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>));
        ret=<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>);
    }
    <span class="org-keyword">return</span> ret;

}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_file_fops</span> = {
    .owner = THIS_MODULE,
    .read  = procfile_read,
};

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(procfs_name,0644,<span class="org-constant">NULL</span>,&amp;proc_file_fops);
    <span class="org-keyword">if</span>(<span class="org-constant">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span class="org-string">"Error:Could not initialize /proc/%s\n"</span>,procfs_name);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    pr_info(<span class="org-string">"/proc/%s created\n"</span>, procfs_name);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span class="org-string">"/proc/%s removed\n"</span>, procfs_name);
}
</pre>
</div>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Lire et Ã©crire un fichier /proc</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Nous avons vu un exemple rudimentaire d'un fichier /proc, <b>/proc/helloworld</b>, qu'on ne pouvait que lire. Mais il est Ã©galement possible d'Ã©crire au sein d'un fichier /proc file. De la mÃªme maniÃ¨re qu'une lecture, une fonction est appelÃ©e quand une Ã©criture est demandÃ©e sur le fichier /proc. Mais il existe une lÃ©gÃ¨re diffÃ©rence avec la fonction de lecture, oÃ¹ les donnÃ©es viennent de l'espace utilisateur, et vous devez donc importer ces donnÃ©es depuis l'espace utilisateur vers l'espace noyau (grÃ¢ce aux fonctions copy_from_user ou get_user).
</p>

<p>
La raison pour laquelle l'usage de la fonction copy_from_user ou get_user est nÃ©cessaire vient du fait qu'au sein de Linux, la mÃ©moire est segmentÃ©e (en tout cas pour les architectures Intel, mais ceci peut Ãªtre diffÃ©rent sur d'autres processeurs). Ce qui signifie qu'un pointeur, ne rÃ©fÃ©rence pas une location dans la mÃ©moire, mais une location dans un segment de la mÃ©moire, et vous devez savoir Ã  quel segment il appartient. Il existe un segment mÃ©moire pour le noyau, et un segment mÃ©moire pour chaque processus.
</p>

<p>
Un processus n'a accÃ¨s qu'Ã  son propre segment mÃ©moire, afin qu'Ã  l'Ã©criture d'un simple programme Ã  lancer en tant que processus, le dÃ©veloppeur n'ait pas Ã  se prÃ©occuper des segments mÃ©moires. Quand vous Ã©crivez un noyau module, vous cherchez la plupart du temps Ã  accÃ©der au segment mÃ©moire du noyau, lequel est gÃ©rÃ© par le systÃ¨me. Cependant, quand le contenu d'un tampon mÃ©moire doit Ãªtre passÃ© d'un segment mÃ©moire Ã  un autre, en l'occurrence du processus en train de tourner vers le noyau, alors la fonction du noyau reÃ§oit un pointeur vers un espace du segment mÃ©moire du processus qui le demande. Les macros put_user et get_user permettent au noyau d'accÃ©der Ã  ce segment mÃ©moire. Ces fonctions ne gÃ¨rent qu'un seul caractÃ¨re. Vous pouvez maniez plusieurs caractÃ¨res avec les fonctions copy_to_user et copy_from_user. Comme le tampon (dans une fonction de lecture ou d'Ã©criture) est situÃ© dans le segment mÃ©moire du noyau, vous n'avez pas besoin de gÃ©rer ces diffÃ©rents espaces dans le cas d'une lecture, car les donnÃ©es sont dÃ©jÃ  dans l'espace noyau. Cependant, dans le cas d'une Ã©criture, vous aurez besoin d'importer ces donnÃ©es car elles viennent de l'espace utilisateur.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-doc">/**</span>
<span class="org-doc"> *  procfs2.c -  Cr&#195;&#169;&#195;&#169; un "fichier"</span>
<span class="org-doc"> */</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire parce qu'on utilise le proc fs  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour la fonction copy_from_user </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_MAX_SIZE</span>         1024
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_NAME</span>             <span class="org-string">"buffer1k"</span>

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette structure contient les informatiosn relative au fichier /proc</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Notre Fichier Proc </span><span class="org-comment-delimiter">*/</span>

<span class="org-doc">/**</span>
<span class="org-doc"> * Le tampon qui contiendra les caract&#195;&#168;res pour ce module</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">procfs_buffer</span>[PROCFS_MAX_SIZE];

<span class="org-doc">/**</span>
<span class="org-doc"> * La taille du tampon</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">procfs_buffer_size</span> = 0;

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e quand le fichier /proc est lu</span>
<span class="org-doc"> */</span>
<span class="org-type">ssize_t</span> <span class="org-function-name">procfile_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filePointer</span>,<span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                      <span class="org-type">size_t</span> <span class="org-variable-name">buffer_length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>=0;
    <span class="org-keyword">if</span>(strlen(buffer) ==0) {
        pr_info(<span class="org-string">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span class="org-string">"HelloWorld!\n"</span>,<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>));
        ret=<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>);
    }
    <span class="org-keyword">return</span> ret;
}


<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e quand on &#195;&#169;crit dans le fichier /proc</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfile_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buff</span>,
                              <span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">off</span>)
{
    procfs_buffer_size = len;
    <span class="org-keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;

    <span class="org-keyword">if</span> (copy_from_user(procfs_buffer, buff, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;

    procfs_buffer[procfs_buffer_size] = <span class="org-string">'\0'</span>;
    <span class="org-keyword">return</span> procfs_buffer_size;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_file_fops</span> = {
    .owner = THIS_MODULE,
    .read  = procfile_read,
    .write  = procfile_write,
};

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e quand le module est charg&#195;&#169;</span>
<span class="org-doc"> */</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_NAME,0644,<span class="org-constant">NULL</span>,&amp;proc_file_fops);
    <span class="org-keyword">if</span>(<span class="org-constant">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span class="org-string">"Error:Could not initialize /proc/%s\n"</span>,PROCFS_NAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    pr_info(<span class="org-string">"/proc/%s created\n"</span>, PROCFS_NAME);
    <span class="org-keyword">return</span> 0;
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e quand le module est d&#195;&#169;charg&#195;&#169;</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span class="org-string">"/proc/%s enleve\n"</span>, PROCFS_NAME);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">GÃ©rer un fichier /proc avec un systÃ¨me de fichier standard</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Nous avons vu comment lire et Ã©crire dans un fichier /proc, avec l'interface du systÃ¨me de fichier proc. Mais il est Ã©galement possible de gÃ©rer un fichier /proc avec des inodes. Pour cela, il faut utiliser des fonctions avancÃ©es, telles que les permissions.
</p>

<p>
Dans Linux, il existe un mÃ©canisme standard pour l'enregistrement des systÃ¨mes de fichiers. Comme chaque systÃ¨me de fichier doit avoir ses propres fonctions pour gÃ©rer les inodes et les opÃ©rations sur les fichiers, il existe une structure particuliÃ¨re qui contient les pointeurs vers toutes ces fonctions, Ã  savoir struct <b>inode_operations</b>, laquelle inclut un pointeur vers une struct file_operations.
</p>

<p>
La diffÃ©rence entre une opÃ©ration sur une inode et une opÃ©ration sur un fichier tient au fait qu'une opÃ©ration sur un fichier intervient sur le fichier lui-mÃªme, alors qu'une opÃ©ration sur son inode n'interagit avec le rÃ©fÃ©rencement du fichier, tel que la crÃ©ation de liens vers le fichier.
</p>

<p>
Dans /proc, quand nous enregistrons un nouveau fichier, nous pouvons spÃ©cifier quelle structure inode_operations sera utilisÃ©e pour interagir avec le fichier. Cette derniÃ¨re contient un pointeur vers une structure file_operations, qui elle-mÃªme contient des pointeurs vers nos fonctions procfs_read et procfs_write.
</p>

<p>
Une autre partie intÃ©ressante est la fonction module_permission. Cette derniÃ¨re est appelÃ©e quand un processus essaie d'accÃ©der Ã  notre fichier /proc. Cette fonction accorde ou refuse la permission d'accÃ©der Ã  notre fichier. Pour l'instant, cette dÃ©cision n'est basÃ©e que sur l'opÃ©ration demandÃ©e et le numÃ©ro de l'utilisateur (qu'on peut connaÃ®tre via un pointeur vers une structure qui contient toutes les informations sur le processus qui tourne actuellement), mais on pourrait baser cette dÃ©cision sur toutes les conditions que l'on souhaite, telles que l'heure, ce que d'autres processus font avec ce fichier, les derniÃ¨res donnÃ©es qu'on a reÃ§ues, ou bien d'autres encore.
</p>

<p>
Il faut Ã©galement noter que les rÃ´les des fonctions de lecture et d'Ã©criture sont inversÃ©s dans le noyau. En effet, une fonction de lecture doit renvoyer une valeur lue, alors qu'une fonction d'Ã©criture doit recevoir des donnÃ©es Ã  Ã©crire. La fonction de lecture envoie des donnÃ©es, l'Ã©criture en reÃ§oit. La raison pour laquelle cette notion est inversÃ©e vient du fait que par convention, les fonctions de lecture et d'Ã©criture sont nommÃ©es du point de vue de l'utilisateur. Si un processus utilisateur veut lire une information via le noyau, ce dernier doit renvoyer cette information Ã  l'utilisateur, et inversement.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment">    procfs3.c</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_MAX_SIZE</span>         2048
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_ENTRY_FILENAME</span>   <span class="org-string">"buffer2k"</span>

<span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>;
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">procfs_buffer</span>[PROCFS_MAX_SIZE];
<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">procfs_buffer_size</span> = 0;

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfs_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>, <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">offset</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">finished</span> = 0;
    <span class="org-keyword">if</span>(finished)
    {
        pr_debug(<span class="org-string">"procfs_read: END\n"</span>);
        finished = 0;
        <span class="org-keyword">return</span> 0;
    }
    finished = 1;
    <span class="org-keyword">if</span>(copy_to_user(buffer, procfs_buffer, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;
    pr_debug(<span class="org-string">"procfs_read: read %lu bytes\n"</span>, procfs_buffer_size);
    <span class="org-keyword">return</span> procfs_buffer_size;
}
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfs_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,  <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                            <span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">off</span>)
{
    <span class="org-keyword">if</span>(len&gt;PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;
    <span class="org-keyword">else</span>
        procfs_buffer_size = len;
    <span class="org-keyword">if</span>(copy_from_user(procfs_buffer, buffer, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;
    pr_debug(<span class="org-string">"procfs_write: write %lu bytes\n"</span>, procfs_buffer_size);
    <span class="org-keyword">return</span> procfs_buffer_size;
}
<span class="org-type">int</span> <span class="org-function-name">procfs_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    try_module_get(THIS_MODULE);
    <span class="org-keyword">return</span> 0;
}
<span class="org-type">int</span> <span class="org-function-name">procfs_close</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    module_put(THIS_MODULE);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">File_Ops_4_Our_Proc_File</span> = {
    .read       = procfs_read,
    .write      = procfs_write,
    .open       = procfs_open,
    .release    = procfs_close,
};

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_ENTRY_FILENAME, 0644, <span class="org-constant">NULL</span>,&amp;File_Ops_4_Our_Proc_File);
    <span class="org-keyword">if</span>(Our_Proc_File == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Erreur : Impossible d'initialiser /proc/%s\n"</span>, PROCFS_ENTRY_FILENAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_debug(<span class="org-string">"/proc/%s cree\n"</span>, PROCFS_ENTRY_FILENAME);
    <span class="org-keyword">return</span> 0;
}
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s removed\n"</span>, PROCFS_ENTRY_FILENAME);
}
</pre>
</div>

<p>
Si vous souhaitez en apprendre plus sur le systÃ¨me de fichier procfs, sachez que procfs a Ã©tÃ© rendu obsolÃ¨te et qu'il est maintenant conseillÃ© d'utiliser sysfs (que nous verrons dans un prochain chapitre). Si malgrÃ© tout vous souhaitez en apprendre plus, il existe une documentation que je vous recommande pour le systÃ¨me de fichier procfs au sein de linux/Documentation/DocBook/. Utilisez la commande make help Ã  la racine de vos sources Linux pour apprendre comment convertir ces informations dans votre format de prÃ©dilection. Par exemple : make htmldocs. Je vous conseille d'utiliser ce mÃ©canisme si vous souhaitez documenter des informations relatives au noyau.
</p>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">GÃ©rer un fichier /proc avec seq_file</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Comme vous l'avez remarquÃ©, crÃ©er un fichier /proc tient plus du parcours du combattant que de la balade enfantine. C'est pourquoi une API appelÃ©e seq_file a Ã©tÃ© implantÃ©e, afin d'aider les programmeurs. Le principe d'utilisation de cette API repose sur des sÃ©quences, qui sont composÃ©es de trois fonctions : start(), next(), et stop(). L'API seq_file commencera une sÃ©quence quand le fichier /proc associÃ© sera lu.
</p>

<p>
Une sÃ©quence commence avec l'appel Ã  la fonction start(). Si la valeur renvoyÃ©e est non nulle, alors la fonction next() est appelÃ©e. Cette fonction est un itÃ©rateur. Son but est de parcourir les donnÃ©es de notre fichier. Ã€ chaque fois que la fonction next() est appelÃ©e, la fonction show() l'est Ã©galement. Cette derniÃ¨re Ã©crit la valeur des donnÃ©es lues dans le tampon lu par l'utilisateur. La fonction next() est appelÃ©e continuellement jusqu'Ã  ce qu'elle renvoie une valeur nulle. Quand la fonction next renvoie une valeure nulle, alors la sÃ©quence se termine par l'appel Ã  la fonction stop().
</p>

<p>
Attention cependant : Quand une sÃ©quence se termine, une autre est lancÃ©e. Ce qui signifie quÃ  la fin de la fonction stop(), la fonction start() est rappelÃ©e. Cette boucle se termine quand la fonction start() renvoie une valeur nulle. Vous pouvez voir un schÃ©ma dÃ©crivant le comportement dÃ©crit plus haut intitulÃ© "Comment seq_file fonctionne".
</p>


<div class="figure">
<p><img src="img/seq_file.png" alt="seq_file.png" />
</p>
</div>

<p>
Seq_file fournit des fonctions basiques pour la structure file_operations, telles que seq_read, seq_lseek ou d'autres. Mais aucune fonction n'est fournit pour Ã©crire dans notre fichier. Vous pouvez bien sÃ»r utiliser les mÃªmes mÃ©thodes que dans notre exemple prÃ©cÃ©dent pour le faire.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-doc">/**</span>
<span class="org-doc"> *  procfs4.c -  Cree un "fichier" dans /proc</span>
<span class="org-doc"> *      Ce programme utilise la biblioth&#195;&#168;que seq_file pour g&#195;&#169;rer</span>
<span class="org-doc"> *      le fichier /proc</span>
<span class="org-doc"> */</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>      <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour utiliser le proc fs </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/seq_file.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour seq_file </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROC_NAME</span>       <span class="org-string">"iter"</span>

MODULE_AUTHOR(<span class="org-string">"Philippe Reynes"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e au d&#195;&#169;but d'une s&#195;&#169;quence, par exemple quand :</span>
<span class="org-doc"> *      - Le fichier /proc est lu (pout la premi&#195;&#168;re fois)</span>
<span class="org-doc"> *      - A la fin de la la fonction stop (fin de s&#195;&#169;quence)</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> *<span class="org-function-name">my_seq_start</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">pos</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">counter</span> = 0;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Est-ce qu'on commande une nouvelle s&#195;&#169;quence ? </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> ( *pos == 0 ) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Si oui =&gt; Renvoie une valeur non nulle pour d&#195;&#169;marrer la s&#195;&#169;quence </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">return</span> &amp;counter;
    }
    <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Sinon =&gt; Signifie la fin de la s&#195;&#169;quence, renvoie NULL pour</span>
<span class="org-comment">         * arr&#195;&#170;ter la lecture</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        *pos = 0;
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e apr&#195;&#168;s le d&#195;&#169;but la s&#195;&#169;quence.</span>
<span class="org-doc"> * Elle est appel&#195;&#169;e en boucle jusqu'&#195;  ce qu'elle renvoie la valeur NULL.</span>
<span class="org-doc"> * Cette valeur signifie la fin de la s&#195;&#169;quence.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> *<span class="org-function-name">my_seq_next</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">pos</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> *<span class="org-variable-name">tmp_v</span> = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)v;
    (*tmp_v)++;
    (*pos)++;
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#195;&#169;e &#195;  la fin de la s&#195;&#169;quence.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">my_seq_stop</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Rien &#195;  faire, on utilise une variable</span>
<span class="org-comment">     * statique dans la fonction start()</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#195;&#169;e &#195;  chaque &#195;&#169;tape d'une s&#195;&#169;quence.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">my_seq_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
    <span class="org-type">loff_t</span> *<span class="org-variable-name">spos</span> = (<span class="org-type">loff_t</span> *) v;

    seq_printf(s, <span class="org-string">"%Ld\n"</span>, *spos);
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure d&#195;&#169;finit les fonctions qui g&#195;&#168;reront la s&#195;&#169;quence</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">my_seq_ops</span> = {
        .start = my_seq_start,
        .next  = my_seq_next,
        .stop  = my_seq_stop,
        .show  = my_seq_show
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#195;&#169;e quand le fichier /proc sera ouvert</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">my_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-keyword">return</span> seq_open(file, &amp;my_seq_ops);
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure d&#195;&#169;finit les fonctions qui g&#195;&#169;reront le fichier /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">my_file_ops</span> = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = seq_release
};


<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#195;&#169;e quand le module sera charg&#195;&#169;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">entry</span>;

    entry = proc_create(PROC_NAME, 0, <span class="org-constant">NULL</span>, &amp;my_file_ops);
    <span class="org-keyword">if</span>(entry == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROC_NAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Error: Could not initialize /proc/%s\n"</span>, PROC_NAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#195;&#169;e quand le module sera d&#195;&#169;charg&#195;&#169; du noyau</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    remove_proc_entry(PROC_NAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s supprime\n"</span>, PROC_NAME);
}
</pre>
</div>

<p>
Si vous dÃ©sirez plus d'informations, je vous conseille ce lien :
</p>

<ul class="org-ul">
<li><a href="http://lwn.net/Articles/22355/">http://lwn.net/Articles/22355/</a>
</li>

<li><a href="http://www.kernelnewbies.org/documents/seq_file_howto.txt">http://www.kernelnewbies.org/documents/seq_file_howto.txt</a>
</li>
</ul>

<p>
Vous pouvez Ã©galement lire le code de fs/seq_file.c au sein du noyau.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">sysfs : Interagissez avec votre module</h2>
<div class="outline-text-2" id="text-8">
<p>
<i>sysfs</i> vous permet d'interagir avec le noyau depuis l'espace utilisateur, via la lecture ou l'Ã©criture de variable au sein de modules. Ã‡a peut Ãªtre trÃ¨s utile Ã  des fins de dÃ©bogage, ou encore cela peut vous servir d'interface pour vos applications ou vos scripts. Vous pouvez trouvez des rÃ©pertoires et des fichiers sysfs au sein du rÃ©pertoire <i>sys</i> de votre systÃ¨me.
</p>

<div class="org-src-container">

<pre class="src src-bash">ls -l /sys
</pre>
</div>

<p>
L'Ã©ternel exemple du module hello world incluant la crÃ©ation d'une variable accessible via sysfs est fourni plus bas :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * hello-sysfs.c sysfs example</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kobject.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sysfs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/string.h&gt;</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">mymodule</span>;

<span class="org-comment-delimiter">/* </span><span class="org-comment">La variable que vous souhaitez pouvoir modifier </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myvariable</span> = 0;

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">myvariable_show</span>(<span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">kobj</span>,
                               <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> *<span class="org-variable-name">attr</span>,
                               <span class="org-type">char</span> *<span class="org-variable-name">buf</span>)
{
    <span class="org-keyword">return</span> sprintf(buf, <span class="org-string">"%d\n"</span>, myvariable);
}

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">myvariable_store</span>(<span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">kobj</span>,
                                <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> *<span class="org-variable-name">attr</span>,
                                <span class="org-type">char</span> *<span class="org-variable-name">buf</span>, <span class="org-type">size_t</span> <span class="org-variable-name">count</span>)
{
    sscanf(buf, <span class="org-string">"%du"</span>, &amp;myvariable);
    <span class="org-keyword">return</span> count;
}


<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> <span class="org-variable-name">myvariable_attribute</span> =
    __ATTR(myvariable, 0660, myvariable_show,
           (<span class="org-type">void</span>*)myvariable_store);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> mymodule_init (<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">error</span> = 0;

    pr_info(<span class="org-string">"mymodule: initialised\n"</span>);

    mymodule =
        kobject_create_and_add(<span class="org-string">"mymodule"</span>, kernel_kobj);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>mymodule)
        <span class="org-keyword">return</span> -ENOMEM;

    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr);
    <span class="org-keyword">if</span> (error) {
        pr_info(<span class="org-string">"failed to create the myvariable file "</span> \
               <span class="org-string">"in /sys/kernel/mymodule\n"</span>);
    }

    <span class="org-keyword">return</span> error;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> mymodule_exit (<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"mymodule: Exit success\n"</span>);
    kobject_put(mymodule);
}

<span class="org-function-name">module_init</span>(mymodule_init);
<span class="org-function-name">module_exit</span>(mymodule_exit);
</pre>
</div>

<p>
CrÃ©ez et installez votre module :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
sudo insmod hello-sysfs.ko
</pre>
</div>

<p>
VÃ©rifiez qu'il existe :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello_sysfs
</pre>
</div>

<p>
Quelle est la valeur de <i>myvariable</i> ?
</p>

<div class="org-src-container">

<pre class="src src-sh">cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Modifiez la valeur de <i>myvariable</i> et vÃ©rifiez qu'elle a changÃ©e
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">echo</span> <span class="org-string">"32"</span> &gt; /sys/kernel/mymodule/myvariable
cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Finalement, supprimez ce module exemple :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod hello_sysfs
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Interagir avec un fichier de pÃ©riphÃ©rique</h2>
<div class="outline-text-2" id="text-9">
<p>
Les fichiers de pÃ©riphÃ©riques sont censÃ©s reprÃ©senter des pÃ©riphÃ©riques physiques. La plupart de ces pÃ©riphÃ©riques physiques sont utilisÃ©s aussi bien en lecture qu'en Ã©criture, il existe donc des mÃ©canismes pour que le pilote du pÃ©riphÃ©rique concernÃ© reÃ§oive des informations du processus qui souhaite Ã©crire dans le pÃ©riphÃ©rique. Ce mÃ©canisme est rÃ©alisÃ© en ouvrant le fichier du pÃ©riphÃ©rique pour une Ã©criture, et en Ã©crivant dedans, tout comme vous Ã©cririez dans un simple fichier. Dans l'illustration suivante, un exemple vous est donnÃ© via la fonction device_write.
</p>

<p>
Mais ce n'est pas suffisant. Imaginez que vous disposez d'un port sÃ©rie, lequel est connectÃ© Ã  une carte rÃ©seau (mÃªme si vous avez une carte rÃ©seau intÃ©grÃ©e dans votre carte mÃ¨re, celle-ci est implantÃ©e, du point de vue du processeur, comme un port sÃ©rie connectÃ© Ã  une carte rÃ©seau, vous n'aurez donc pas Ã  pousser loin votre imagination). Le comportement qui pourra vous sembler naturel sera d'utiliser le fichier de pÃ©riphÃ©rique du port sÃ©rie vers la carte rÃ©seau pour y Ã©crire (soit des ordres pour commander la carte rÃ©seau, soit des donnÃ©es Ã  transmettre sur la ligne) ou pour y lire des informations depuis la carte rÃ©seau (soit les rÃ©ponses des commandes, soit des donnÃ©es reÃ§ues depuis la ligne). Vous avez rÃ©glÃ© le problÃ¨me, mais la question reste ouverte de savoir comment vous ferez quand vous souhaiterez interagir avec le port-sÃ©rie lui-mÃªme, par exemple pour dÃ©finir Ã  quelle frÃ©quence il doit recevoir et envoyer des donnÃ©es.
</p>

<p>
La rÃ©ponse au sein d'Unix est d'utiliser une fonction spÃ©ciale appelÃ©e <b>ioctl</b> (raccourci pour Input Output ConTrol). Chaque pÃ©riphÃ©rique a ses propres commandes ioctl, qui peuvent Ãªtre soit en lecture (envoyer des informations du processus vers le noyau), soit en Ã©criture (renvoyer les informations Au processus), soit les deux, soit aucune des deux. Vous noterez qu'ici, les rÃ´les des fonctions de lecture et d'Ã©critures sont inversÃ©es une fois de plus. Ainsi avec les ioctl, la lecture consiste Ã  envoyer des informations vers le noyau, et l'Ã©criture consiste Ã  recevoir des informations du noyau.
</p>

<p>
Les fonctions ioctl sont appelÃ©es avec trois paramÃ¨tres : le file descriptor du fichier de pÃ©riphÃ©rique appropriÃ©, le numÃ©ro d'ioctl, et un paramÃ¨tre de type long afin que vous puissiez le caster pour passer l'adresse de tout ce que vous souhaitez.
</p>

<p>
Le numÃ©ro de l'ioctl est une valeur formatÃ©e qui contient le numÃ©ro majeur de votre pÃ©riphÃ©rique, le type de l'ioctl, la commande, et le type de votre paramÃ¨tre. Le numÃ©ro d'ioctl est habituellement crÃ©Ã© dans une fichier d'en-tÃªte via un appel de macro (\_IO, \_IOR, \_IOW ou \_IOWR , en fonction du type). Ce fichier d'entÃªte devra ensuite Ã©galement Ãªtre inclus Ã  la fois par le programme utilisateur qui va employer l'ioctl (afin qu'il puisse gÃ©nÃ©rer un numÃ©ro correct), et par le module (afin qu'il puisse comprendre ce numÃ©ro). Dans l'exemple suivant, le fichier d'en-tÃªte est chardev.h et le programme utilisateur qui exÃ©cute l'ioctl est ioctl.c
</p>

<p>
Si vous souhaitez utiliser les ioctls pour votre propre module, la meilleure maniÃ¨re est de demander un numÃ©ro officiel, ainsi vous ne risquez pas de partager votre numÃ©ro avec un autre, dans quel cas le rÃ©sultat pourrait Ãªtre dÃ©sastreux. Pour plus d'informations, jetez un oeil au fichier Documentation/ioctl-number.txt au sein des sources de votre noyau.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * chardev2.c - Cr&#195;&#169;&#195;&#169; un p&#195;&#169;riph&#195;&#169;rique d'entr&#195;&#169;e/sortie en mode caract&#195;&#168;re</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/device.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/uaccess.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/io.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/poll.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/cdev.h&gt;</span>

<span class="org-preprocessor">#include</span> <span class="org-string">"chardev.h"</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">SUCCESS</span> 0
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_NAME</span> <span class="org-string">"char_dev"</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">BUF_LEN</span> 80

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Est-ce que le p&#195;&#169;riph&#195;&#169;rique est</span>
<span class="org-comment"> * actuellement ouvert ?</span>
<span class="org-comment"> * Utilis&#195;&#169; pour &#195;&#169;viter les acc&#195;&#168;s</span>
<span class="org-comment"> * concurrents au m&#195;&#170;me p&#195;&#169;riph&#195;&#169;riques</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Device_Open</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le message que fournira le p&#195;&#169;riph&#195;&#169;rique quand on lui demandera</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">Message</span>[BUF_LEN];

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * O&#195;&#185; en est le processus qui lit le message ?</span>
<span class="org-comment"> * Utile si message est plus grand que la taille du tampon &#195;  remplir dans</span>
<span class="org-comment"> * la fonction device_read()</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">Message_Ptr</span>;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Major</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#195;&#169;ro Major associ&#195;&#169; au pilote de notre p&#195;&#169;riph&#195;&#169;rique </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">class</span> *<span class="org-variable-name">cls</span>;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * C'est appel&#195;&#169; quand un processus demande une ouverture du fichier associ&#195;&#169;</span>
<span class="org-comment"> * &#195;  notre p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
<span class="org-preprocessor">#ifdef</span> DEBUG
        pr_info(<span class="org-string">"device_open(%p)\n"</span>, file);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On ne souhaite pas traiter deux processus concurentiellement</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (Device_Open)
        <span class="org-keyword">return</span> -EBUSY;

    Device_Open++;
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Initialise le message</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Message_Ptr = Message;
    try_module_get(THIS_MODULE);
    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_release(%p,%p)\n"</span>, inode, file);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nous sommes maintenant pr&#195;&#170;t pour traiter l'appel suivant</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Device_Open--;

    module_put(THIS_MODULE);
    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#195;&#169;e quand un processus qui a d&#195;&#169;j&#195;  ouvert le fichier</span>
<span class="org-comment"> * associ&#195;&#169; &#195;  notre p&#195;&#169;riph&#195;&#169;rique demande une lecture de ce dernier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">char</span> <span class="org-variable-name">__user</span> * buffer,        <span class="org-comment-delimiter">/* </span><span class="org-comment">Tampon qui sera  *</span>
<span class="org-comment">                                                         * remplis          </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille du tampon         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nombre d'octets r&#195;&#169;ellement &#195;&#169;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">int</span> <span class="org-variable-name">bytes_read</span> = 0;

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_read(%p,%p,%d)\n"</span>, file, buffer, length);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si on atteint la fin du message, renvoie un 0 pour signifier</span>
<span class="org-comment">     * la fin du fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (*Message_Ptr == 0)
        <span class="org-keyword">return</span> 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Insertion des donn&#195;&#169;es dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (length &amp;&amp; *Message_Ptr) {
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Parce que le tampon est dans l'espace utilisateur, et non pas dans</span>
<span class="org-comment">     * l'espace noyau o&#195;&#185; nous nous trouvons au moment o&#195;&#185; l'on ex&#195;&#169;cute ce</span>
<span class="org-comment">     * code, une simple modification de valeur par les variable ne</span>
<span class="org-comment">     * fonctionnerait pas. C'est pourquoi nous devons utiliser la fonction</span>
<span class="org-comment">     * put_user() qui copie des donn&#195;&#169;es de l'espace noyau vers l'espace</span>
<span class="org-comment">     * utilisateur</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
     put_user(*(Message_Ptr++), buffer++);
     length--;
     bytes_read++;
}

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"Read %d bytes, %d left\n"</span>, bytes_read, length);
<span class="org-preprocessor">#endif</span>
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La plupart des fonctions de lecture renvoie le nombre d'octets</span>
<span class="org-comment">     * qui ont &#195;&#169;t&#195;&#169; ins&#195;&#169;r&#195;&#169; dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> bytes_read;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#195;&#169;e quand quelqu'un commandera une &#195;&#169;criture</span>
<span class="org-comment"> * dans le fichier associ&#195;&#169; &#195;  notre p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span>
<span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,
             <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">__user</span> * buffer, <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_write(%p,%s,%d)"</span>, file, buffer, length);
<span class="org-preprocessor">#endif</span>

    <span class="org-keyword">for</span> (i = 0; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++)
        get_user(Message[i], buffer + i);

    Message_Ptr = Message;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Une fois n'est pas coutume, nous renvoyons</span>
<span class="org-comment">     * le nombre de caract&#195;&#168;res trait&#195;&#169;s</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> i;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#195;&#169;e quand un processus essaiera de commander</span>
<span class="org-comment"> * un ioctl sur le fichier associ&#195;&#169; &#195;  notre p&#195;&#169;riph&#195;&#169;rique. Par rapport aux</span>
<span class="org-comment"> * structures inode et file, on a ici deux param&#195;&#168;tres suppl&#195;&#169;mentaires :</span>
<span class="org-comment"> * le num&#195;&#169;ro de l'ioctl appel&#195;&#169; et le param&#195;&#168;tre pass&#195;&#169; &#195;  la fonction ioctl.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Si l'ioctl est en mode &#195;&#169;criture, ou lecture/&#195;&#169;criture, ce qui implique</span>
<span class="org-comment"> * qu'une valeur sera renvoy&#195;&#169;e au processus l'ex&#195;&#169;cutant, alors l'appel</span>
<span class="org-comment"> * ioctl renverra la m&#195;&#170;me chose que cette fonction.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">long</span> <span class="org-function-name">device_ioctl</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,
                  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">ioctl_num</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#195;&#169;ro de l'appel ioctl    </span><span class="org-comment-delimiter">*/</span>
                  <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">ioctl_param</span>) <span class="org-comment-delimiter">/* </span><span class="org-comment">Param&#195;&#168;tre de l'appel ioctl </span><span class="org-comment-delimiter">*/</span>
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> *<span class="org-variable-name">temp</span>;
    <span class="org-type">char</span> <span class="org-variable-name">ch</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Switch en fonction du num&#195;&#169;ro de l'appel ioctl</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">switch</span> (ioctl_num) {
    <span class="org-keyword">case</span> IOCTL_SET_MSG:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Re&#195;&#167;oit via le param&#195;&#168;tre de l'appel ioctl</span>
<span class="org-comment">         * un pointeur vers un message (dans l'espace utilisateur)</span>
<span class="org-comment">         * et le modifie pour qu'il pointe vers le message de notre</span>
<span class="org-comment">         * p&#195;&#169;riph&#195;&#169;rique.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        temp = (<span class="org-type">char</span> *)ioctl_param;

         <span class="org-comment-delimiter">/*</span>
<span class="org-comment">          * Cherche la taille de notre message</span>
<span class="org-comment">          </span><span class="org-comment-delimiter">*/</span>
         get_user(ch, temp);
         <span class="org-keyword">for</span> (i = 0; ch &amp;&amp; i &lt; BUF_LEN; i++, temp++)
             get_user(ch, temp);

         device_write(file, (<span class="org-type">char</span> *)ioctl_param, i, 0);
         <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> IOCTL_GET_MSG:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Renvoie un message au processus qui demande une lecture</span>
<span class="org-comment">         * Notre param&#195;&#168;tre est un pointeur, il faut donc le remplir</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        i = device_read(file, (<span class="org-type">char</span> *)ioctl_param, 99, 0);

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Puis pour faire faire les choses proprement,</span>
<span class="org-comment">         * il faut ins&#195;&#169;rer un 0 &#195;  la fin du tampon</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        put_user(<span class="org-string">'\0'</span>, (<span class="org-type">char</span> *)ioctl_param + i);
        <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> IOCTL_GET_NTH_BYTE:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cette ioctl est &#195;  la fois en mode entr&#195;&#169;e (ioctl_param)</span>
<span class="org-comment">         * et en mode sortie (la valeur renvoy&#195;&#169;e par cette fonction)</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">return</span> Message[ioctl_param];
        <span class="org-keyword">break</span>;
    }

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;clarations des module </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure va contenir les fonctions qui seront appel&#195;&#169;es au moment</span>
<span class="org-comment"> * o&#195;&#185; un processus agira sur le p&#195;&#169;riph&#195;&#169;rique qu'on a cr&#195;&#169;&#195;&#169;. Comme un pointeur</span>
<span class="org-comment"> * vers cette structure est conserv&#195;&#169; dans la table des p&#195;&#169;riph&#195;&#169;riques, ce</span>
<span class="org-comment"> * dernier ne peut pas &#195;&#170;tre local &#195;  init_module.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * La valeur NULL est assign&#195;&#169;e aux fonctions non implant&#195;&#169;es.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">Fops</span> = {
        .read = device_read,
        .write = device_write,
        .unlocked_ioctl = device_ioctl,
        .open = device_open,
        .release = device_release,     <span class="org-comment-delimiter">/* </span><span class="org-comment">Fonction de fermeture </span><span class="org-comment-delimiter">*/</span>
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialiser le module - Enregistrer le p&#195;&#169;riph&#195;&#169;rique de type caract&#195;&#168;re</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Enregistre le p&#195;&#169;riph&#195;&#169;rique de type caract&#195;&#168;re</span>
<span class="org-comment">     * (ou du moins essaie de le faire)</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;Fops);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Les valeurs n&#195;&#169;gatices signifient des erreurs</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        pr_alert(<span class="org-string">"%s failed with %d\n"</span>,
                 <span class="org-string">"Sorry, registering the character device "</span>, ret_val);
        <span class="org-keyword">return</span> ret_val;
    }

    Major = ret_val;

    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);
    device_create(cls, <span class="org-constant">NULL</span>, MKDEV(Major, MAJOR_NUM), <span class="org-constant">NULL</span>, DEVICE_FILE_NAME);

    pr_info(<span class="org-string">"Device created on /dev/%s\n"</span>, DEVICE_FILE_NAME);

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Nettoyage - Supprime le fichier appropri&#195;&#169; de /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Supprime le p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    unregister_chrdev(Major, DEVICE_NAME);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  chardev.h - Le fichier d'en-t&#195;&#170;te qui contient toutes les d&#195;&#169;finitions</span>
<span class="org-comment"> *  d'ioctl</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Les d&#195;&#169;clarations ici doivent obligatoirement &#195;&#170;tre contenues dans ce type</span>
<span class="org-comment"> *  de fichier, parce qu'elles doivent &#195;&#170;tre connues &#195;  la fois :</span>
<span class="org-comment"> *  - de notre module (dans le fichier chardev.c)</span>
<span class="org-comment"> *  - et par le processus qui appelle les ioctl (ioctl.c).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> CHARDEV_H
<span class="org-preprocessor">#define</span> <span class="org-variable-name">CHARDEV_H</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/ioctl.h&gt;</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le num&#195;&#169;ro majeur de p&#195;&#169;riph&#195;&#169;rique.</span>
<span class="org-comment"> * On ne peut plus utiliser un m&#195;&#169;canisme d'attribution dynamique, car les</span>
<span class="org-comment"> * ioctls doivent le conna&#195;&#174;tre.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MAJOR_NUM</span> 100

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Assigne le message du pilote de notre p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> * depuis un processus utilisateur</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_SET_MSG</span> _IOW(MAJOR_NUM, 0, <span class="org-type">char</span> *)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * _IOW signifie qu'on est en train de cr&#195;&#169;er un num&#195;&#169;ro d'ioctl</span>
<span class="org-comment"> * pour passer des informations depuis un processus utilisateur</span>
<span class="org-comment"> * vers un module noyau.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le premier argument, MAJOR_NUM, est le num&#195;&#169;ro majeur du p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> * qu'on utilise.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le deuxi&#195;&#168;me argument est le num&#195;&#169;ro de la commande.</span>
<span class="org-comment"> * Au sein d'un pilote, il peut exister diff&#195;&#169;rentes commandes ioctl. Ce num&#195;&#169;ro</span>
<span class="org-comment"> * sert &#195;  les identifier</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le troisi&#195;&#168;me argument est le type qu'on attend du processus ex&#195;&#169;cutant</span>
<span class="org-comment"> * une commande ioctl.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Obtiens le message du pilote de notre p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_GET_MSG</span> _IOR(MAJOR_NUM, 1, <span class="org-type">char</span> *)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cet IOCTL est utilis&#195;&#169; pour diffuser une information, pour informer le</span>
<span class="org-comment"> * processus du contenu de notre pilote. Cependant, on a encore besoin</span>
<span class="org-comment"> * d'un tampon pour y ins&#195;&#169;rer les donn&#195;&#169;es que l'utilisateur souhaite,</span>
<span class="org-comment"> * tampon qui nous est fourni par ce dernier.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Obtenir le N&#195;&#168;me caract&#195;&#168;re de notre message</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_GET_NTH_BYTE</span> _IOWR(MAJOR_NUM, 2, <span class="org-type">int</span>)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * L'IOCTL est utilis&#195;&#169; &#195;  la fois en sortie et en entr&#195;&#169;e.</span>
<span class="org-comment"> * Il re&#195;&#167;oit un num&#195;&#169;ro N de l'utilisateur, et renvoie Message[N]</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le nom du fichier associ&#195;&#169; &#195;  notre p&#195;&#169;riph&#195;&#169;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_FILE_NAME</span> <span class="org-string">"char_dev"</span>

<span class="org-preprocessor">#endif</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  ioctl.c - Le programme utilisateur qui ex&#195;&#169;cutera des ioctls pour</span>
<span class="org-comment"> *  int&#195;&#169;ragir avec notre module</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Jusqu'&#195;  maintenant, nous pouvions utiliser des commandes comme cat</span>
<span class="org-comment"> *  pour commander une entr&#195;&#169;e ou une sortie sur nos modules, mais</span>
<span class="org-comment"> *  pour ex&#195;&#169;cuter un appel ioctl, il faut n&#195;&#169;cessairement &#195;&#169;crire notre</span>
<span class="org-comment"> *  propre programme utilisateur</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Sp&#195;&#169;cifique &#195;  notre p&#195;&#169;riph&#195;&#169;rique, ce fichier contient les num&#195;&#169;ro des ioctls</span>
<span class="org-comment"> * et le num&#195;&#169;ro majeur du fichier associ&#195;&#169; &#195;  notre p&#195;&#169;riph&#195;&#169;rique.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"../chardev.h"</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;fcntl.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">open </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">exit </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/ioctl.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">ioctl </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction pour les appels ioctls</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">ioctl_set_msg</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>, <span class="org-type">char</span> *<span class="org-variable-name">message</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;

    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);

    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        printf(<span class="org-string">"ioctl_set_msg failed:%d\n"</span>, ret_val);
        exit(-1);
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">ioctl_get_msg</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;
    <span class="org-type">char</span> <span class="org-variable-name">message</span>[100];

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Attention ! Ceci est dangereux parce qu'on ne dit pas au noyau</span>
<span class="org-comment">     * jusqu'o&#195;&#185; il doit &#195;&#169;crire, alors il existe un risque de d&#195;&#169;passement</span>
<span class="org-comment">     * du tampon. En condition r&#195;&#169;elle de programmation noyau, nous</span>
<span class="org-comment">     * aurions utilis&#195;&#169; deux appels ioctls :</span>
<span class="org-comment">     * - un pour informer le noyau de la taille du tampon</span>
<span class="org-comment">     * - un second avec le tampon &#195;  remplir</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);

    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        printf(<span class="org-string">"ioctl_get_msg failed:%d\n"</span>, ret_val);
        exit(-1);
    }

    printf(<span class="org-string">"get_msg message:%s\n"</span>, message);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">ioctl_get_nth_byte</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">c</span>;

    printf(<span class="org-string">"get_nth_byte message:"</span>);

    i = 0;
    <span class="org-keyword">do</span> {
        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);

        <span class="org-keyword">if</span> (c &lt; 0) {
            printf(<span class="org-string">"ioctl_get_nth_byte failed at the %d'th byte:\n"</span>,
                   i);
            exit(-1);
        }

        putchar(c);
    } <span class="org-keyword">while</span> (c != 0);
    putchar(<span class="org-string">'\n'</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Main - Appel des fonctions d'ioctls</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">file_desc</span>, <span class="org-variable-name">ret_val</span>;
    <span class="org-type">char</span> *<span class="org-variable-name">msg</span> = <span class="org-string">"Message passed by ioctl\n"</span>;

    file_desc = open(DEVICE_FILE_NAME, 0);
    <span class="org-keyword">if</span> (file_desc &lt; 0) {
        printf(<span class="org-string">"Can't open device file: %s\n"</span>, DEVICE_FILE_NAME);
        exit(-1);
    }

    ioctl_get_nth_byte(file_desc);
    ioctl_get_msg(file_desc);
    ioctl_set_msg(file_desc, msg);

    close(file_desc);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Les appels systÃ¨me</h2>
<div class="outline-text-2" id="text-10">
<p>
Jusqu'ici, tout ce qu'on a fait Ã©tait d'utiliser des mÃ©canismes prÃ©dÃ©finis pour enregistrer un fichier <b>/proc</b> et des gestionnaires de pÃ©riphÃ©riques. Ã‡a vous suffira tant que vous vous cantonnez Ã  ce que les dÃ©veloppeurs noyaux ont prÃ©vu pour vous, comme Ã©crire un pilote de pÃ©riphÃ©rique. Mais qu'en est-il si vous souhaitez aller plus loin ? Si vous souhaitez modifier le fonctionnement du systÃ¨me ?
</p>

<p>
Si vous n'avez pas encore succombÃ© aux sirÃ¨nes de la machine virtuelle, alors c'est ici que le dÃ©veloppement du noyau peut vraiment devenir dangereux. Pendant que j'ai Ã©crit l'exemple plus bas, J'ai tuÃ© l'appel systÃ¨me <b>open()</b>. Ce qui signifie que : je ne pouvais plus ouvrir aucun fichier, je ne pouvais plus lancer aucun programme, et je ne pouvais plus Ã©teindre le systÃ¨me. J'ai dÃ» redÃ©marrer brutalement ma machine virtuelle. Je n'ai perdu aucun fichier important, mais si j'avais fait de mÃªme sur une vraie machine, ce cauchemar aurait pu devenir rÃ©alitÃ©. Pour vous assurer de ne pas perdre de fichier, mÃªme au sein d'un environnement d'essai, pensez Ã  exÃ©cuter <b>sync</b> juste avant d'appeler <b>insmod</b> et <b>rmmod</b>.
</p>

<p>
Oubliez tout Ã  propos des fichiers <b>/proc</b> et des fichiers de pÃ©riphÃ©riques. Ce ne sont que des dÃ©tails sans importance Ã  l'Ã©chelle de votre systÃ¨me. Les vrais mÃ©canismes de communication du noyau sont les appels systÃ¨me. Ce sont eux qui sont appelÃ©s par tous les processus. Quand un processus demande un service au noyau (tel qu'ouvrir un fichier, crÃ©er un nouveau processus, ou demander plus de mÃ©moire), c'est ce mÃ©canisme qui est appelÃ©. Si vous souhaitez changer le fonctionnement de votre noyau, c'est par lÃ  que vous devrez passer. Comme j'en ai parlÃ© plus tÃ´t, si vous souhaitez voir tous les appels systÃ¨me effectuÃ©s par un programme, utilisez la commande <b>strace</b>.
</p>

<p>
En gÃ©nÃ©ral, un processus n'est pas censÃ© pouvoir accÃ©der au noyau. Il ne peut ni accÃ©der Ã  la mÃ©moire du noyau, ni appeler les fonctions du noyau. Le matÃ©riel, via le CPU, s'en assure (c'est la raison pour laquelle ce mÃ©canisme est appelÃ© 'mode superviseur', ou 'protection de pages').
</p>

<p>
Les appels systÃ¨me sont une exception Ã  cette rÃ¨gle gÃ©nÃ©rale. Ce qui se passe, c'est que les processus remplissent des registres avec des valeurs en guise de paramÃ¨tres, et appellent ensuite une instruction particuliÃ¨re qui saute Ã  une adresse dÃ©finie prÃ©cÃ©demment, au sein du noyau (bien sÃ»r, cette adresse peut Ãªtre lue par les processus utilisateurs, mais ces derniers ne peuvent pas y Ã©crire). Au sein des CPU Intels, on y accÃ¨de via l'interruption 0x80. Le matÃ©riel sait qu'une fois que vous avez sautÃ© Ã  cette adresse, votre processeur n'est plus en mode utilisateur, mais en mode noyau &#x2014; vous Ãªtes donc libre de faire tout ce que vous souhaitez.
</p>

<p>
L'adresse au sein du noyau oÃ¹ un processus peut sauter est appelÃ© system_call. L'algorithme Ã  l'arrivÃ©e de ce code regarde le numÃ©ro d'appel systÃ¨me, qui dÃ©finit quelle fonction systÃ¨me est demandÃ©e. Ensuite, le programme regarde dans la table d'appels systÃ¨me (appelÃ©e sys_call_table) quelle est l'adresse de la fonction demandÃ©e. Pour finir, le processeur saute Ã  cette fonction, et avant d'en revenir, effectue quelques vÃ©rifications systÃ¨mes avant de redonner la main au processus utilisateur appelant (ou Ã  un autre processus si le premier Ã  Ã©tÃ© trop long). Si vous souhaitez lire ce code, il est disponible dans le code source (arch/$&lt;$architecture$&gt;$/kernel/enty.S, aprÃ¨s la ligne ENTRY(system_call)).
</p>

<p>
Ainsi, si vous souhaitez, d'une certaine maniÃ¨re, changer le fonctionnement d'un certain appel systÃ¨me, ce que vous devez faire est de crÃ©er votre propre fonction pour l'insÃ©rer (gÃ©nÃ©ralement cette fonction exÃ©cutera votre code avant d'appeler la fonction systÃ¨me originale) et ensuite changer le pointeur de la table sys_call_table pour que cette derniÃ¨re pointe vers votre fonction. Attention ! Parce que vous ne souhaitez pas que votre module soit enlevÃ© en laissant le systÃ¨me dans un Ã©tat instable, il est important que la fonction cleanup_module modifie la table dans son Ã©tat prÃ©cÃ©dent.
</p>

<p>
Le code source suivant est un exemple d'un tel module noyau. On souhaite ici "espionner" un certain utilisateur, afin de notifier, via <b>pr_info()</b>, quand cet utilisateur ouvre un fichier. Pour procÃ©der, on remplace l'appel systÃ¨me lancÃ© Ã  l'ouverture d'un fichier par notre propre fonction, appelÃ©e ici <b>our_sys_open</b>. Cette fonction vÃ©rifie l'uid (l'identifiant de l'utilisateur) du processus courant, et si cet uid est Ã©gal Ã  celui qu'on surveille, alors la fonction appelle <b>pr_info()</b> afin d'afficher le nom du fichier en cours d'ouverture. Ensuite, et peu importe l'uid, notre fonction appelle la fonction originale open() avec les mÃªmes paramÃ¨tres, pour effectivement ouvrir le fichier.
</p>

<p>
La fonction <b>init_module</b> remplace la fonction concernÃ©e dans la table <b>sys_call_table</b> avec notre fonction, et conserve l'originale dans une variable. La fonction cleanup_module utilise cette variable pour restaurer le systÃ¨me dans l'Ã©tat oÃ¹ il se trouvait avant cette modification. Cette mÃ©thode est trÃ¨s dangereuse, dans le cas ou deux modules noyaux modifient le mÃªme appel systÃ¨me.
</p>

<p>
Imaginez deux modules, A et B. L'ouverture de A sera A_open, et celle de B B_open. Maintenant, quand A est insÃ©rÃ© dans le noyau, l'appel systÃ¨me open est remplacÃ© par A_open, qui appellera l'appel original open Ã  sa fin. Ensuite, si on insÃ¨re B au sein de noyau, ce dernier remplacera l'appel systÃ¨me A_open avec le B_open. L'appel de A_open sera sonc effectuÃ© Ã  la fin de la fonction B_open.
</p>

<p>
Ensuite, enlevons ces modules. Si B est enlevÃ© en premier, alors il n'y aura aucun problÃ¨me &#x2014; l'appel systÃ¨me sera restaurÃ© Ã  A_open, qui lui-mÃªme appelle l'open() original. Cependant, si A est enlevÃ©, alors l'appel systÃ¨me original sera restaurÃ© (ce qui signifie que B_open ne sera jamais appelÃ©). C'est problÃ©matique, mais pas catastrophique. Cependant, si vous enlevez ensuite B, la suppression de ce dernier va restaurer l'appel systÃ¨me Ã  ce qu'il pense Ãªtre l'original, <b>A_open</b>, lequel n'est plus prÃ©sent en mÃ©moire. Les consÃ©quences seront dÃ©sastreuses.
</p>

<p>
Ã€ premiÃ¨re vue, un module peut rÃ©gler ce problÃ¨me en vÃ©rifiant, lors de sa suppression, si l'appel systÃ¨me prÃ©sent dans la table sys_call_table est bien sa propre fonction, et si ce n'est pas le cas, il ne doit rien changer (ainsi B ne changerait aucun appel systÃ¨me Ã  sa suppression), mais cette solution conduirait en rÃ©alitÃ© Ã  un problÃ¨me plus grave encore. Quand A est enlevÃ©, ce dernier voit que l'appel systÃ¨me a Ã©tÃ© changÃ© Ã  <b>B_open</b>. Ce dernier ne restaurera donc pas l'appel systÃ¨me original. Mais malheureusement, B n'a pas conscience de Ã§a. <b>B_open</b> commencera, puis appellera <b>A_open</b>, qui n'existe pas en mÃ©moire. Donc mÃªme sans enlever B du systÃ¨me, votre systÃ¨me va planter.
</p>

<p>
Notez que tous les problÃ¨mes relatifs Ã  cette situation rendent tout simplement la redÃ©finition des appels systÃ¨me impossible pour des usages en situation de production. Afin de ne pas tenter les dÃ©veloppeurs du dimanche de faire des choses potentiellement dÃ©sastreuses, la table <b>sys_call_table</b> n'est plus exportÃ©e, ce qui signifie que si vous souhaitez exÃ©cuter l'exemple suivant, vous devrez modifier votre noyau pour exporter la table en question. Dans le rÃ©pertoire examples, vous trouverez un README et la modification Ã  apporter. Comme vous l'imaginez, une telle modification ne doit pas Ãªtre prise Ã  la lÃ©gÃ¨re. N'essayez pas de rÃ©aliser une telle action sur un systÃ¨me important (par exemple un systÃ¨me que vous ne possÃ©dez pas ou que vous ne pouvez pas restaurer aisÃ©ment). Vous aurez besoin d'accÃ©der au code source complet de ce guide pour avoir accÃ¨s aux modifications et au README. En fonction de votre version du noyau, vous risquez mÃªme devoir effectuer cette modification Ã  la main.
</p>

<p>
C'est ici que se clÃ´t ce chapitre. Sachez cependant que si Le Coyote chassant Bip Bip Ã©tait un hacker noyau, ce serait la premiÃ¨re chose qu'il essaierait pour attraper son repas !
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  syscall.c</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Exemple de "vol" d'un d'appel syst&#195;&#168;me.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  D&#195;&#169;sactive la protection des pages au niveau du processeur</span>
<span class="org-comment"> *  en changeant le 16&#195;&#168;me bit dans le registre cr0</span>
<span class="org-comment"> *  (sp&#195;&#169;cifique aux processeurs Intel)</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  D&#195;&#169;monstration bas&#195;&#169;e sur l'exemple de Peter Jay Salzman et sur</span>
<span class="org-comment"> *  https://bbs.archlinux.org/viewtopic.php?id=139406</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/syscalls.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/paravirt.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/moduleparam.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">Qui contiendra les param&#195;&#168;tres </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/unistd.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">La liste des appels syst&#195;&#168;me </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * On a besoin de ces fichiers afin de conna&#195;&#174;tre qui est</span>
<span class="org-comment"> * l'utilisateur dans la structure du processus actuel</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-variable-name">sys_call_table</span>;
<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">original_cr0</span>;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * UID qu'on souhaite espionner - sera affect&#195;&#169;e</span>
<span class="org-comment"> * par la ligne de commande</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">uid</span>;
<span class="org-function-name">module_param</span>(uid, <span class="org-type">int</span>, 0644);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La prochaine variable est un pointeur qui contiendra l'adresse</span>
<span class="org-comment"> * de l'appel syst&#195;&#168;me avant notre modification.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * On garde cette adresse dans ce pointeur pour pouvoir, quand on d&#195;&#169;chargera</span>
<span class="org-comment"> * notre module, remettre le syst&#195;&#168;me dans son &#195;&#169;tat initial. On doit garder en</span>
<span class="org-comment"> * m&#195;&#169;moire dans ce pointeur l'appel syst&#195;&#168;me avant qu'on le modifie, et on ne</span>
<span class="org-comment"> * peut pas juste utiliser l'appel syst&#195;&#168;me original (sys_open) dans le cas ou</span>
<span class="org-comment"> * un autre module a modifi&#195;&#169; cet appel syst&#195;&#168;me avant non. Notez bien que cette</span>
<span class="org-comment"> * s&#195;&#169;curit&#195;&#169; n'est pas absolument s&#195;&#187;re, car dans le cas redout&#195;&#169; d&#195;&#169;crit dans</span>
<span class="org-comment"> * ce guide de deux modules modifiant le m&#195;&#170;me appel syst&#195;&#168;me, alors si le</span>
<span class="org-comment"> * module qui a modifi&#195;&#169; l'appel syst&#195;&#168;me original est supprim&#195;&#169; avant le notre,</span>
<span class="org-comment"> * alors si j'appelle une fonction de ce module supprim&#195;&#169; d&#195;&#169;puis, je ne sais</span>
<span class="org-comment"> * pas ce qui attends notre noyau !</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Une autre raison pour laquelle on utilise ce pointeur c'est que sys_open</span>
<span class="org-comment"> * est une variable statique, et elle n'est donc pas export&#195;&#169;e.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
asmlinkage <span class="org-type">int</span> (*<span class="org-function-name">original_call</span>) (<span class="org-keyword">const</span> <span class="org-type">char</span> *, <span class="org-type">int</span>, <span class="org-type">int</span>);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La fonction suivante va remplacer sys_open</span>
<span class="org-comment"> * Elle sera donc appel&#195;&#169;e quand n'importe quel processus ex&#195;&#169;cutera l'appel</span>
<span class="org-comment"> * syst&#195;&#168;me open.</span>
<span class="org-comment"> * Pour trouver le prototype exact, afin que correspondent parfaitement</span>
<span class="org-comment"> * les arguments, vous devrez faire un tour dans le fichier qui contient la</span>
<span class="org-comment"> * fonction originale (fs/open.c).</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * En th&#195;&#169;orie, &#195;&#167;a veut dire que notre code est donc d&#195;&#169;pendant de la version</span>
<span class="org-comment"> * actuelle du noyau, puisque notre fonction d&#195;&#169;pend des types et nombres</span>
<span class="org-comment"> * d'arguments que prennent l'appel syst&#195;&#168;me original.</span>
<span class="org-comment"> * En pratique, ne vous inqui&#195;&#169;tez pas, les appels syst&#195;&#168;me ne sont quasiment</span>
<span class="org-comment"> * jamais modifi&#195;&#169;s (cela signifirai que tous les programmes con&#195;&#167;us avant cette</span>
<span class="org-comment"> * mise &#195;  jour soit recompil&#195;&#169;s, puisque les appels syst&#195;&#168;me sont l'interface</span>
<span class="org-comment"> * entre le noyau et les processus, et &#195;&#167;a causerait donc des ravages</span>
<span class="org-comment"> * d&#195;&#169;vastateurs pour le noyau et sa r&#195;&#169;putation)</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
asmlinkage <span class="org-type">int</span> <span class="org-function-name">our_sys_open</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">filename</span>, <span class="org-type">int</span> <span class="org-variable-name">flags</span>, <span class="org-type">int</span> <span class="org-variable-name">mode</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
    <span class="org-type">char</span> <span class="org-variable-name">ch</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Note l'ouverture du fichier, si n&#195;&#169;cessaire</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    pr_info(<span class="org-string">"Opened file by %d: "</span>, uid);
    <span class="org-keyword">do</span> {
        get_user(ch, filename + i);
        i++;
        pr_info(<span class="org-string">"%c"</span>, ch);
    } <span class="org-keyword">while</span> (ch != 0);
    pr_info(<span class="org-string">"\n"</span>);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * A l&#195;  fin de notre appel syst&#195;&#168;me, notre code doit, bien sur, appeler</span>
<span class="org-comment">     * le code original, sinon quoi on perdrait la capacit&#195;&#169; d'ouvrir</span>
<span class="org-comment">     * tous les fichiers</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> original_call(filename, flags, mode);
}

<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-function-name">aquire_sys_call_table</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">int</span> <span class="org-variable-name">offset</span> = PAGE_OFFSET;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-variable-name">sct</span>;

    <span class="org-keyword">while</span> (offset &lt; ULLONG_MAX) {
        sct = (<span class="org-type">unsigned</span> <span class="org-type">long</span> **)offset;

        <span class="org-keyword">if</span> (sct[__NR_close] == (<span class="org-type">unsigned</span> <span class="org-type">long</span> *) sys_close)
            <span class="org-keyword">return</span> sct;

        offset += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
    }

    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> syscall_start(<span class="org-type">void</span>)
{
    <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>(sys_call_table = aquire_sys_call_table()))
        <span class="org-keyword">return</span> -1;

    original_cr0 = read_cr0();

    write_cr0(original_cr0 &amp; ~0x00010000);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Garde l'adresse de l'appel syst&#195;&#168;me open original </span><span class="org-comment-delimiter">*/</span>
    original_call = (<span class="org-type">void</span>*)sys_call_table[__NR_open];

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Modifie la table des appels syst&#195;&#168;me pour utiliser notre fonction </span><span class="org-comment-delimiter">*/</span>
    sys_call_table[__NR_open] = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)our_sys_open;

    write_cr0(original_cr0);

    pr_info(<span class="org-string">"Spying on UID:%d\n"</span>, uid);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> syscall_end(<span class="org-type">void</span>)
{
    <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>sys_call_table) {
        <span class="org-keyword">return</span>;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Restaure la table des appels syst&#195;&#168;me &#195;</span>
<span class="org-comment">     * son &#195;&#169;tat avant notre modification</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (sys_call_table[__NR_open] != (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)our_sys_open) {
        pr_alert(<span class="org-string">"Somebody else also played with the "</span>);
        pr_alert(<span class="org-string">"open system call\n"</span>);
        pr_alert(<span class="org-string">"The system may be left in "</span>);
        pr_alert(<span class="org-string">"an unstable state.\n"</span>);
    }

    write_cr0(original_cr0 &amp; ~0x00010000);
    sys_call_table[__NR_open] = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)original_call;
    write_cr0(original_cr0);

    msleep(2000);
}

<span class="org-function-name">module_init</span>(syscall_start);
<span class="org-function-name">module_exit</span>(syscall_end);

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Processus bloquants et threads</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Sleep</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Que faites-vous quand quelqu'un vous demande de faire quelque chose que vous ne pouvez pas faire immÃ©diatement ? Si vous Ãªtes un Corse dÃ©rangÃ© par quelqu'un vous lui rÃ©pondrez sans doute "<i>Pas maintenant, laisse-moi dormir !</i>". Mais si vous Ãªtes un module et que vous Ãªtes dÃ©rangÃ© par un processus, vous avez une autre possibilitÃ© : Vous pouvez endormir le processus qui vous demande jusqu'Ã  ce que vous puissiez vous en occuper. AprÃ¨s tout, les processus sont endormis et rÃ©veillÃ©s sans arrÃªt par le noyau (c'est la raison pour laquelle de nombreux processus donnent l'impression de tourner en mÃªme temps sur un seul processeur).
</p>

<p>
Le module noyau suivant est un exemple de Ã§a. Le fichier (appelÃ© <b>/proc/sleep</b>) ne peut Ãªtre ouvert que par un seul processus Ã  la fois. Si le fichier est dÃ©jÃ  ouvert, le module appelle wait_event_interruptible. La maniÃ¨re la plus simple de garder un fichier ouvert est la suivante :
</p>

<div class="org-src-container">

<pre class="src src-bash">tail -f
</pre>
</div>

<p>
La fonction wait_event_interruptible change l'Ã©tat de la tÃ¢che (une tÃ¢che est ni plus ni moins qu'une structure de donnÃ©es dans le noyau qui contient les informations d'un processus et les appels systÃ¨me utilisÃ©s) pour <b>TASK_INTERRUPTIBLE</b>, qui signifie que la tÃ¢che ne sera pas lancÃ©e avant qu'elle ne soit rÃ©veillÃ©e d'une quelconque maniÃ¨re. La fonction wait_event_interruptible va ensuite ajouter la tÃ¢che en question Ã  WaitQ, la file des tÃ¢ches qui attendent pour accÃ©der au fichier. Ensuite, la fonction appelle l'ordonnanceur pour changer le contexte d'exÃ©cution de la thread Ã  endormir pour une autre, qui sera vraiment utilisÃ©e par le CPU.
</p>

<p>
Quand le processus qui utilisait le fichier n'en a plus besoin, ce processus ferme le fichier, la fonction module_close est alors appelÃ©e. Cette fonction rÃ©veille tous les processus dans la file d'attente (il n'y a pas de moyen de n'en rÃ©veiller qu'un). Quand cette fonction se termine, alors le processus qui vient de fermer le fichier peut continuer sa vie. En temps voulu, l'ordonnanceur dÃ©cidera que ce processus a assez profitÃ© du processeur, et "donnera" le processeur Ã  un autre processus. Et tÃ´t ou tard, l'un des processus qui Ã©tait dans la file d'attente pour le fichier se verra donner l'accÃ¨s au processeur par l'ordonnanceur. Et il reprendra sa vie juste aprÃ¨s l'appel Ã  <b>module_interruptible_sleep_on</b>.
</p>

<p>
Ã‡a signifie que le processus est encore en train d'exÃ©cuter du code noyau. D'un point de vue du code utilisateur du programme, on est encore situÃ© dans l'appel systÃ¨me open, lequel ne s'est pas encore terminÃ©. Le processus n'a absolument aucune idÃ©e qu'un autre processus a utilisÃ© le processeur entre le moment oÃ¹ il a exÃ©cutÃ© l'appel Ã  la fonction open() et le moment oÃ¹ cette fonction s'est terminÃ©e.
</p>

<p>
Une fois que le processus qui attendait l'accÃ¨s au fichier a la main sur le processeur et sur le fichier, il peut ensuite affecter une variable globale pour signaler aux autres processus que le fichier est encore ouvert (en l'occurrence par lui), et continuer son affaire. Quand les autres processus qui attendent l'accÃ¨s Ã  ce fichier auront accÃ¨s au processeur, ils liront que cette variable globale signale que le fichier sur lequel ils attendent un accÃ¨s est encore occupÃ©, et se rendormiront aussitÃ´t.
</p>

<p>
Dans notre cas, nous utiliserons tail -f pour garder le fichier ouvert continuellement en tÃ¢che de fond, pendant que nous essaierons d'y accÃ©der avec d'autres processus (toujours en tÃ¢che de fond, afin que nous n'ayons pas besoin de basculer vers un autre terminal). DÃ¨s que le premier fichier sera tuÃ© avec la commande kill%1, alors le second se rÃ©veillera, aura finalement accÃ¨s au fichier avant de se terminer.
</p>

<p>
Pour rendre cette expÃ©rience plus intÃ©ressante, sachez que bien que notre processus endormi attend son prince charmant, la fonction <b>module_close</b> n'a pas le monopole du rÃ©veil de notre processus. Ce dernier peut Ãªtre Ã©galement rÃ©veillÃ© par d'autre interruptions, telles qu'un signal Ctrl+c/ (<b>SIGINT</b>). Ceci vient du fait qu'on a prÃ©fÃ©rÃ© utiliser <b>module_interruptible_sleep_on</b>. On aurait pu utiliser <b>module_sleep_on</b> Ã  la place, lequel ignore les signaux, mais pour une raison qui m'Ã©chappe, les utilisateurs n'aiment pas avoir l'impression que le contrÃ´le de leur machine leur Ã©chappe.
</p>

<p>
Dans le cas d'un rÃ©veil par Ctrl+c/, on veut terminer la fonction immÃ©diatement et renvoyer un <b>-EINTR</b>. C'est essentiel afin que les utilisateurs puissent tuer un processus avant que ce dernier ne reÃ§oivent le fichier qu'il attend.
</p>

<p>
Il y a encore un point important Ã  retenir. Parfois, les processus sont exigeants et ne souhaitent pas s'endormir. Ils veulent soit obtenir ce qu'ils demandent immÃ©diatement, soit qu'on leur informe que la ressource qu'ils demandent n'est pas disponible. De tels processus utilisent le drapeau <b>O_NONBLOCK</b> quand ils ouvrent un fichier. Le noyau est censÃ© intervenir en renvoyant une erreur <b>-EAGAIN</b> Ã  l'appel d'une opÃ©ration qui ignorerait ce drapeau pour bloquer le processus appelant. Le programme cat_noblock, disponible dans le code source de ce chapitre de votre guide, peut Ãªtre utiliser pour illustrer l'ouverture d'un fichier avec l'option <b>O_NONBLOCK</b>.
</p>

<div class="org-src-container">

<pre class="src src-sh">hostname:~/lkmpg-examples/09-BlockingProcesses# insmod sleep.ko
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses# tail -f /proc/sleep &amp;
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
tail: /proc/sleep: file truncated
[1] 6540
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Open would block
hostname:~/lkmpg-examples/09-BlockingProcesses# kill %1
[1]+  Terminated              tail -f /proc/sleep
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses#
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  sleep.c - Cr&#195;&#169;er un fichier /proc, et si</span>
<span class="org-comment"> *  plusieurs processus essaient d'y acc&#195;&#168;der</span>
<span class="org-comment"> *  en m&#195;&#170;me temps, les endorts tous sauf un</span>
<span class="org-comment"> *  &#195;  qui la lecture est accord&#195;&#169;e</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire comme nous utilisons proc fs </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour endormir les processus  *</span>
<span class="org-comment">                              et les r&#195;&#169;veiller                        </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#195;&#169;cessaire pour les fonctions get_user  *</span>
<span class="org-comment">                              et put_user                             </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Les fonctions de notre module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Dans ce tableau on garde le dernier message re&#195;&#167;u,</span>
<span class="org-comment"> * afin de prouver que notre fichier g&#195;&#168;re les entr&#195;&#169;es</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MESSAGE_LENGTH</span> 80
<span class="org-keyword">static</span> <span class="org-type">char</span> Message[MESSAGE_LENGTH];

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>;
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROC_ENTRY_FILENAME</span> <span class="org-string">"sleep"</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction de lecture associ&#195;&#169;e dans notre struct file operations</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">module_output</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-comment-delimiter">/* </span><span class="org-comment">Voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">char</span> *<span class="org-variable-name">buf</span>,         <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon dans lequel on *</span>
<span class="org-comment">                                                   va ins&#195;&#169;rer les donn&#195;&#169;es   *</span>
<span class="org-comment">                                                   (situ&#195;&#169; dans l'espace     *</span>
<span class="org-comment">                                                   utilisateur)             </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">size_t</span> <span class="org-variable-name">len</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">La taille du tampon      </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">finished</span> = 0;
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">message</span>[MESSAGE_LENGTH + 30];

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Renvoie 0 pour signifier la fin du fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (finished) {
        finished = 0;
        <span class="org-keyword">return</span> 0;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si vous ne comprenez pas &#195;&#167;a au point o&#195;&#185; vous en &#195;&#170;tes,</span>
<span class="org-comment">     * alors vous &#195;&#170;tes aussi d&#195;&#169;sesp&#195;&#169;rant qu'un programmeur noyau</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    sprintf(message, <span class="org-string">"Last input:%s\n"</span>, Message);
    <span class="org-keyword">for</span> (i = 0; i &lt; len &amp;&amp; message[i]; i++)
        put_user(message[i], buf + i);

    finished = 1;
    <span class="org-keyword">return</span> i;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Renvoie le nombre d'octets "lus" </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction re&#195;&#167;oit des donn&#195;&#169;es de l'utilisateur quand ce dernier &#195;&#169;crit</span>
<span class="org-comment"> * quelque chose dans notre fichier /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">module_input</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,  <span class="org-comment-delimiter">/* </span><span class="org-comment">Le fichier en question   </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buf</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon contenant les  *</span>
<span class="org-comment">                                                   donn&#195;&#169;es &#195;  "&#195;&#169;crire"       </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,      <span class="org-comment-delimiter">/* </span><span class="org-comment">La taille du tampon      </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)    <span class="org-comment-delimiter">/* </span><span class="org-comment">Curseur de notre fichier *</span>
<span class="org-comment">                                                   (&#195;  ignorer)              </span><span class="org-comment-delimiter">*/</span>
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Modifie notre tableau Message avec les donn&#195;&#169;es pass&#195;&#169;es par</span>
<span class="org-comment">     * l'utilisateur, afin que que notre fonction module_output</span>
<span class="org-comment">     * puisse par la suite s'en servir</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; MESSAGE_LENGTH - 1 &amp;&amp; i &lt; length; i++)
        get_user(Message[i], buf + i);
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On souhaite une cha&#195;&#174;ne de caract&#195;&#168;res bien faite, termin&#195;&#169;e par un 0</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Message[i] = <span class="org-string">'\0'</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On doit renvoyer le nombre de caract&#195;&#168;res pass&#195;&#169;s par l'utilisateur</span>
<span class="org-comment">     * qu'on a effectivement utilis&#195;&#169;s</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> i;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Vaut 1 si le fichier est actuellement ouvert par un processus</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-variable-name">Already_Open</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * File des processus qui veulent ouvrir notre fichier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-function-name">DECLARE_WAIT_QUEUE_HEAD</span>(WaitQ);
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169;e quand notre fichier /proc est ouvert</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">module_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si les drapeaux de notre fichier incluent O_NONBLOCK, &#195;&#167;a signifie que</span>
<span class="org-comment">     * le processus qui a essaie d'ouvrir notre fichier ne souhaite pas</span>
<span class="org-comment">     * &#195;&#170;tre bloqu&#195;&#169; si ce dernier n'est pas disponible. Dans ce cas, si</span>
<span class="org-comment">     * le fichier est d&#195;&#169;j&#195;  ouvert, on doit terminer la fonction avec la valeur</span>
<span class="org-comment">     * d'&#195;&#169;chec -EAGAIN, qui signifie "Essaie encore !" plut&#195;&#180;t que de bloquer</span>
<span class="org-comment">     * un processus qui pr&#195;&#169;f&#195;&#168;re rester libre et r&#195;&#169;veill&#195;&#169;</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; Already_Open)
        <span class="org-keyword">return</span> -EAGAIN;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * C'est le bon endroit pour ins&#195;&#169;rer la fonction</span>
<span class="org-comment">     * try_module_get(THIS_MODULE), car si jamais un</span>
<span class="org-comment">     * processus est dans la boucle qui vient juste</span>
<span class="org-comment">     * apr&#195;&#168;s, laquelle se situe dans le code noyau,</span>
<span class="org-comment">     * alors notre module ne doit pas &#195;&#170;tre supprim&#195;&#169;</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    try_module_get(THIS_MODULE);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si le fichier est d&#195;&#169;j&#195;  ouvert, attendre qu'il ne le soit plus</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (Already_Open) {
        <span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">is_sig</span> = 0;

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cette fonction endort le processus en-cours (y compris tous les</span>
<span class="org-comment">         * appels syst&#195;&#168;me). Son ex&#195;&#169;cution reprendra juste apr&#195;&#168;s l'appel &#195;</span>
<span class="org-comment">         * cette fonction, soit parce qu'un autre processus a ex&#195;&#169;cut&#195;&#169;</span>
<span class="org-comment">         * wake_up(&amp;WaitQ) (seulement module_close fait cela, quand le</span>
<span class="org-comment">         * fichier est ferm&#195;&#169;), soit quand un signal (par exemple un Ctrl+C)</span>
<span class="org-comment">         * est envoy&#195;&#169; au dit-processus</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        wait_event_interruptible(WaitQ, <span class="org-negation-char">!</span>Already_Open);

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Si le processus est r&#195;&#169;veill&#195;&#169; parce qu'il a re&#195;&#167;ut un signal,</span>
<span class="org-comment">         * alors il faut renvoyer -EINTR(ce qui signifie un &#195;&#169;chec de l'appel</span>
<span class="org-comment">         * syst&#195;&#168;me). Cela permet aux processus qui attendent un fichier</span>
<span class="org-comment">         * d'&#195;&#170;tre tu&#195;&#169;s ou arr&#195;&#170;t&#195;&#169;s par un signal.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cmmentaire de Emmanuel Papirakis traduit :</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Ceci est une petite mise &#195;  jour par rapport &#195;  la version 2.2.*.</span>
<span class="org-comment">         * Les signaux sont maintenant contenus dans deux mots (de 64 bits)</span>
<span class="org-comment">         * et sont stock&#195;&#169;s dans une structure qui contient un tableau de</span>
<span class="org-comment">         * deux entiers longs non sign&#195;&#169;s.</span>
<span class="org-comment">         * On doit donc faire deux v&#195;&#169;rifications dans notre "si"</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Commentaire de Ori Pomerantz traduit :</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Personne n'a jamais promis de ne pas utiliser des mots plus longs</span>
<span class="org-comment">         * que 64 bits, ou que ce guide ne serait pas utilis&#195;&#169; pour des</span>
<span class="org-comment">         * versions de Linux qui utilisent des mots de 16 bits.</span>
<span class="org-comment">         * C'est pourquoi ce code marchera quelque soit votre architecture.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">for</span> (i = 0; i &lt; _NSIG_WORDS &amp;&amp; <span class="org-negation-char">!</span>is_sig; i++)
            is_sig =
                current-&gt;pending.signal.sig[i] &amp; ~current-&gt;
                blocked.sig[i];

        <span class="org-keyword">if</span> (is_sig) {
            <span class="org-comment-delimiter">/*</span>
<span class="org-comment">             * Il est important de d&#195;&#169;cr&#195;&#169;menter le compteur d'utilisation dans</span>
<span class="org-comment">             * le cas ou le processus voulant ouvrir notre fichier a re&#195;&#167;u</span>
<span class="org-comment">             * un signal. Si on oublie de d&#195;&#169;cr&#195;&#169;menter ce compteur, notre</span>
<span class="org-comment">             * module sera immortel et ne pourra pas &#195;&#170;tre enlev&#195;&#169; du noyau</span>
<span class="org-comment">             * autrement que par un red&#195;&#169;marrage.</span>
<span class="org-comment">             </span><span class="org-comment-delimiter">*/</span>
            module_put(THIS_MODULE);
            <span class="org-keyword">return</span> -EINTR;
        }
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si on est ici, alors la variable Already_Open doit &#195;&#170;tre &#195;&#169;gale &#195;  0</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Ouvre le fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Already_Open = 1;
    <span class="org-keyword">return</span> 0;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Autorise l'acc&#195;&#168;s </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#195;&#169; quand notre fichier /proc est ferm&#195;&#169;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">module_close</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Met la variable Already_Open &#195;  0, afin que l'un des processus qui</span>
<span class="org-comment">     * attend sagement d'ouvrir le fichier puisse enfin mettre la main</span>
<span class="org-comment">     * dessus, en signalant son utilisation en remettant la variable</span>
<span class="org-comment">     * Already_Open &#195;  1 avant d'effectivement ouvrir le fichier.</span>
<span class="org-comment">     * Tous les processus qui attendent notre fichier verront alors</span>
<span class="org-comment">     * qu'Already_Open vaut 1, signifiant qu'un processus a d&#195;&#169;j&#195;  la main</span>
<span class="org-comment">     * sur le fichier. Ces processus s'endormiront alors une fois encore.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Already_Open = 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * R&#195;&#169;veille tous les processus pr&#195;&#169;sent dans la file d'attente WaitQ,</span>
<span class="org-comment">     * Afin que ces derniers puissent enfin prendre la main sur le fichier</span>
<span class="org-comment">     * qu'ils attendent.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    wake_up(&amp;WaitQ);

    module_put(THIS_MODULE);

    <span class="org-keyword">return</span> 0;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Succ&#195;&#168;s </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Structure pour enregister le fichier /proc, contenant des</span>
<span class="org-comment"> * pointeurs vers les fonctions associ&#195;&#169;es.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La structure file operations pour notre fichier proc. C'est ici qu'on place</span>
<span class="org-comment"> * les pointeurs vers toutes les fonctions appel&#195;&#169;es quand quelqu'un essaie de</span>
<span class="org-comment"> * faire quoique ce soit avec notre fichier. La valeur NULL signifie qu'on</span>
<span class="org-comment"> * n'a pas implant&#195;&#169; la fonction associ&#195;&#169;e.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">File_Ops_4_Our_Proc_File</span> = {
    .read = module_output,   <span class="org-comment-delimiter">/* </span><span class="org-comment">"Lecture" de notre fichier              </span><span class="org-comment-delimiter">*/</span>
    .write = module_input,   <span class="org-comment-delimiter">/* </span><span class="org-comment">"Ecriture" de notre fichier             </span><span class="org-comment-delimiter">*/</span>
    .open = module_open,     <span class="org-comment-delimiter">/* </span><span class="org-comment">Appel&#195;&#169;e quand notre fichier sera ouvert </span><span class="org-comment-delimiter">*/</span>
    .release = module_close, <span class="org-comment-delimiter">/* </span><span class="org-comment">Appel&#195;&#169;e quand notre fichier sera ferm&#195;&#169;  </span><span class="org-comment-delimiter">*/</span>
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialisation et suppression de notre module.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialise notre module en enregistrant le fichier proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROC_ENTRY_FILENAME, 0644, <span class="org-constant">NULL</span>, &amp;File_Ops_4_Our_Proc_File);
    <span class="org-keyword">if</span>(Our_Proc_File == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROC_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Error: Could not initialize /proc/%s\n"</span>, PROC_ENTRY_FILENAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_info(<span class="org-string">"/proc/test created\n"</span>);

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction de sortie de notre module - Supprime notre fichier de /proc.</span>
<span class="org-comment"> * Cela pourrait &#195;&#170;tre dangereux si il y avait encore des processus pr&#195;&#169;sents</span>
<span class="org-comment"> * dans WaitQ, attendant la lib&#195;&#169;ration de notre fichier, parcequ'ils ont leurs</span>
<span class="org-comment"> * pointeurs de code dirig&#195;&#169;s vers notre fonction open(), qui va &#195;&#170;tre d&#195;&#169;charg&#195;&#169;e</span>
<span class="org-comment"> * du noyau. J'expliquerai dans le chapitre 10 comment &#195;&#169;viter de d&#195;&#169;charger un</span>
<span class="org-comment"> * module du noyau dans un tel cas.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    remove_proc_entry(PROC_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s removed\n"</span>, PROC_ENTRY_FILENAME);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * cat_noblock.c - Ouvre un fichier et affiche son contenu, mais pr&#195;&#169;f&#195;&#168;re</span>
<span class="org-comment"> * s'arr&#195;&#169;ter plutot que d'attendre le fichier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">Copyright (C) 1998 de Ori Pomerantz </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Entr&#195;&#169;e/Sortie standard </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;fcntl.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction open  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction read  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction exit  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;errno.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour les erreurs       </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">MAX_BYTES</span> 1024*4


<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[])
{
    <span class="org-type">int</span>    <span class="org-variable-name">fd</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">Le descripteur de fichier pour le fichier *</span>
<span class="org-comment">                               * qu'on souhaite lire                       </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>;             <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'octets lus                    </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">char</span>   <span class="org-variable-name">buffer</span>[MAX_BYTES]; <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon qui recevra les donn&#195;&#169;es         </span><span class="org-comment-delimiter">*/</span>


    <span class="org-comment-delimiter">/* </span><span class="org-comment">V&#195;&#169;rification du bon utilisation de notre programme </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (argc != 2) {
        printf(<span class="org-string">"Usage: %s &lt;filename&gt;\n"</span>, argv[0]);
        puts(<span class="org-string">"Reads the content of a file, but doesn't wait for input"</span>);
        exit(-1);
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ouvre le fichier pour une lecture en mode non bloquant </span><span class="org-comment-delimiter">*/</span>
    fd = open(argv[1], O_RDONLY | O_NONBLOCK);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Si l'ouverture a &#195;&#169;chou&#195;&#169;e </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (fd == -1) {
        <span class="org-keyword">if</span> (errno = EAGAIN)
            puts(<span class="org-string">"Open would block"</span>);
        <span class="org-keyword">else</span>
            puts(<span class="org-string">"Open failed"</span>);
        exit(-1);
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lit le fichier et affiche son contenu </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">do</span> {
        <span class="org-type">int</span> <span class="org-variable-name">i</span>;

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Lit les caract&#195;&#168;res depuis le fichier </span><span class="org-comment-delimiter">*/</span>
        bytes = read(fd, buffer, MAX_BYTES);

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Si une erreur est renvoy&#195;&#169;e, la signaler *</span>
<span class="org-comment">         * avant de terminer le processus          </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">if</span> (bytes == -1) {
            <span class="org-keyword">if</span> (errno = EAGAIN)
                puts(<span class="org-string">"Normally I'd block, but you told me not to"</span>);
            <span class="org-keyword">else</span>
                puts(<span class="org-string">"Another read error"</span>);
            exit(-1);
        }

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Affiche les caract&#195;&#168;res </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">if</span> (bytes &gt; 0) {
            <span class="org-keyword">for</span>(i=0; i&lt;bytes; i++)
                putchar(buffer[i]);
        }

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Continuer tant qu'il reste des caract&#195;&#168;res *</span>
<span class="org-comment">         * &#195;  lire dans notre fichier                 </span><span class="org-comment-delimiter">*/</span>
    } <span class="org-keyword">while</span> (bytes &gt; 0);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">AchÃ¨vements</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Parfois, certaines choses doivent se dÃ©rouler avec d'autres au sein d'un module disposant de plusieurs threads. PlutÃ´t que d'utiliser la commande <b>/proc/sleep</b>, le noyau a un autre moyen de rÃ©aliser ce mÃ©canisme, tout en permettant les temporisations et les interruptions.
</p>

<p>
Dans l'exemple suivant, deux threads sont dÃ©marrÃ©es au sein d'un module, mais l'une d'entre elle doit commencer aprÃ¨s l'autre pour le bon fonctionnement du module.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/completion.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> {
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">crank_comp</span>;
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">flywheel_comp</span>;
} <span class="org-variable-name">machine</span>;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">machine_crank_thread</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
    pr_info(<span class="org-string">"Turn the crank\n"</span>);

    complete_all(&amp;machine.crank_comp);
    complete_and_exit(&amp;machine.crank_comp, 0);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">machine_flywheel_spinup_thread</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
    wait_for_completion(&amp;machine.crank_comp);

    pr_info(<span class="org-string">"Flywheel spins up\n"</span>);

    complete_all(&amp;machine.flywheel_comp);
    complete_and_exit(&amp;machine.flywheel_comp, 0);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">completions_init</span>(<span class="org-type">void</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">task_struct</span>* <span class="org-variable-name">crank_thread</span>;
    <span class="org-keyword">struct</span> <span class="org-type">task_struct</span>* <span class="org-variable-name">flywheel_thread</span>;

    pr_info(<span class="org-string">"completions example\n"</span>);

    init_completion(&amp;machine.crank_comp);
    init_completion(&amp;machine.flywheel_comp);

    crank_thread =
        kthread_create(machine_crank_thread,
                       <span class="org-constant">NULL</span>, <span class="org-string">"KThread Crank"</span>);
    <span class="org-keyword">if</span> (IS_ERR(crank_thread))
        <span class="org-keyword">goto</span> <span class="org-constant">ERROR_THREAD_1</span>;

    flywheel_thread =
        kthread_create(machine_flywheel_spinup_thread,
                       <span class="org-constant">NULL</span>, <span class="org-string">"KThread Flywheel"</span>);
    <span class="org-keyword">if</span> (IS_ERR(flywheel_thread))
        <span class="org-keyword">goto</span> <span class="org-constant">ERROR_THREAD_2</span>;

    wake_up_process(flywheel_thread);
    wake_up_process(crank_thread);

    <span class="org-keyword">return</span> 0;

<span class="org-constant">ERROR_THREAD_2</span>:
    kthread_stop(crank_thread);
<span class="org-constant">ERROR_THREAD_1</span>:

    <span class="org-keyword">return</span> -1;
}

<span class="org-type">void</span> <span class="org-function-name">completions_exit</span>(<span class="org-type">void</span>)
{
    wait_for_completion(&amp;machine.crank_comp);
    wait_for_completion(&amp;machine.flywheel_comp);

    pr_info(<span class="org-string">"completions exit\n"</span>);
}

<span class="org-function-name">module_init</span>(completions_init);
<span class="org-function-name">module_exit</span>(completions_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Completions example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
La structure <i>machine</i> contient l'Ã©tat de complÃ©tude de ces deux threads. Ã€ la sortie de chacune de ces threads, l'Ã©tat associÃ© est mis Ã  jour pour signaler une terminaison, et <i>wait_for_completion</i> est utilisÃ©e par la thread flywheel pour s'assurer qu'elle ne dÃ©marre pas prÃ©maturÃ©ment.
</p>

<p>
Ainsi, mÃªme si <i>flywheel_thread</i> est dÃ©marrÃ©e en premier, vous noterez, si vous chargez ce module avec de jeter un coup d'oeil aux entrÃ©es du journal du noyau, que la note "turning the crank" apparaÃ®t toujours en premier. C'est parce que la thread flywheel attend toujours la complÃ©tion de l'autre thread avant de s'exÃ©cuter.
</p>

<p>
Il existe d'autres versions de la fonction <i>wait_for_completion</i>, qui incluent des temporisations ou des interruptions, mais ce mÃ©canisme basique conviendra dans la plupart des situations, en ayant l'avantage de limiter la complexitÃ© de votre module.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Eviter les collisions et les interblocages</h2>
<div class="outline-text-2" id="text-12">
<p>
Si des processus qui tournent sur diffÃ©rents processeurs ou dans diffÃ©rentes threads essaient d'accÃ©der au mÃªme espace mÃ©moire, il est possible que des choses surprenantes arrivent, voir que votre systÃ¨me se bloque. Pour Ã©viter ces problÃ¨mes, plusieurs types de fonction d'exclusion mutuelles sont disponibles au sein du noyau. Celles-ci indiquent si une partie de code est "verrouillÃ©" ou "libre", afin d'Ã©viter des exÃ©cutions concurrentes du mÃªme code.
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">Mutex</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Vous pouvez utiliser les mutex noyau (exclusions mutuelles) de la mÃªme maniÃ¨re que vous les exÃ©cuteriez en espace utilisateur. Ce mÃ©canisme sera suffisant pour Ã©viter les collisions dans la plupart des cas.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/mutex.h&gt;</span>

<span class="org-function-name">DEFINE_MUTEX</span>(mymutex);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_mutex_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    pr_info(<span class="org-string">"example_mutex init\n"</span>);

    ret = mutex_trylock(&amp;mymutex);
    <span class="org-keyword">if</span> (ret != 0) {
        pr_info(<span class="org-string">"mutex is locked\n"</span>);

        <span class="org-keyword">if</span> (mutex_is_locked(&amp;mymutex) == 0)
            pr_info(<span class="org-string">"The mutex failed to lock!\n"</span>);

        mutex_unlock(&amp;mymutex);
        pr_info(<span class="org-string">"mutex is unlocked\n"</span>);
    }
    <span class="org-keyword">else</span>
        pr_info(<span class="org-string">"Failed to lock\n"</span>);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_mutex_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_mutex exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_mutex_init);
<span class="org-function-name">module_exit</span>(example_mutex_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Mutex example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">Verrou tournant</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Le verrou tournant, ou spinlock, est un mÃ©canisme de verrou basÃ© sur l'attente active ; La thread qui essaie d'acquÃ©rir une ressource vÃ©rouillÃ©e va mobiliser toutes les ressources du processeur en vue d'acquÃ©rir ce verrou. Elle va faire la demande de la ressource des millions de fois, jusqu'Ã  ce qu'elle l'obtienne. C'est la raison pour laquelle vous ne devriez utiliser ce verrou que pour du code qui peut espÃ©rer rÃ©aliser sa tÃ¢che en moins de quelques millisecondes. Dans le cas contraire l'utilisateur risquera d'Ãªtre tÃ©moin de ralentissements du systÃ¨me.
</p>

<p>
L'exemple ici est /"irq safe"/ dans le sens oÃ¹les interruptions qui peuvent arriver durant le verrou ne seront pas omises grÃ¢ce Ã  la variable <i>flags</i> qui les retiendra. Elles seront ensuite traitÃ©es quand le verrou sera libÃ©rÃ©.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/spinlock.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-function-name">DEFINE_SPINLOCK</span>(sl_static);
<span class="org-type">spinlock_t</span> <span class="org-variable-name">sl_dynamic</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_static</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    spin_lock_irqsave(&amp;sl_static, flags);
    pr_info(<span class="org-string">"Locked static spinlock\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous devez &#195;&#170;tre s&#195;&#187;r de ce que vous</span>
<span class="org-comment">       faites. Parce que vous avez verrouill&#195;&#169;</span>
<span class="org-comment">       une ressource, et qu'un autre programme</span>
<span class="org-comment">       qui attendra l'acc&#195;&#168;s &#195;  cette ressource</span>
<span class="org-comment">       utilisera TOUTES les ressources de</span>
<span class="org-comment">       votre processeur, ce code ne doit</span>
<span class="org-comment">       jamais demander plus de quelques</span>
<span class="org-comment">       millisecondes pour &#195;&#170;tre ex&#195;&#169;cut&#195;&#169;. </span><span class="org-comment-delimiter">*/</span>

    spin_unlock_irqrestore(&amp;sl_static, flags);
    pr_info(<span class="org-string">"Unlocked static spinlock\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_dynamic</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    spin_lock_init(&amp;sl_dynamic);
    spin_lock_irqsave(&amp;sl_dynamic, flags);
    pr_info(<span class="org-string">"Locked dynamic spinlock\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous devez &#195;&#170;tre s&#195;&#187;r de ce que vous</span>
<span class="org-comment">       faites. Parce que vous avez verrouill&#195;&#169;</span>
<span class="org-comment">       une ressource, et qu'un autre programme</span>
<span class="org-comment">       qui attendra l'acc&#195;&#168;s &#195;  cette ressource</span>
<span class="org-comment">       utilisera TOUTES les ressources de</span>
<span class="org-comment">       votre processeur, ce code ne doit</span>
<span class="org-comment">       jamais demander plus de quelques</span>
<span class="org-comment">       millisecondes pour &#195;&#170;tre ex&#195;&#169;cut&#195;&#169;. </span><span class="org-comment-delimiter">*/</span>

    spin_unlock_irqrestore(&amp;sl_dynamic, flags);
    pr_info(<span class="org-string">"Unlocked dynamic spinlock\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_spinlock_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example spinlock started\n"</span>);

    example_spinlock_static();
    example_spinlock_dynamic();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example spinlock exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_spinlock_init);
<span class="org-function-name">module_exit</span>(example_spinlock_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Spinlock example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3">Verrou lecture/Ã©criture</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Le verrou de type lecture/Ã©criture est une sorte de verrou tournant spÃ©cialisÃ©, afin que vous puissiez exclusivement lire ou Ã©crire vers une certaine ressource. Comme l'exemple de verrou tournant prÃ©cÃ©dent, cet exemple est "irq safe", dans le sens oÃ¹ si d'autres fonctions doivent Ãªtre appelÃ©es en raison d'interruptions reÃ§ues, leurs exÃ©cutions seront diffÃ©rÃ©es sans Ãªtre oubliÃ©es. Comme prÃ©cÃ©demment, c'est une bonne idÃ©e de n'utiliser le verrou qu'un minimum de temps possible afin de ne pas ralentir le systÃ¨me. Ceci bien sÃ»r afin d'Ã©viter le soulÃ¨vement des utilisateurs contre le diktat de votre module.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-function-name">DEFINE_RWLOCK</span>(myrwlock);

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_read_lock</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    read_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Read Locked\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lecture </span><span class="org-comment-delimiter">*/</span>

    read_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Read Unlocked\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_write_lock</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    write_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Write Locked\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ecriture </span><span class="org-comment-delimiter">*/</span>

    write_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Write Unlocked\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_rwlock_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_rwlock started\n"</span>);

    example_read_lock();
    example_write_lock();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_rwlock_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_rwlock exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_rwlock_init);
<span class="org-function-name">module_exit</span>(example_rwlock_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Read/Write locks example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Bien sÃ»r, si vous Ãªtes certain qu'aucune fonction dÃ©clenchÃ©e par des interruptions ne pourra gÃªner votre algorithme, alors vous pouvez vous contenter des fonctions <i>read_lock(&amp;myrwlock)</i> et <i>read_unlock(&amp;myrwlock)/</i>
</p>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4">OpÃ©rations atomiques</h3>
<div class="outline-text-3" id="text-12-4">
<p>
Si vous rÃ©alisez des opÃ©rations arithmÃ©tiques simple : ajouter, soustraire ou rÃ©aliser des opÃ©rations bit-Ã -bit, alors il existe un autre moyen pour s'assurer, dans un monde oÃ¹ plusieurs processeurs et programmes tournent en concurrence, qu'un Ã©tranger ne vous a pas dÃ©rangÃ© dans votre travail. En utilisant les opÃ©rations atomiques, vous Ãªtes assurÃ© que votre opÃ©ration s'est dÃ©roulÃ© exactement comme vous le souhaitez, et qu'un tierce programme n'a pas modifiÃ© la valeur sur laquelle vous travaillez en mÃªme temps que lui. En voici un exemple :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">BYTE_TO_BINARY_PATTERN</span> <span class="org-string">"%c%c%c%c%c%c%c%c"</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">BYTE_TO_BINARY</span>(<span class="org-variable-name">byte</span>)  \
  (byte &amp; 0x80 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x40 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x20 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x10 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x08 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x04 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x02 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x01 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>)

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">atomic_add_subtract</span>(<span class="org-type">void</span>)
{
    <span class="org-type">atomic_t</span> <span class="org-variable-name">debbie</span>;
    <span class="org-type">atomic_t</span> <span class="org-variable-name">chris</span> = ATOMIC_INIT(50);

    atomic_set(&amp;debbie, 45);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;cr&#195;&#169;mentation atomique </span><span class="org-comment-delimiter">*/</span>
    atomic_dec(&amp;debbie);

    atomic_add(7, &amp;debbie);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Incr&#195;&#169;mentation atomique </span><span class="org-comment-delimiter">*/</span>
    atomic_inc(&amp;debbie);

    pr_info(<span class="org-string">"chris: %d, debbie: %d\n"</span>,
           atomic_read(&amp;chris), atomic_read(&amp;debbie));
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">atomic_bitwise</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">word</span> = 0;

    pr_info(<span class="org-string">"Bits 0: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    set_bit(3, &amp;word);
    set_bit(5, &amp;word);
    pr_info(<span class="org-string">"Bits 1: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    clear_bit(5, &amp;word);
    pr_info(<span class="org-string">"Bits 2: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    change_bit(3, &amp;word);

    pr_info(<span class="org-string">"Bits 3: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    <span class="org-keyword">if</span> (test_and_set_bit(3, &amp;word))
        pr_info(<span class="org-string">"wrong\n"</span>);
    pr_info(<span class="org-string">"Bits 4: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));

    word = 255;
    pr_info(<span class="org-string">"Bits 5: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_atomic_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_atomic started\n"</span>);

    atomic_add_subtract();
    atomic_bitwise();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_atomic_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_atomic exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_atomic_init);
<span class="org-function-name">module_exit</span>(example_atomic_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Atomic operations example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Remplacer les macros Print</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">Remplacement</h3>
<div class="outline-text-3" id="text-13-1">
<p>
Dans la section 1.2.1.2, j'ai dit que les interfaces graphiques et les modules ne vont pas bien ensemble. C'est vrai pour le dÃ©veloppement de modules noyau, mais en situation rÃ©elle, vous souhaitez Ãªtre capable d'envoyer des messages au terminal qui vous a demandÃ© de charger le module en question.
</p>

<p>
"tty" est une abrÃ©viation de <i>teletype</i>: Ã  l'origine, il s'agissait d'un pÃ©riphÃ©rique matÃ©riel, une combinaison clavier-moniteur utilisÃ©e pour communiquer avec un systÃ¨me Unix. C'est aujourd'hui devenu, par abstraction, un flot de texte utilisÃ© par un programme Unix, que ce soit un terminal physique, un terminal virtuel au sein d'une interface graphique, une connexion rÃ©seau utilisÃ©e par le rÃ©seau via ssh, et bien d'autres&#x2026;
</p>

<p>
Cette abstraction est implantÃ©e de la maniÃ¨re suivante : On dispose d'un pointeur, current, vers la tÃ¢che en cours d'exÃ©cution, Ã  partir duquel on peut obtenir la structure tty de cette tÃ¢che. Ensuite, au sein de cette structure tty, on dispose d'un pointeur vers une fonction d'Ã©criture, qui sera appelÃ©e pour Ã©crire une chaÃ®ne de caractÃ¨res sur le terminal du programme en cours.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  print_string.c - Affichage de donn&#195;&#169;es sur le terminal, qu'il</span>
<span class="org-comment"> *  s'agisse d'un terminal graphique, d'une liaison ssh, etc.</span>
<span class="org-comment"> *  Pour agir, il suffit d'&#195;&#169;crire une cha&#195;&#174;ne de caract&#195;&#168;res sur le</span>
<span class="org-comment"> *  terminal associ&#195;&#169; &#195;  la t&#195;&#162;che courante.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Fournit l'acc&#195;&#168;s &#195;  la structure   *</span>
<span class="org-comment">                            * associ&#195;&#169;e &#195;  la t&#195;&#162;che courrante    </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/tty.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour les d&#195;&#169;clarations du tty     </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/version.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la macro LINUX_VERSION_CODE </span><span class="org-comment-delimiter">*/</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Peter Jay Salzman"</span>);

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_string</span>(<span class="org-type">char</span> *<span class="org-variable-name">str</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">tty_struct</span> *<span class="org-variable-name">my_tty</span>;
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">tty_operations</span> *<span class="org-variable-name">ttyops</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La location de la structure tty a chang&#195;&#169;</span>
<span class="org-comment">     * depuis la version 2.6.6 du noyau</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,5) )
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Pour le tty de la t&#195;&#162;che courante, pour les noyaux plus vieux que 2.6.6</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    my_tty = current-&gt;tty;
<span class="org-preprocessor">#else</span>
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Pour le tty de la t&#195;&#162;che courante, pour les noyaux les plus r&#195;&#169;cents</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    my_tty = get_current_tty();
<span class="org-preprocessor">#endif</span>
    ttyops = my_tty-&gt;driver-&gt;ops;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si my_tty est NULL, &#195;&#167;a signifie qu'aucun tty n'est associ&#195;&#169; &#195;  la</span>
<span class="org-comment">     * t&#195;&#162;che courante. (Cela peut vous arriver, par exemple si c'est un</span>
<span class="org-comment">     * d&#195;&#169;mon). Si c'est le cas, vous &#195;&#170;tes pieds et poings li&#195;&#169;s et ne</span>
<span class="org-comment">     * pouvez rien faire.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (my_tty != <span class="org-constant">NULL</span>) {

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * my_tty-&gt;driver est une structure qui contient les fonctions</span>
<span class="org-comment">         * du tty, dont l'une d'entre elle (write) est utilis&#195;&#169;e pour</span>
<span class="org-comment">         * &#195;&#169;crire des cha&#195;&#174;nes de caract&#195;&#168;res au tty.</span>
<span class="org-comment">         * On peut s'en servir pour &#195;&#169;crire une cha&#195;&#174;ne, qu'elle soit</span>
<span class="org-comment">         * localis&#195;&#169;e dans l'espace utilisateur, ou dans l'espace noyau</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le premier param&#195;&#168;tre de la fonction est le tty vers lequel</span>
<span class="org-comment">         * vous souhaitez &#195;&#169;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le second param&#195;&#168;tre est un bool&#195;&#169;en qui stipule si la cha&#195;&#174;ne</span>
<span class="org-comment">         * de caract&#195;&#168;re re&#195;&#167;ue vient de l'espace noyau (0/faux), o&#195;&#185;</span>
<span class="org-comment">         * s'il vient de l'espace utilisateur (vrai/positif).</span>
<span class="org-comment">         * Attention cependant : Depuis les versions du Noyau sup&#195;&#169;rieures</span>
<span class="org-comment">         * &#195;  2.6.9, ce param&#195;&#168;tre a &#195;&#169;t&#195;&#169; supprim&#195;&#169;.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le param&#195;&#168;tre suivant est un pointeur vers la cha&#195;&#174;ne de</span>
<span class="org-comment">         * caract&#195;&#168;res &#195;  &#195;&#169;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le dernier param&#195;&#168;tre est la taille de la cha&#195;&#174;ne de caract&#195;&#168;res</span>
<span class="org-comment">         * &#195;  &#195;&#169;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Comme vous le verrez plus bas, il est parfois n&#195;&#169;cessaire</span>
<span class="org-comment">         * d'utiliser le pr&#195;&#169;processeur pour cr&#195;&#169;er du code qui marchera</span>
<span class="org-comment">         * sur diff&#195;&#169;rentes versions du noyau. L'approche na&#195;&#175;vre qu'on a</span>
<span class="org-comment">         * adopt&#195;&#169; ici est loin d'&#195;&#170;tre parfaite. Le meilleur moyen de</span>
<span class="org-comment">         * r&#195;&#169;gler ces probl&#195;&#168;mes  est d&#195;&#169;crit dans la seconde section de</span>
<span class="org-comment">         * linux/Documentation/SubmittingPatches</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        (ttyops-&gt;write) (my_tty,      <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tty </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
                         0,            <span class="org-comment-delimiter">/* </span><span class="org-comment">La cha&#195;&#174;ne de caract&#195;&#168;res           *</span>
<span class="org-comment">                                        * est localis&#195;&#169;e en espace           *</span>
<span class="org-comment">                                        * noyau                             </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#endif</span>
                         str,          <span class="org-comment-delimiter">/* </span><span class="org-comment">La cha&#195;&#174;ne de caract&#195;&#168;res</span>
<span class="org-comment">                                        * &#195;  &#195;&#169;crire                          </span><span class="org-comment-delimiter">*/</span>
                         strlen(str)); <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille de la cha&#195;&#174;ne de caract&#195;&#168;res </span><span class="org-comment-delimiter">*/</span>

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Les ttys &#195;&#169;taient &#195;  l'origine des p&#195;&#169;riph&#195;&#169;riques physiques</span>
<span class="org-comment">         * qui, le plus souvant, suivaient &#195;  la lettre la r&#195;&#168;gle ASCII</span>
<span class="org-comment">         * standard. En ASCII, pour acc&#195;&#168;der &#195;  une nouvelle ligne,</span>
<span class="org-comment">         * vous avez besoin de deux caract&#195;&#168;res : un retour de chariot</span>
<span class="org-comment">         * et un saut de ligne. Sur Unix, le saut de ligne sert aussi</span>
<span class="org-comment">         * de retour chariot, mais pas pour votre tty. C'est pourquoi</span>
<span class="org-comment">         * on ne peut donc pas se contenter d'un \n. Il faut rajouter</span>
<span class="org-comment">         * un retour chariot, ou sinon quoi notre terminal continuera</span>
<span class="org-comment">         * bien son affichage sur la ligne suivante, mais sur la m&#195;&#170;me</span>
<span class="org-comment">         * colonne.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * C'est pourquoi les fichiers de texte sont diff&#195;&#169;rents selon</span>
<span class="org-comment">         * Unix ou Windows. Dans CP/M est ses d&#195;&#169;riv&#195;&#169;s, tel que MS-DOS</span>
<span class="org-comment">         * et MS-Windows, la r&#195;&#168;gle ASCII a &#195;&#169;t&#195;&#169; suivie &#195;  la lettre, ce</span>
<span class="org-comment">         * qui signifie qu'une nouvelle ligne inclut un saut de ligne</span>
<span class="org-comment">         * ET un retour chariot (d'ou le \rn).</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
        (ttyops-&gt;write) (my_tty, 0, <span class="org-string">"\015\012"</span>, 2);
<span class="org-preprocessor">#else</span>
        (ttyops-&gt;write) (my_tty, <span class="org-string">"\015\012"</span>, 2);
<span class="org-preprocessor">#endif</span>
    }
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> print_string_init(<span class="org-type">void</span>)
{
    print_string(<span class="org-string">"The module has been inserted.  Hello world!"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> print_string_exit(<span class="org-type">void</span>)
{
    print_string(<span class="org-string">"The module has been removed.  Farewell world!"</span>);
}

<span class="org-function-name">module_init</span>(print_string_init);
<span class="org-function-name">module_exit</span>(print_string_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">Faire clignoter les LEDS du clavier</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Vous chercherez parfois un moyen plus simple et plus concret de communiquer avec le monde extÃ©rieur. Un exemple frappant : les LEDs de votre clavier qui vous signalent que vous Ãªtes en mode majuscule ou minuscule. On peut se servir de ces LEDs pour attirer l'attention ou afficher un Ã©tat de votre systÃ¨me. Les LEDs sont prÃ©sents sur quasiment tous les claviers, dans quel cas ils sont toujours visibles, n'ont pas besoin d'Ãªtre installÃ©s, en plus de quoi leur usage est plus simple et discret que l'Ã©criture sur un terminal ou sur un fichier.
</p>

<p>
Le code suivant est un exemple de noyau minimal qui permet, une fois qu'il est chargÃ© de faire clignoter les LEDs du clavier jusqu'Ã  son dÃ©chargement du noyau.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  kbleds.c - Fait clignoter les LEDs du clavier tant que le module est</span>
<span class="org-comment"> *  charg&#195;&#169; au sein du noyau</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/vt_kern.h&gt;</span>              <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#195;&#168;s &#195;  fg_console    </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/tty.h&gt;</span>                  <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#195;&#168;s &#195;  fg_console,   *</span>
<span class="org-comment">                                         * et &#195;  la macroMAX_NR_CONSOLES </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kd.h&gt;</span>                   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#195;&#168;s &#195;  KDSETLED      </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/vt.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/console_struct.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#195;&#168;s &#195;  vc_cons       </span><span class="org-comment-delimiter">*/</span>

MODULE_DESCRIPTION(<span class="org-string">"Example module illustrating the use of Keyboard LEDs."</span>);
MODULE_AUTHOR(<span class="org-string">"Daniele Paolo Scarpazza"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);

<span class="org-keyword">struct</span> <span class="org-type">timer_list</span> <span class="org-variable-name">my_timer</span>;
<span class="org-keyword">struct</span> <span class="org-type">tty_driver</span> *<span class="org-variable-name">my_driver</span>;
<span class="org-type">char</span> <span class="org-variable-name">kbledstatus</span> = 0;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">BLINK_DELAY</span>   HZ/5
<span class="org-preprocessor">#define</span> <span class="org-variable-name">ALL_LEDS_ON</span>   0x07
<span class="org-preprocessor">#define</span> <span class="org-variable-name">RESTORE_LEDS</span>  0xFF

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La fonction my_timer_func fait clignoter les LEDs du clavier de mani&#195;&#168;re</span>
<span class="org-comment"> * p&#195;&#169;riodique en appelant la commande KDSETLED (qui est un appel ioctl sur</span>
<span class="org-comment"> * une console virtuelle) sur le pilote du clavier.</span>
<span class="org-comment"> * Pour en apprendre plus sur les op&#195;&#169;rations sur les consoles virtuelles,</span>
<span class="org-comment"> * regardez le fichier :</span>
<span class="org-comment"> *     /usr/src/linux/drivers/char/vt_ioctl.c, fonction vt_ioctl().</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * L'argument de KDSETLED est affect&#195;&#169; &#195;  tour de r&#195;&#180;le &#195;  0x07 et &#195;  0xFF.</span>
<span class="org-comment"> * 0x07 conduit les Leds &#195;  &#195;&#170;tre affect&#195;&#169;es &#195;  LED_SHOW_IOCTL, ce qui les allume</span>
<span class="org-comment"> * 0xFF affecte les Leds &#195;  LED_SHOW_FLAGS, o&#195;&#185; ces derni&#195;&#168;res correspondes &#195;</span>
<span class="org-comment"> * l'&#195;&#169;tat du clavier.</span>
<span class="org-comment"> * Pour en apprendre plus, regardez :</span>
<span class="org-comment"> *     /usr/src/linux/drivers/char/keyboard.c, fonction setledstate().</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">my_timer_func</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">ptr</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> *<span class="org-variable-name">pstatus</span> = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)ptr;
    <span class="org-keyword">struct</span> <span class="org-type">tty_struct</span>* <span class="org-variable-name">t</span> = vc_cons[fg_console].d-&gt;port.tty;

    <span class="org-keyword">if</span> (*pstatus == ALL_LEDS_ON)
        *pstatus = RESTORE_LEDS;
    <span class="org-keyword">else</span>
        *pstatus = ALL_LEDS_ON;

    (my_driver-&gt;ops-&gt;ioctl) (t, KDSETLED, *pstatus);

    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> kbleds_init(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"kbleds: loading\n"</span>);
    pr_info(<span class="org-string">"kbleds: fgconsole is %x\n"</span>, fg_console);
    <span class="org-keyword">for</span> (i = 0; i &lt; MAX_NR_CONSOLES; i++) {
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>vc_cons[i].d)
            <span class="org-keyword">break</span>;
        pr_info(<span class="org-string">"poet_atkm: console[%i/%i] #%i, tty %lx\n"</span>, i,
               MAX_NR_CONSOLES, vc_cons[i].d-&gt;vc_num,
               (<span class="org-type">unsigned</span> <span class="org-type">long</span>)vc_cons[i].d-&gt;port.tty);
    }
    pr_info(<span class="org-string">"kbleds: finished scanning consoles\n"</span>);

    my_driver = vc_cons[fg_console].d-&gt;port.tty-&gt;driver;
    pr_info(<span class="org-string">"kbleds: tty driver magic %x\n"</span>, my_driver-&gt;magic);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * R&#195;&#168;gle le temporisateur de clignotement pour la premi&#195;&#168;re fois</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    timer_setup(&amp;my_timer, (<span class="org-type">void</span>*)&amp;my_timer_func, (<span class="org-type">unsigned</span> <span class="org-type">long</span>)&amp;kbledstatus);
    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> kbleds_cleanup(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"kbleds: unloading...\n"</span>);
    del_timer(&amp;my_timer);
    (my_driver-&gt;ops-&gt;ioctl) (vc_cons[fg_console].d-&gt;port.tty,
                             KDSETLED, RESTORE_LEDS);
}

<span class="org-function-name">module_init</span>(kbleds_init);
<span class="org-function-name">module_exit</span>(kbleds_cleanup);
</pre>
</div>

<p>
Si aucun des exemples prÃ©sents dans ce chapitre ne rÃ©pond Ã  vos besoins en terme de dÃ©bogage, il existe encore quelques astuces Ã  essayer. Vous Ãªtes vous dÃ©jÃ  demandÃ© Ã  quoi la macro CONFIG_LL_DEBUG du make menuconfig sert ? Si vous l'activez, alors vous aurez un accÃ¨s bas niveau au port sÃ©rie. Bien que Ã§a ne semble pas trÃ¨s utile, sachez que vous pourrez alors modifier <b>kernel/printk.c</b> ou n'importe quel autre appel systÃ¨me pour utiliser printascii, ce qui vous permettra de laisser une trace sur absolument tout ce que fait votre code, de prÃ¨s ou de loin, sur le port sÃ©rie. Si vous souhaitez porter le noyau sur une nouvelle architecture, cette manipulation est gÃ©nÃ©ralement la premiÃ¨re Ã  rÃ©aliser. Se connecter Ã  votre noyau Ã  travers une console via le rÃ©seau pourra aussi Ãªtre une chose trÃ¨s utile Ã  des fin de dÃ©bogage.
</p>

<p>
Bien que vous ayez lu quelques maniÃ¨res de dÃ©boguer, sachez que le dÃ©bogage est presque toujours une mÃ©thode trÃ¨s intrusive vis-Ã -vis de votre code. La simple insertion de code de dÃ©bogage pour localiser un problÃ¨me peut changer en profondeur votre code jusqu'Ã  ce que vous ayez l'impression que votre problÃ¨me est rÃ©solu. C'est un problÃ¨me qui vous arrivera tÃ´t ou tard. C'est la raison pour laquelle vous devrez limiter le code de dÃ©bogage au strict minimum, et surtout faire des essais, sans cesse et sans arrÃªt, pour s'assurer que les problÃ¨mes ne reviendront pas en situation de production.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">TÃ¢ches ordonnancÃ©es</h2>
<div class="outline-text-2" id="text-14">
<p>
Il existe deux maniÃ¨res de lancer un tÃ¢che : via le mÃ©canisme de tasklet et via les files de travaux. Les tasklets sont un moyen rapide et facile d'ordonnancer une tÃ¢che unique, par exemple en la dÃ©clanchant suite Ã  une interruption, alors que les files de travaux sont plus complexes, mais plus efficaces pour exÃ©cuter plusieurs tÃ¢ches.
</p>
</div>

<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">Tasklets</h3>
<div class="outline-text-3" id="text-14-1">
<p>
Voici un exemple de module qui utilise les tasklets. La fonction <i>tasklet_fn</i> est lancÃ©e pour quelques secondes, durant lesquelles l'exÃ©cution de <i>example_tasklet_init</i> continue jusqu'Ã  se terminer.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">tasklet_fn</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">data</span>)
{
    pr_info(<span class="org-string">"Example tasklet starts\n"</span>);
    mdelay(5000);
    pr_info(<span class="org-string">"Example tasklet ends\n"</span>);
}

<span class="org-function-name">DECLARE_TASKLET</span>(mytask, tasklet_fn, 0L);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_tasklet_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"tasklet example init\n"</span>);
    tasklet_schedule(&amp;mytask);
    mdelay(200);
    pr_info(<span class="org-string">"Example tasklet init continues...\n"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_tasklet_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"tasklet example exit\n"</span>);
    tasklet_kill(&amp;mytask);
}

<span class="org-function-name">module_init</span>(example_tasklet_init);
<span class="org-function-name">module_exit</span>(example_tasklet_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Tasklet example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Ansi, avec cet exemple, les notes au sein de <i>dmesg</i> devraient contenir :
</p>

<div class="org-src-container">

<pre class="src src-bash">tasklet example init
Example tasklet starts
Example tasklet init continues...
Example tasklet ends
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">Files de travaux</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Pour ajouter une tÃ¢che Ã  l'ordonnanceur, vous pouvez utiliser une file de travaux. Le noyau utilise ensuite le Completely Fair Scheduler (CFS) (entendez l'ordonnanceur parfaitement Ã©quitable) pour exÃ©cuter les travaux dans cette file d'attente.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/workqueue.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">workqueue_struct</span> *<span class="org-variable-name">queue</span>=<span class="org-constant">NULL</span>;
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">work_struct</span> <span class="org-variable-name">work</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">work_handler</span>(<span class="org-keyword">struct</span> <span class="org-type">work_struct</span> *<span class="org-variable-name">data</span>)
{
    pr_info (<span class="org-string">"work handler function.\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    queue = alloc_workqueue(<span class="org-string">"HELLOWORLD"</span>, WQ_UNBOUND, 1);
    INIT_WORK(&amp;work, work_handler);
    schedule_work(&amp;work);

    <span class="org-keyword">return</span> 0;

}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    destroy_workqueue(queue);
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Workqueue example"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Gestionnaire d'interruptions</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">Gestionnaire d'interruptions</h3>
<div class="outline-text-3" id="text-15-1">
<p>
Ã€ l'exception du dernier chapitre, tout ce qu'on a rÃ©alisÃ© dans le noyau jusqu'ici Ã©tait du code appelÃ© par un processus qui le demandait, que ce soit Ã  travers un fichier spÃ©cial, Ã  travers l'envoi d'un ioctl(), ou un appel systÃ¨me. Mais ce n'est pas la principale fonction d'un noyau. Un systÃ¨me d'exploitation a la tÃ¢che essentielle de communiquer avec le matÃ©riel connectÃ© Ã  la machine.
</p>

<p>
Il existe deux interactions diffÃ©rentes entre le processeur et les autres pÃ©riphÃ©riques. La premiÃ¨re, c'est quand le processeur ordonne des actions au matÃ©riel, et les transferts de donnÃ©es qui en dÃ©coulent. La seconde interaction, appelÃ©e interruption, advient quand le matÃ©riel doit informer le processus d'une situation particuliÃ¨re. Les interruptions sont dures Ã  implanter, parce que le dÃ©veloppeur doit tenir compte des contraintes matÃ©rielles que le processeur ignore. Par exemple, de nombreux pÃ©riphÃ©riques ont une mÃ©moire trÃ¨s limitÃ©e. Si vous ne lisez pas les bons registres du pÃ©riphÃ©rique quand elle est disponible, cette information risque d'Ãªtre perdue trÃ¨s vite. Par exemple, certains claviers ont un registre unique qui contient la derniÃ¨re touche tapÃ©e par l'utilisateur. Si l'information n'est pas lue avant que l'utilisateur appuie sur une nouvelle touche, cette information risque d'Ãªtre perdue. Pour Ã©viter ce cas, le clavier va envoyer une interruption au systÃ¨me pour le prÃ©venir qu'une nouvelle information est disponible.
</p>

<p>
Sous Linux, les interruptions matÃ©rielles sont appelÃ©es IRQ, pour requÃªtes d'interruption. Il existe deux types d'IRQ : les courtes et les longues. Une IRQ courte est une IRQ qui doit Ãªtre traitÃ©e en trÃ¨s peu de temps, pendant lequel aucune autre interruption ne pourra Ãªtre prise en compte. Une IRQ longue peut au contraire durer plus longtemps et peut Ãªtre interrompue par d'autres interruptions d'un matÃ©riel diffÃ©rent (mais pas du mÃªme matÃ©riel). Dans chaque cas oÃ¹ la situation le permet, il est prÃ©fÃ©rable d'utiliser les IRQ longues.
</p>

<p>
Quand le processeur reÃ§oit une interruption, il arrÃªte ce qu'il fait (Ã  moins qu'il ne soit dÃ©jÃ  occupÃ© par une interruption plus importante, dans quel cas il s'occupe de l'interruption la plus importante), sauvegarde certains paramÃ¨tres sur la pile d'exÃ©cution, et appelle le gestionnaire d'interruption. Ce qui signifie que tout n'est pas permis dans le gestionnaire d'interruption. C'est pourquoi le gestionnaire d'interruption se contente de faire ce qui est urgent, en gÃ©nÃ©ral il s'agit de lire ou d'Ã©crire dans les registres du matÃ©riel, avant d'ordonnancer la gestion de cette nouvelle information afin de s'en occuper plus tard (c'est ce qu'on appelle le "bottom half", ou la partie immergÃ©e). Finalement, le gestionnaire d'interruption rend la main Ã  la tÃ¢che qui a Ã©tÃ© interrompue par l'interruption. Le noyau garantit ensuite d'appeler la partie immergÃ©e de l'interruption dÃ¨s que possible &#x2013; et Ã  ce moment, le noyau aura tous les droits.
</p>

<p>
Le moyen de procÃ©der de la sorte est d'appeler <b>request_irq()</b> afin que votre gestionnaire d'interruption soit appelÃ© quand l'IRQ associÃ©e est reÃ§ut.
</p>

<p>
Dans la pratique, la gestion des IRQ est un peu plus complexe. La plupart des pÃ©riphÃ©riques sont conÃ§us de telle sorte que deux gestionnaires devront Ãªtre appelÃ©s en cascade. Ainsi, toutes les IRQs d'un gestionnaire d'interruption B seront reconduites vers une certaine IRQ d'un autre gestionnaire d'interruption A. Bien sÃ»r, Ã§a nÃ©cessite que le noyau cherche quelle Ã©tait l'IRQ qui Ã©tait vraiment lancÃ©e par le matÃ©riel. D'autres architectures matÃ©rielles proposent d'autres mÃ©canismes d'interruptions, appelÃ©s "fast IRQ" (FIQ) pour requÃªte d'interruption rapide. Comme ils sont relatifs Ã  certaines architectures, ils doivent Ãªtre codÃ©s en assembleur. C'est la raison pour laquelle ils sont d'une certaine maniÃ¨re Ã  l'Ã©cart du noyau. Ils peuvent Ãªtre conÃ§us de la mÃªme maniÃ¨re que les autres IRQs mais dans ce cas ils ne seraient pas plus rapides que les requÃªtes interruptions "normales". Les noyaux conÃ§us pour les systÃ¨mes multi-processeurs (les noyaux SMP, pour Symmetric MultiProcessor) ont encore plus de problÃ¨mes Ã  rÃ©gler. Dans ces noyaux, au moment oÃ¹ une interruption est levÃ©e, il faut non seulement trouver quelle IRQs est levÃ©e, mais il faut aussi prendre en compte Ã  quel processeur elle Ã©tait destinÃ©e. Cela dÃ©passe le cadre de ce cours, mais les personnes qui souhaitent en savoir plus devraient faire des recherches sur les "Advanced Programmable Interrupt Controller".
</p>

<p>
La fonction <b>request_irq()</b> qui permet d'activer une fonction qui va gÃ©rer l'interruption reÃ§oit un numÃ©ro de requÃªte d'interruption, une fonction, des drapeaux, un nom pour le fichier <i>proc</i> de l'interruption et un paramÃ¨tre Ã  passer au gestionnaire d'interruption. Il n'y a qu'un certain nombre de requÃªtes d'interruption, et ce nombre dÃ©pend du matÃ©riel. Les drapeaux qui sont passÃ©s peuvent inclure SA_SHIRQ, qui indique que vous Ãªtes en train de partager la requÃªte d'interruption en cours avec un autre gestionnaire d'interruption (en gÃ©nÃ©ral parce que plusieurs pÃ©riphÃ©riques matÃ©riels partagent la mÃªme requÃªte d'interruption), ou SA_INTERRUPT, qui indique que vous traitez une interruption courte. Cette fonction ne se terminera avec succÃ¨s que s'il n'existe pas dÃ©jÃ  un gestionnaire pour cette interuption, ou si les deux gestionnaires ont conscience de partager une mÃªme interruption.
</p>
</div>
</div>

<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">DÃ©tection de pression de bouton</h3>
<div class="outline-text-3" id="text-15-2">
<p>
Les ordinateurs monocartes les plus populaires, comme les Raspberry Pis ou les Beagleboard disposent de plusieurs broches GPIO (traduites littÃ©ralement par EntrÃ©e/Sortie pour un Usage GÃ©nÃ©ral). Vous pouvez attacher un bouton poussoir Ã  ces broches. Vous aurez ensuite deux maniÃ¨re diffÃ©rentes de savoir si un utilisateur appuie sur l'un des boutons. Soit en crÃ©ant une tÃ¢che qui va gaspiller du temps de processeur et de l'Ã©nergie en regardant pÃ©riodiquement si le bouton est appuyÃ©, ou faire en sorte que l'appui dÃ©clenche une interruption, qui sera gÃ©rÃ©e par le processeur en appelant la fonction de gestion d'interruption associÃ©e.
</p>

<p>
VoilÃ  un exemple de code pour Raspberry PI, oÃ¹ des boutons sont connectÃ©s aux broches 17 et 18 et une LED est connectÃ©e Ã  la broche 4. Vous pouvez bien sÃ»r changer ces numÃ©ros pour qu'ils correspondent Ã  votre machine.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  intrpt.c - G&#195;&#168;re les GPIOs avec les interruptions</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Copyright (C) 2017 par Bob Mottram</span>
<span class="org-comment"> *  Bas&#195;&#169; sur l'exemple sur Raspberry Py de Stehan Wendler(devnull@kaltpost.de)</span>
<span class="org-comment"> *  de:</span>
<span class="org-comment"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Appuyez sur un boutton pour allumer une LED,</span>
<span class="org-comment"> *  et sur un autre pour l'&#195;&#169;teindre</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/gpio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">button_irqs</span>[] = { -1, -1 };

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;finit les GPIOs pour les LEDs.              *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span class="org-string">"LED 1"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;finit les GPIOs pour les boutons.           *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">buttons</span>[] = {
        { 17, GPIOF_IN, <span class="org-string">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span class="org-string">"LED 1 OFF BUTTON"</span> }
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction d'interruption qui sera appel&#195;&#169;e quand un bouton sera press&#195;&#169;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">irqreturn_t</span> <span class="org-function-name">button_isr</span>(<span class="org-type">int</span> <span class="org-variable-name">irq</span>, <span class="org-type">void</span> *<span class="org-variable-name">data</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Premier bouton </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (irq == button_irqs[0] &amp;&amp; <span class="org-negation-char">!</span>gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Second bouton </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">else</span> <span class="org-keyword">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span class="org-keyword">return</span> IRQ_HANDLED;
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Les registres correspondant aux broches associ&#195;&#169;es aux LEDs </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Les registres correspondant aux broches associ&#195;&#169;es aux bouttons </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail1</span>;
    }

    pr_info(<span class="org-string">"Current button1 value: %d\n"</span>,
           gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
           button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button1"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
           button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button2"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail3</span>;
    }

    <span class="org-keyword">return</span> 0;

<span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoie ce qui a d&#195;&#169;j&#195;  &#195;&#169;t&#195;&#169; fait en cas d'&#195;&#169;chec </span><span class="org-comment-delimiter">*/</span>
<span class="org-constant">fail3</span>:
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);

<span class="org-constant">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span class="org-constant">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">return</span> ret;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lib&#195;&#168;re les interruptions </span><span class="org-comment-delimiter">*/</span>
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);
    free_irq(button_irqs[1], <span class="org-constant">NULL</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Eteint les LEDs </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Suppression </span><span class="org-comment-delimiter">*/</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Handle some GPIO interrupts"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">Partie immergÃ©e d'une interruption</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Supposez maintenant que vous devez faire beaucoup de choses au sein de votre gestionnaire d'interruption. La maniÃ¨re la plus simple de procÃ©der ainsi sans dÃ©sactiver les interruptions pour un long dÃ©lai est de combiner ce gestionnaire avec le mÃ©canisme de tasklet. Ainsi, le gros de travail est dÃ©portÃ© vers l'ordonnanceur.
</p>

<p>
L'exemple plus bas modifie l'exemple prÃ©cÃ©dent pour lancer une tÃ¢che additionnelle quand une interruption est levÃ©e.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * bottomhalf.c - Gestion d'interruption utilisant la partie immerg&#195;&#169;e</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Copyright (C) 2017 par Bob Mottram</span>
<span class="org-comment"> *  Bas&#195;&#169; sur l'exemple pour rasp de Stefan Wendler (devnull@kaltpost.de)</span>
<span class="org-comment"> *  disponible ici :</span>
<span class="org-comment"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Appuyez sur un bouton pour allumer une LED,</span>
<span class="org-comment"> *  et sur un autre pour l'&#195;&#169;teindre</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/gpio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">button_irqs</span>[] = { -1, -1 };

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;finit les GPIOs pour les LEDs.              *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span class="org-string">"LED 1"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#195;&#169;finit les GPIOs pour les boutons.           *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">buttons</span>[] = {
        { 17, GPIOF_IN, <span class="org-string">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span class="org-string">"LED 1 OFF BUTTON"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">Tasklet qui contient du code long &#195;  s'ex&#195;&#169;cuter </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">bottomhalf_tasklet_fn</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">data</span>)
{
    pr_info(<span class="org-string">"Bottom half tasklet starts\n"</span>);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous pouvez ins&#195;&#169;rer du code lourd &#195;  ex&#195;&#169;cuter </span><span class="org-comment-delimiter">*/</span>
    mdelay(500);
    pr_info(<span class="org-string">"Bottom half tasklet ends\n"</span>);
}

<span class="org-function-name">DECLARE_TASKLET</span>(buttontask, bottomhalf_tasklet_fn, 0L);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction d'interruption : D&#195;&#169;clench&#195;&#169;e quand un bouton est appuy&#195;&#169;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">irqreturn_t</span> <span class="org-function-name">button_isr</span>(<span class="org-type">int</span> <span class="org-variable-name">irq</span>, <span class="org-type">void</span> *<span class="org-variable-name">data</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous pouvez ins&#195;&#169;rer du code rapide &#195;  ex&#195;&#169;cuter </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (irq == button_irqs[0] &amp;&amp; <span class="org-negation-char">!</span>gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span class="org-keyword">else</span> <span class="org-keyword">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Chargez maintenant le reste    *</span>
<span class="org-comment">     * (la partie la plus &#195;&#169;nergivore) *</span>
<span class="org-comment">     * de la t&#195;&#162;che &#195;  ex&#195;&#169;cuter         </span><span class="org-comment-delimiter">*/</span>
    tasklet_schedule(&amp;buttontask);

    <span class="org-keyword">return</span> IRQ_HANDLED;
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Enregistrement des broches li&#195;&#169;es aux LEDs </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Enregistrement des broches li&#195;&#169;es aux boutons </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail1</span>;
    }

    pr_info(<span class="org-string">"Current button1 value: %d\n"</span>,
           gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
           button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button1"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
           button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button2"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail3</span>;
    }

    <span class="org-keyword">return</span> 0;

<span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoyage de ce qui a &#195;&#169;t&#195;&#169; ex&#195;&#169;cut&#195;&#169;, en cas d'&#195;&#169;chec </span><span class="org-comment-delimiter">*/</span>
<span class="org-constant">fail3</span>:
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);

<span class="org-constant">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span class="org-constant">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">return</span> ret;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lib&#195;&#169;ration des interruptions </span><span class="org-comment-delimiter">*/</span>
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);
    free_irq(button_irqs[1], <span class="org-constant">NULL</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Extinction des LEDs </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Suppression </span><span class="org-comment-delimiter">*/</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Interrupt with top and bottom half"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Cryptage</h2>
<div class="outline-text-2" id="text-16">
<p>
Ã€ l'aube de l'internet, le monde Ã©tait bienveillant&#x2026; mais tout ne s'est pas passÃ© comme prÃ©vu. Quand la premiÃ¨re version de ce guide a Ã©tÃ© Ã©crite, le monde de l'informatique Ã©tait bien plus innocent et tout le monde se fichait du cryptage - en tout cas c'Ã©tait le cas des dÃ©veloppeurs noyau. C'est n'est plus le cas de nos jours. Pour gÃ©rer le cryptage, le noyau a sa propre API qui fournit des mÃ©thodes de cryptage, de dÃ©cryptage, et votre fonction de hachage prÃ©fÃ©rÃ©e.
</p>
</div>

<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1">Fonction de hachage</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Le hachage d'une information et sa vÃ©rification sont des opÃ©rations communes. VoilÃ  en exemple pour hacher une donnÃ©e avec l'algorithme sha256 au sein d'un module noyau :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;crypto/internal/hash.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SHA256_LENGTH</span> (256/8)

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">show_hash_result</span>(<span class="org-type">char</span> * <span class="org-variable-name">plaintext</span>, <span class="org-type">char</span> * <span class="org-variable-name">hash_sha256</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">str</span>[SHA256_LENGTH*2 + 1];

    pr_info(<span class="org-string">"sha256 test for string: \"%s\"\n"</span>, plaintext);
    <span class="org-keyword">for</span> (i = 0; i &lt; SHA256_LENGTH ; i++)
        sprintf(&amp;str[i*2],<span class="org-string">"%02x"</span>, (<span class="org-type">unsigned</span> <span class="org-type">char</span>)hash_sha256[i]);
    str[i*2] = 0;
    pr_info(<span class="org-string">"%s\n"</span>, str);
}

<span class="org-type">int</span> <span class="org-function-name">cryptosha256_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">char</span> * <span class="org-variable-name">plaintext</span> = <span class="org-string">"This is a test"</span>;
    <span class="org-type">char</span> <span class="org-variable-name">hash_sha256</span>[SHA256_LENGTH];
    <span class="org-keyword">struct</span> <span class="org-type">crypto_shash</span> *<span class="org-variable-name">sha256</span>;
    <span class="org-keyword">struct</span> <span class="org-type">shash_desc</span> *<span class="org-variable-name">shash</span>;

    sha256 = crypto_alloc_shash(<span class="org-string">"sha256"</span>, 0, 0);
    <span class="org-keyword">if</span> (IS_ERR(sha256))
        <span class="org-keyword">return</span> -1;

    shash =
        kmalloc(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">shash_desc</span>) + crypto_shash_descsize(sha256),
                GFP_KERNEL);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>shash)
        <span class="org-keyword">return</span> -ENOMEM;

    shash-&gt;tfm = sha256;
    shash-&gt;flags = 0;

    <span class="org-keyword">if</span> (crypto_shash_init(shash))
        <span class="org-keyword">return</span> -1;

    <span class="org-keyword">if</span> (crypto_shash_update(shash, plaintext, strlen(plaintext)))
        <span class="org-keyword">return</span> -1;

    <span class="org-keyword">if</span> (crypto_shash_final(shash, hash_sha256))
        <span class="org-keyword">return</span> -1;

    kfree(shash);
    crypto_free_shash(sha256);

    show_hash_result(plaintext, hash_sha256);

    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cryptosha256_exit</span>(<span class="org-type">void</span>)
{
}

<span class="org-function-name">module_init</span>(cryptosha256_init);
<span class="org-function-name">module_exit</span>(cryptosha256_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"sha256 hash test"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Pour crÃ©er et installer le module :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
sudo insmod cryptosha256.ko
dmesg
</pre>
</div>

<p>
Vous devriez vous apercevoir que la chaÃ®ne de caractÃ¨re a Ã©tÃ© hachÃ©e.
</p>

<p>
Finalement, enlevez le module :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod cryptosha256
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2">Cryptage par clÃ© symÃ©trique</h3>
<div class="outline-text-3" id="text-16-2">
<p>
Voici un exemple de cryptage de clÃ© symÃ©trique d'une chaÃ®ne de caractÃ¨res en utilisant l'algorithme AES et une clÃ© secrÃ¨te associÃ©e.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;crypto/internal/skcipher.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/crypto.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SYMMETRIC_KEY_LENGTH</span> 32
<span class="org-preprocessor">#define</span> <span class="org-variable-name">CIPHER_BLOCK_SIZE</span>    16

<span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> {
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">completion</span>;
    <span class="org-type">int</span> <span class="org-variable-name">err</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> {
    <span class="org-keyword">struct</span> <span class="org-type">scatterlist</span> <span class="org-variable-name">sg</span>;
    <span class="org-keyword">struct</span> <span class="org-type">crypto_skcipher</span> * <span class="org-variable-name">tfm</span>;
    <span class="org-keyword">struct</span> <span class="org-type">skcipher_request</span> * <span class="org-variable-name">req</span>;
    <span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> <span class="org-variable-name">result</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">scratchpad</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">ciphertext</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">ivdata</span>;
};

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> <span class="org-variable-name">sk</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test_skcipher_finish</span>(<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>)
{
    <span class="org-keyword">if</span> (sk-&gt;tfm)
        crypto_free_skcipher(sk-&gt;tfm);
    <span class="org-keyword">if</span> (sk-&gt;req)
        skcipher_request_free(sk-&gt;req);
    <span class="org-keyword">if</span> (sk-&gt;ivdata)
        kfree(sk-&gt;ivdata);
    <span class="org-keyword">if</span> (sk-&gt;scratchpad)
        kfree(sk-&gt;scratchpad);
    <span class="org-keyword">if</span> (sk-&gt;ciphertext)
        kfree(sk-&gt;ciphertext);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">test_skcipher_result</span>(<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>, <span class="org-type">int</span> <span class="org-variable-name">rc</span>)
{
    <span class="org-keyword">switch</span> (rc) {
    <span class="org-keyword">case</span> 0:
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> -EINPROGRESS:
    <span class="org-keyword">case</span> -EBUSY:
        rc = wait_for_completion_interruptible(
            &amp;sk-&gt;result.completion);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>rc &amp;&amp; <span class="org-negation-char">!</span>sk-&gt;result.err) {
            reinit_completion(&amp;sk-&gt;result.completion);
            <span class="org-keyword">break</span>;
        }
    <span class="org-keyword">default</span>:
        pr_info(<span class="org-string">"skcipher encrypt returned with %d result %d\n"</span>,
            rc, sk-&gt;result.err);
        <span class="org-keyword">break</span>;
    }

    init_completion(&amp;sk-&gt;result.completion);

    <span class="org-keyword">return</span> rc;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test_skcipher_callback</span>(<span class="org-keyword">struct</span> <span class="org-type">crypto_async_request</span> *<span class="org-variable-name">req</span>, <span class="org-type">int</span> <span class="org-variable-name">error</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> *<span class="org-variable-name">result</span> = req-&gt;data;
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    <span class="org-keyword">if</span> (error == -EINPROGRESS)
        <span class="org-keyword">return</span>;

    result-&gt;err = error;
    complete(&amp;result-&gt;completion);
    pr_info(<span class="org-string">"Encryption finished successfully\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">test_skcipher_encrypt</span>(<span class="org-type">char</span> * <span class="org-variable-name">plaintext</span>, <span class="org-type">char</span> * <span class="org-variable-name">password</span>,
                                 <span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = -EFAULT;
    <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">key</span>[SYMMETRIC_KEY_LENGTH];

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;tfm) {
        sk-&gt;tfm = crypto_alloc_skcipher(<span class="org-string">"cbc-aes-aesni"</span>, 0, 0);
        <span class="org-keyword">if</span> (IS_ERR(sk-&gt;tfm)) {
            pr_info(<span class="org-string">"could not allocate skcipher handle\n"</span>);
            <span class="org-keyword">return</span> PTR_ERR(sk-&gt;tfm);
        }
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;req) {
        sk-&gt;req = skcipher_request_alloc(sk-&gt;tfm, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;req) {
            pr_info(<span class="org-string">"could not allocate skcipher request\n"</span>);
            ret = -ENOMEM;
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
    }

    skcipher_request_set_callback(sk-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
                                  test_skcipher_callback,
                                  &amp;sk-&gt;result);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoyez la cl&#195;&#169;s </span><span class="org-comment-delimiter">*/</span>
    memset((<span class="org-type">void</span>*)key,<span class="org-string">'\0'</span>,SYMMETRIC_KEY_LENGTH);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Utilisez le meilleur mot de passe du monde </span><span class="org-comment-delimiter">*/</span>
    sprintf((<span class="org-type">char</span>*)key,<span class="org-string">"%s"</span>,password);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Cryptage AES 256 par cl&#195;&#169;s sym&#195;&#169;triques </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (crypto_skcipher_setkey(sk-&gt;tfm, key, SYMMETRIC_KEY_LENGTH)) {
        pr_info(<span class="org-string">"key could not be set\n"</span>);
        ret = -EAGAIN;
        <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
    }
    pr_info(<span class="org-string">"Symmetric key: %s\n"</span>, key);
    pr_info(<span class="org-string">"Plaintext: %s\n"</span>, plaintext);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;ivdata) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Voyez https://fr.wikipedia.org/wiki/Vecteur_d%27initialisation </span><span class="org-comment-delimiter">*/</span>
        sk-&gt;ivdata = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;ivdata) {
            pr_info(<span class="org-string">"could not allocate ivdata\n"</span>);
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
        get_random_bytes(sk-&gt;ivdata, CIPHER_BLOCK_SIZE);
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;scratchpad) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Le texte que vous souhaitez crypter </span><span class="org-comment-delimiter">*/</span>
        sk-&gt;scratchpad = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;scratchpad) {
            pr_info(<span class="org-string">"could not allocate scratchpad\n"</span>);
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
    }
    sprintf((<span class="org-type">char</span>*)sk-&gt;scratchpad,<span class="org-string">"%s"</span>,plaintext);

    sg_init_one(&amp;sk-&gt;sg, sk-&gt;scratchpad, CIPHER_BLOCK_SIZE);
    skcipher_request_set_crypt(sk-&gt;req, &amp;sk-&gt;sg, &amp;sk-&gt;sg,
                               CIPHER_BLOCK_SIZE, sk-&gt;ivdata);
    init_completion(&amp;sk-&gt;result.completion);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Cryptage </span><span class="org-comment-delimiter">*/</span>
    ret = crypto_skcipher_encrypt(sk-&gt;req);
    ret = test_skcipher_result(sk, ret);
    <span class="org-keyword">if</span> (ret)
        <span class="org-keyword">goto</span> <span class="org-constant">out</span>;

    pr_info(<span class="org-string">"Encryption request successful\n"</span>);

<span class="org-constant">out</span>:
    <span class="org-keyword">return</span> ret;
}

<span class="org-type">int</span> <span class="org-function-name">cryptoapi_init</span>(<span class="org-type">void</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le meilleur mot de passe du monde </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">char</span> * <span class="org-variable-name">password</span> = <span class="org-string">"password123"</span>;

    sk.tfm = <span class="org-constant">NULL</span>;
    sk.req = <span class="org-constant">NULL</span>;
    sk.scratchpad = <span class="org-constant">NULL</span>;
    sk.ciphertext = <span class="org-constant">NULL</span>;
    sk.ivdata = <span class="org-constant">NULL</span>;

    test_skcipher_encrypt(<span class="org-string">"Testing"</span>, password, &amp;sk);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cryptoapi_exit</span>(<span class="org-type">void</span>)
{
    test_skcipher_finish(&amp;sk);
}

<span class="org-function-name">module_init</span>(cryptoapi_init);
<span class="org-function-name">module_exit</span>(cryptoapi_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Symmetric key encryption example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">Standardisation des interfaces : Le modÃ¨le de pÃ©riphÃ©rique</h2>
<div class="outline-text-2" id="text-17">
<p>
Jusqu'ici, on a vu plusieurs sortes de modules qui faisaient toutes sortes de choses, mais leurs interfaces avec le reste du noyau Ã©taient limitÃ©es. L'idÃ©e est venue, pour imposer une interface standardisÃ©e (afin qu'il existe une maniÃ¨re normalisÃ©e de dÃ©marrer, suspendre et reprendre un pÃ©riphÃ©rique), de crÃ©er un modÃ¨le de pÃ©riphÃ©rique. C'est ce qui a Ã©tÃ© ajoutÃ© au sein du noyau. L'exemple suivant le montre, et vous pouvez utiliser ce modÃ¨le pour ajouter vos propres fonctions de pÃ©riphÃ©rique telle qu'une fonction d'arrÃªt, de redÃ©marrage, ou autre.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/platform_device.h&gt;</span>

<span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> {
    <span class="org-type">char</span> *<span class="org-variable-name">greeting</span>;
    <span class="org-type">int</span>   <span class="org-variable-name">number</span>;
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_probe</span>(<span class="org-keyword">struct</span> <span class="org-type">platform_device</span> *<span class="org-variable-name">dev</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> *<span class="org-variable-name">pd</span> = (<span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> *)(dev-&gt;dev.platform_data);

    pr_info(<span class="org-string">"devicemodel probe\n"</span>);
    pr_info(<span class="org-string">"devicemodel greeting: %s; %d\n"</span>, pd-&gt;greeting, pd-&gt;number);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code d'initialisation de votre p&#195;&#169;riph&#195;&#169;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_remove</span>(<span class="org-keyword">struct</span> <span class="org-type">platform_device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example removed\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de suppression de votre p&#195;&#169;riph&#195;&#169;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_suspend</span>(<span class="org-keyword">struct</span> <span class="org-type">device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example suspend\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de mise en veille de votre p&#195;&#169;riph&#195;&#169;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_resume</span>(<span class="org-keyword">struct</span> <span class="org-type">device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example resume\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de reprise en activit&#195;&#169; de votre p&#195;&#169;riph&#195;&#169;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">dev_pm_ops</span> <span class="org-variable-name">devicemodel_pm_ops</span> =
{
    .suspend = devicemodel_suspend,
    .resume = devicemodel_resume,
    .poweroff = devicemodel_suspend,
    .freeze = devicemodel_suspend,
    .thaw = devicemodel_resume,
    .restore = devicemodel_resume
};

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">platform_driver</span> <span class="org-variable-name">devicemodel_driver</span> = {
    .driver     = {
        .name   = <span class="org-string">"devicemodel_example"</span>,
        .owner  = THIS_MODULE,
        .pm     = &amp;devicemodel_pm_ops,
    },
    .probe      = devicemodel_probe,
    .remove     = devicemodel_remove,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    pr_info(<span class="org-string">"devicemodel init\n"</span>);

    ret = platform_driver_register(&amp;devicemodel_driver);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to register driver\n"</span>);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">devicemodel_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"devicemodel exit\n"</span>);
    platform_driver_unregister(&amp;devicemodel_driver);
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Linux Device Model example"</span>);

<span class="org-function-name">module_init</span>(devicemodel_init);
<span class="org-function-name">module_exit</span>(devicemodel_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">Optimisation</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">Conditions likely et unlikely</h3>
<div class="outline-text-3" id="text-18-1">
<p>
Vous souhaitez parfois que votre code tourne de la maniÃ¨re la plus rapide possible, spÃ©cialement si ce dernier concerne la gestion d'une interruption, ou tout autre chose qui peut prendre du temps lÃ  ou vous souhaitez l'Ã©viter. Si votre code contient des conditions boolÃ©ennes, et si vous savez que ces conditions auront presque toujours la mÃªme valeur (que ce soit vraie <i>true</i> ou fausse <i>false</i>), alors vous pouvez optimiser votre code en utilisant les macros <i>likely</i> (pour une condition qui sera souvent vraie) ou <i>unlikely</i> (pour une condition qui sera souvent fausse).
</p>

<p>
Par exemple, l'allocation de mÃ©moire va statistiquement le plus souvent  rÃ©ussir.
</p>

<div class="org-src-container">

<pre class="src src-C">bvl = bvec_alloc(gfp_mask, nr_iovecs, &amp;idx);
<span class="org-keyword">if</span> (unlikely(<span class="org-negation-char">!</span>bvl)) {
  mempool_free(bio, bio_pool);
  bio = <span class="org-constant">NULL</span>;
  <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
}
</pre>
</div>

<p>
Quand la macro <i>unlikely</i> est utilisÃ©e, alors le compilateur modifie les instructions qui y sont liÃ©es de sorte qu'il Ã©vite un saut au sein du code coÃ»teux en ressource, saut qui ne sera effectuÃ© que si la condition est vraie. Ceci Ã©vite de vider le pipeline de votre processeur, et Ã§a vous Ã©vitera donc de nombreux cycles durant lesquels votre processeur sera bloquÃ©. L'exact opposÃ© arrive si vous utilisez la macro <i>likely</i>.
</p>

<p>
Attention cependant. Cette manoeuvre doit Ãªtre utilisÃ©e dans les conditions dont vous Ãªtes presque toujours sur du rÃ©sultat. C'est une mauvaise idÃ©e de trop l'utiliser sur les conditions de vÃ©rification d'erreurs et donc d'en tirer des conclusions hÃ¢tives sur votre code. Il ne faudrait pas confondre prÃ©diction et espoir, puisque vous prÃ©voyez rarement quand les erreurs vont arriver.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">PiÃ¨ges rÃ©currents</h2>
<div class="outline-text-2" id="text-19">
<p>
La messe n'est pas dite. Avant de vous renvoyer dans le monde Ã©crire des modules noyau, vous devez Ãªtre prÃ©venu de certaines choses. Si je ne vous ai pas assez prÃ©venu et qu'une chose mauvaise vous arrive, merci de signaler le problÃ¨me, et je vous rembourserai le montant que j'ai touchÃ© pour votre copie papier de ce guide.
</p>
</div>

<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">Utilisation de bibliothÃ¨ques standards.</h3>
<div class="outline-text-3" id="text-19-1">
<p>
Vous ne pouvez pas les utiliser, et si vous le faites vous Ãªtes passible du bÃ»cher. Ces bibliothÃ¨ques sont rÃ©servÃ©es au code utilisateur et vous n'avez le droit de n'utiliser que des fonctions noyau, qui sont les fonctions dont vous pouvez apercevoir les symboles dans le fichier /proc/kallsyms.
</p>
</div>
</div>

<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">DÃ©sactiver les interruptions</h3>
<div class="outline-text-3" id="text-19-2">
<p>
Vous devrez parfois dÃ©sactiver toutes les interruptions pour une trÃ¨s courte pÃ©riode, et Ã§a ne pose pas de problÃ¨me, mais si vous ne les rÃ©activez pas ensuite, votre systÃ¨me sera embourbÃ© et vous serez contraint de l'Ã©teindre Ã  la maniÃ¨re d'un barbare.
</p>
</div>
</div>

<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">Ne vous jetez pas dans la gueule du loup</h3>
<div class="outline-text-3" id="text-19-3">
<p>
Je n'ai probablement pas besoin de vous prÃ©venir pour Ã§a, mais je vais quand mÃªme le faire, juste au cas oÃ¹&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">Que faire ensuite ?</h2>
<div class="outline-text-2" id="text-20">
<p>
J'aurais facilement pu rajouter plusieurs chapitres Ã  ce livre. Il y a tant Ã  dire ! J'aurais pu ajouter un chapitre sur l'ajout de nouveau systÃ¨mes de fichiers, ou l'ajout d'un nouveau protocole de communication rÃ©seau (comme si vous en aurez un jour besoin &#x2013; vous risquez de chercher longtemps pour trouver un protocole rÃ©seau qui n'est pas encore gÃ©rÃ© par Linux). J'aurais pu ajouter des explications sur les mÃ©canismes du noyau qu'on a pas traitÃ©s, tel que le dÃ©marrage du systÃ¨me, ou l'interface disque/systÃ¨me.
</p>

<p>
J'ai pourtant choisi de ne pas le faire. Mon but en Ã©crivant ce livre Ã©tait de fournir au lecteur une premiÃ¨re initiation aux mystÃ¨res de la programmation de module noyau pour Linux, et Ã  ce but d'enseigner les techniques Ã©lÃ©mentaires de dÃ©veloppement noyau. Mais pour les lecteurs qui restent sur leur faim et qui sont intÃ©ressÃ©s pour en apprendre davantage, je conseille <a href="https://kernelnewbies.org">kernelnewbies.org</a> et le rÃ©pertoire <i>Documentation</i> au sein du code source du noyau, qui n'est pas toujours trÃ¨s clair, mais qui est un excellent point de dÃ©part pour en apprendre plus. De plus, comme l'a dit Linus Torvalds, la meilleure maniÃ¨re d'en apprendre plus sur le noyau reste de lire le code source.
</p>

<p>
Si vous Ãªtes intÃ©ressÃ© par plus d'exemples de modules noyau, alors je vous conseille de chercher du contenu de sites comme Github, Bitbucket ou Gitlab, dont les contenus sont trÃ¨s bien rÃ©fÃ©rencÃ©s (mais vous pouvez tomber sur tout et n'importe quoi, comme de vieilles versions de ce guide qui ne compileront plus sur des versions Ã  jour du noyau). Vous trouverez Ã©galement des exemples trÃ¨s instructifs sur l'utilisation de modules pour attaquer, compromettre un systÃ¨me, ou encore en tirer des donnÃ©es normalement privÃ©es. La meilleure maniÃ¨re de savoir dÃ©fendre un systÃ¨me, c'est en connaissant ses points faibles, c'est pourquoi je vous conseille la lecture de tels dÃ©pots.
</p>

<p>
J'espÃ¨re vraiment vous avoir aidÃ© dans votre quÃªte pour devenir un meilleur dÃ©veloppeur, ou au moins pour vous amuser ou en apprendre plus sur cette technologie. Si vous souhaitez Ã©crire des modules utiles et intÃ©ressants pour le noyau, j'espÃ¨re que vous le ferez sous une licence libre, afin que je puisse m'en servir ou m'en inspirer.
</p>

<p>
Si vous souhaitez contribuer Ã  ce guide, reporter une chose erronÃ©e, ou si vous souhaitez ajouter des commentaires acerbes ou sardoniques, par exemple en rajoutant des remarques Ã©voquant des singes ou d'autres animaux dans des situations inÃ©narrables, dÃ©posez alors une disputation, ou mieux, proposez une pull request sur le dÃ©pÃ´t git de ce projet : <a href="https://bitbucket.org/s_burel/lkmpg_fr">https://bitbucket.org/s_burel/lkmpg_fr</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

<style type="text/css">
.back-to-top {
    position: fixed;
    bottom: 2em;
    right: 0px;
    text-decoration: none;
    color: #000000;
    background-color: rgba(235, 235, 235, 0.80);
    font-size: 12px;
    padding: 1em;
    display: none;
}

.back-to-top:hover {
    background-color: rgba(135, 135, 135, 0.50);
}
</style>

<div class="back-to-top">
<a href="#top">Back to top</a> | <a href="mailto:bob@freedombone.net">E-mail me</a>
</div>
</div>
</body>
</html>
