<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Le guide de survie à la programmation en noyau Linux</title>
<!-- 2018-09-13 Thu 18:13 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Burel Stéphane" />
<meta  name="description" content="Comment créer des modules noyau pour Linux"
 />
<meta  name="keywords" content="linux, kernel, kernel module, kernel programming, noyau, module noyau, programmation noyau linux, développement noyau linux" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/foundation.min.css"></link>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/org-export.css"></link>
<link rel="stylesheet" type="text/css" href="https://freedombone.net/css/style.css"></link>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<a name="top" id="top"></a>
</div>
<div id="content">
<h1 class="title">Le guide de survie à la programmation en noyau Linux</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a>
<ul>
<li><a href="#sec-1-1">Paternité</a></li>
<li><a href="#sec-1-2">Versions et Notes</a></li>
<li><a href="#sec-1-3">Remerciements</a></li>
<li><a href="#sec-1-4">Qu'est ce qu'un module noyau ?</a></li>
<li><a href="#sec-1-5">Paquet de module noyau</a></li>
<li><a href="#sec-1-6">Quels modules sont présents dans mon noyau ?</a></li>
<li><a href="#sec-1-7">Ai-je besoin de télécharger et de compiler le noyau linux ?</a></li>
<li><a href="#sec-1-8">Avant de commencer</a></li>
</ul>
</li>
<li><a href="#sec-2">En-tête</a></li>
<li><a href="#sec-3">Exemples</a></li>
<li><a href="#sec-4">Hello World</a>
<ul>
<li><a href="#sec-4-1">Votre tout premier module</a></li>
<li><a href="#sec-4-2">Salut et Au revoir</a></li>
<li><a href="#sec-4-3">Les macros __init et __exit</a></li>
<li><a href="#sec-4-4">Licences et Documentation du Module</a></li>
<li><a href="#sec-4-5">Passer un argument à votre module</a></li>
<li><a href="#sec-4-6">Créer un module depuis plusieurs fichiers</a></li>
<li><a href="#sec-4-7">Créer des modules pour un noyau précompilé</a></li>
</ul>
</li>
<li><a href="#sec-5">Avant-propos</a>
<ul>
<li><a href="#sec-5-1">Où la vie d'un module commence et où elle se termine</a></li>
<li><a href="#sec-5-2">Fonctions disponibles pour votre module</a></li>
<li><a href="#sec-5-3">Mode utilisateur, mode noyau</a></li>
<li><a href="#sec-5-4">Convention de nommage</a></li>
<li><a href="#sec-5-5">Espace de code</a></li>
<li><a href="#sec-5-6">Les pilotes de périphériques</a></li>
</ul>
</li>
<li><a href="#sec-6">Pilote de périphérique en mode caractère</a>
<ul>
<li><a href="#sec-6-1">La structure `file_operations`</a></li>
<li><a href="#sec-6-2">La structure `file`</a></li>
<li><a href="#sec-6-3">Enregistrer un périphérique</a></li>
<li><a href="#sec-6-4">Supprimer un périphérique</a></li>
<li><a href="#sec-6-5">chardev.c</a></li>
<li><a href="#sec-6-6">Ecrire des modules pour plusieurs versions du noyau.</a></li>
</ul>
</li>
<li><a href="#sec-7">Le système de fichier /proc</a>
<ul>
<li><a href="#sec-7-1">Lire et écrire un fichier /proc</a></li>
<li><a href="#sec-7-2">Gérer un fichier /proc avec un système de fichier standard</a></li>
<li><a href="#sec-7-3">Gérer un fichier /proc avec seq_file</a></li>
</ul>
</li>
<li><a href="#sec-8">sysfs : Interagissez avec votre module</a></li>
<li><a href="#sec-9">Interagir avec un fichier de périphérique</a></li>
<li><a href="#sec-10">Les appels système</a></li>
<li><a href="#sec-11">Processus bloquants et threads</a>
<ul>
<li><a href="#sec-11-1">Sleep</a></li>
<li><a href="#sec-11-2">Achèvements</a></li>
</ul>
</li>
<li><a href="#sec-12">Eviter les collisions et les interblocages</a>
<ul>
<li><a href="#sec-12-1">Mutex</a></li>
<li><a href="#sec-12-2">Verrou tournant</a></li>
<li><a href="#sec-12-3">Verrou lecture/écriture</a></li>
<li><a href="#sec-12-4">Opérations atomiques</a></li>
</ul>
</li>
<li><a href="#sec-13">Remplacer les macros Print</a>
<ul>
<li><a href="#sec-13-1">Remplacement</a></li>
<li><a href="#sec-13-2">Faire clignoter les LEDS du clavier</a></li>
</ul>
</li>
<li><a href="#sec-14">Tâches ordonnancées</a>
<ul>
<li><a href="#sec-14-1">Tasklets</a></li>
<li><a href="#sec-14-2">Files de travaux</a></li>
</ul>
</li>
<li><a href="#sec-15">Gestionnaire d'interruptions</a>
<ul>
<li><a href="#sec-15-1">Gestionnaire d'interruptions</a></li>
<li><a href="#sec-15-2">Détection de pression de bouton</a></li>
<li><a href="#sec-15-3">Partie immergée d'une interruption</a></li>
</ul>
</li>
<li><a href="#sec-16">Cryptage</a>
<ul>
<li><a href="#sec-16-1">Fonction de hachage</a></li>
<li><a href="#sec-16-2">Cryptage par clé symétrique</a></li>
</ul>
</li>
<li><a href="#sec-17">Standardisation des interfaces : Le modèle de périphérique</a></li>
<li><a href="#sec-18">Optimisation</a>
<ul>
<li><a href="#sec-18-1">Conditions likely et unlikely</a></li>
</ul>
</li>
<li><a href="#sec-19">Pièges récurrents</a>
<ul>
<li><a href="#sec-19-1">Utilisation de bibliothèques standards.</a></li>
<li><a href="#sec-19-2">Désactiver les interruptions</a></li>
<li><a href="#sec-19-3">Ne vous jetez pas dans la gueule du loup</a></li>
</ul>
</li>
<li><a href="#sec-20">Que faire ensuite ?</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Le guide de survie à la programmation en noyau Linux est un livre libre. Vous pouvez le reproduire et le modifier sous respect de l'Open Software License, version 3.0.
</p>

<p>
Cet ouvrage est distribué avec l'espoir qu'il vous sera utile, mais aucune financière ni d'utilisation.
</p>

<p>
Les auteurs encouragent la distribution sans condition de cet ouvrage pour un usage personnel, ou même à fin commerciale, à condition que toute l'information concernant les droits d'auteur et autres droits d'exclusivité soient respectés et que la licence utilisée reste compatible avec les descriptions de la licence Open Software License. En résumé, vous pouvez copier cet ouvrage, le distribuer à des fins non lucratives ou commerciales. Aucune permission explicite n'est requise de l'auteur pour la reproduction de cet ouvrage quelqu'en soit le format, papier ou électronique tant que vous respectez sa licence.
</p>

<p>
Tout travail ou traduction à partir de ce document doit être placé sous une licence compatible avec les descriptions de la licence Open Software License, et les droits d'exclusivité du document original doivent être préservés dans le document final. Si vous avez contribué à améliorer ce document, vous devez rendre votre travail disponible et ouvert pour une mise à jour. Merci de rendre vos travaux, traductions et mises à jours à disposition du gestionnaire de ce document, Peter Jay Salzman \&lt;p@dirac.org\&gt;. Ceci permettra de fusionner vos travaux avec la version originale, afin de toujours fournir à la communauté Linux une version mise à jour.
</p>

<p>
Si vous publiez cet ouvrage à des fins commerciales, des dons, des droits d'auteur et des copies physiques seront grandement appréciées par les auteurs et le [Linux Documentation Project](<a href="http://www.tldp.org">http://www.tldp.org</a>) (LDP). Contribuer de cette sorte démontre votre soutien au logiciel libre et au LDP. Si vous avez des questions ou des commentaires, merci de contacter (en anglais) l'adresse décrite plus-haut.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Paternité</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Le guide de survie à la programmation en noyau Linux a été à l'origine écrit pour le noyau dans sa version 2.2 par Ori Pomerantz. Mais à terme, Ori n'a plus eu le temps pour maintenir ce document à jour. Après tout, le noyau Linux est un logiciel très volatile. Peter Jay Salzman prit en main la mise à jour de ce document et l'a mis à jour pour la version 2.6. Finalement, Peter non plus n'a plus eu de temps à accorder à ce projet, alors Michael Burian est devenu un co-gestionnaire de ce document et l'a actualisé pour les verions 2.6. Bob Mottran a ensuite mis à jour les exemples pour les versions 3.8 et postérieures, puis a rajouté le chapitre sur les sysfs et mis à jour d'autre chapitres. Stéphane Burel a traduit les travaux de ces auteurs en français.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Versions et Notes</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Comme précisé plus haut, le noyau Linux est un logiciel très volatile. Depuis les origines du guide que vous lisez, et alors que les nouvelles versions de Linux défilaient, la question s'est toujours posée de savoir si telle ou telle information obsolète devait être enlevée ou si on devait la garder à titre historique. Michael Burian et Bob Mottran ont décidé de créer une nouvelle branche du guide pour chaque version stable. Ainsi la version du guide 4.15.x traitera du noyau 4.15.x et la version 2.6.x traitera du noyau 2.6. Le but de ce guide n'est donc pas de retenir des informations historiques. Un personne qui cherche une vieille information devra donc lire le guide dans la version qui lui convient.
</p>

<p>
Le code source fourni et les notes générales devraient contenter toutes les architectures et versions, mais je ne peux cependant pas vous l'assurer.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Remerciements</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Les personnes suivantes ont contribué aux corrections du présent document et leurs suggestions ont été utiles : Ignacio Martin, David Porter, Daniele Paolo Scarpazza, Dimo Velev, Francois Audeon, Horst Schirmeier, Bob Mottram et Roman Lakeev.
</p>

<p>
Merci également à Jacqueline Toulet pour sa relecture de la traduction française de ce document.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Qu'est ce qu'un module noyau ?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Vous souhaitez donc écrire un module noyau. Vous connaissez le C, vous avez créé quelques programmes que vous avez lancé en tant que simple processus, et vous souhaitez maintenant mettre les mains dans le cambouis, là ou un simple pointeur mal maîtrisé peut réduire à néant tout votre travail, et où un plantage de votre programme conduit au mieux au redémarrage de votre machine, au pire à la fin du monde.
</p>

<p>
Vous cherchez donc à créer un module noyau.
</p>

<p>
Un module noyau est un morceau code qui peut être chargé et déchargé du noyau à la demande. Il étend les services du noyau sans avoir besoin de redémarrer le système. Par exemple, les pilotes de périphériques forment une classe de modules qui permettent au noyau d'interagir avec les périphériques connectés au système. Sans les modules, il faudrait créer un noyau monolithique, d'un seul bloc, et insérer toutes les nouveautés directement dans l'image du noyau. Non seulement on aurait donc des noyaux bien plus gros, cette technique a aussi l'inconvénient de nécessiter une réinstallation et un redémarrage du noyau à chaque fois que l'on cherche une nouvelle fonctionnalité.
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Paquet de module noyau</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Les distributions Linux fournissent les commandes <b>modprobe</b>, <b>insmod</b> et <b>depmod</b> pour utiliser un paquet.
</p>

<p>
Sur Debian:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get install build-essential kmod
</pre>
</div>

<p>
Sur Parabola:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo pacman -S gcc kmod
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Quels modules sont présents dans mon noyau ?</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Vous pouvez savoir les modules qui sont actuellement chargés dans votre noyau en utilisant la commande <b>lsmod</b>.
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod
</pre>
</div>

<p>
La liste des modules sont stockés au sein du fichier /proc/modules, pouvez vous donc les voir avec la commande suivante :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo cat /proc/modules
</pre>
</div>

<p>
Cette liste pouvant être très longue, peut-être préférerez vous chercher un module particulier. Pour chercher le module <i>fat</i> :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep fat
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Ai-je besoin de télécharger et de compiler le noyau linux ?</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Pour suivre ce cours, ce n'est pas une nécessité. Mais ça reste conseillé de travailler sur une version de test qui tourne sur une machine virtuelle afin d'éviter de ruiner votre système et de tout perdre en cas de maladresse du lecteur. Les auteurs de ce guide ne sont pas tenus pour responsable dans un tel cas de figure.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Avant de commencer</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Avant de plonger dans le vif du sujet, je tiens à vous signaler qu'il existe tellement de versions différentes de Linux que vous pouvez rencontrez des problèmes qui ne sont pas signalées dans ce guide. Selon le cas, créer votre premier module "hello world", le compiler et l'insérer dans le noyau peut être la tâche la plus ardue de tout ce guide. Ce qui implique qu'une fois que vous aurez les pieds dans l'eau, ce qui suivra vous semblera plus simple. Ne désespérez jamais ! C'est la clé pour programmer dans le noyau Linux.
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-8-0-1" name="sec-1-8-0-1"></a>Version des Modules<br  /><div class="outline-text-5" id="text-1-8-0-1">
<p>
Un module compilé pour un noyau donné ne se chargera pas sur un noyau différent, à moins que vous activiez l'option CONFIG_MODVERSIONS dans ce dit noyau. Nous irons plus en profondeur dans ce concept plus tard dans ce guide. Jusqu'à ce que nous traitions le sujet, les exemples fournis peuvent ne pas marcher si vous utilisez un noyau avec cette option activée. Et la plupart des distributions Linux activent cette option par défaut. Si vous avez des problèmes en chargeant les modules en raison de la version de votre noyau, recompilez un noyau qui a désactivé cette option.
</p>
</div>
</li>

<li><a id="sec-1-8-0-2" name="sec-1-8-0-2"></a>Utilisation d'une console.<br  /><div class="outline-text-5" id="text-1-8-0-2">
<p>
Il vous est vivement recommandé de noter, compiler et charger tous les exemples présents dans ce guide. Et il est également recommandé de le faire à partir d'une console. Vous ne devriez pas utiliser d'environnement graphique.
</p>

<p>
Les modules ne peuvent pas afficher de message à l'écran à la manière d'un printf(), mais ils peuvent enregistrer des informations et des alertes, qui finiront affichés sur votre écran, mais dans le seul cas où vous utilisez une console. Si vous insérez un module depuis un terminal graphique, les informations et les alertes seront enregistrées, mais seulement dans votre journal systemd. Vous ne pourrez pas le lire à moins de regarder votre journal journalctl. Afin d'avoir directement, et en temps réel, accès à toutes ces informations, vous devriez travailler à partir d'une console.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">En-tête</h2>
<div class="outline-text-2" id="text-2">
<p>
Avant de pouvoir créer quoi que ce soit, vous aurez besoin d'installer les en-têtes de votre noyau.
</p>

<p>
Sur Parabola GNU/Linux:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo pacman -S linux-libre-headers
</pre>
</div>

<p>
Sur Debian:
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get update
apt-cache search linux-headers-$(<span class="org-sh-quoted-exec">uname</span> -r)
</pre>
</div>

<p>
Ceci vous dira quels fichiers d'en-tête sont disponibles. Par exemple :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo apt-get install kmod linux-headers-4.15.2-1-amd64
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Exemples</h2>
<div class="outline-text-2" id="text-3">
<p>
Tous les documents de ce guide sont disponibles dans le sous-répertoire <i>examples</i>. Pour essayer et pour compiler :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> examples
make
</pre>
</div>

<p>
Si vous avez des erreurs de compilation vous avez peut-être un noyau plus récent ou avez besoin d'installer les fichiers d'en-tête correspondants.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Hello World</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Votre tout premier module</h3>
<div class="outline-text-3" id="text-4-1">
<p>
La plupart des personnes qui commencent à programmer débutent avec un "<i>hello world</i>". Je ne sais pas quelles malédictions encourent celles et ceux qui brisent cette tradition, et j'ai trop peur de l'apprendre. Nous commencerons donc avec quelques exemples "<i>hello world</i>" qui vous montreront les différents aspects des bases nécessaire à l'écriture d'un module noyau.
</p>

<p>
Voici le module le plus simple.
</p>

<p>
Créez un répertoire d'essai :
</p>

<div class="org-src-container">

<pre class="src src-sh">mkdir -p ~/develop/kernel/hello-1
<span class="org-builtin">cd</span> ~/develop/kernel/hello-1
</pre>
</div>

<p>
Recopiez ceci au sein de votre éditeur et sauvegardez le sous <b>hello-1.c</b>:
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-1.c - Module noyau &#233;l&#233;mentaire.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello world 1.\n"</span>);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Un retour non nul signifie que init_module a &#233;chou&#233;. Dans ce cas,</span>
<span class="org-comment">     * le module ne peut pas &#234;tre charg&#233;.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye world 1.\n"</span>);
}
</pre>
</div>

<p>
Vous aurez maintenant besoin d'un Makefile. Si vous recopiez ceci, n'oubliez pas de changer les espaces en tabulations :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o

<span class="org-makefile-targets">all</span>:
        make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
        make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
Puis finalement :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
</pre>
</div>

<p>
Si tout se passe bien, vous devriez ensuite avoir un module compilé <b>hello-1.ko</b>. Vous pouvez lire les informations de ce module avec la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo modinfo hello-1.ko
</pre>
</div>

<p>
À ce moment, la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
Ne doit rien vous renvoyer. Vous pouvez essayer de charger votre module flambant-neuf avec :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo insmod hello-1.ko
</pre>
</div>

<p>
Le trait d'union sera converti en sous-tiret, donc si vous ressayer la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
Vous devriez maintenant voir votre module chargé. Il peut être enlevé avec la commande :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod hello_1
</pre>
</div>

<p>
Vous remarquez donc, comme précisé plus haut, que le trait d'union du nom de votre module a été remplacé par un sous-tiret. Pour voir ce qui s'est passé dans le journal :
</p>

<div class="org-src-container">

<pre class="src src-sh">journalctl --since <span class="org-string">"1 hour ago"</span> | grep kernel
</pre>
</div>

<p>
Vous connaissez maintenant la base de la création, de la compilation, de l'installation et la suppression de modules. Nous allons maintenant étudier comment fonctionne un module.
</p>

<p>
Les modules noyau doivent contenir au moins deux fonctions : une fonction de départ (ou d'initialisation) appelée <b>init_module()</b> qui est appelée par la commande insmod, et une fonction de fin (ou de nettoyage) appelée <b>cleanup_module()</b> qui est appelée par la commande rmmod. Une nouveauté apportée par la version 2.3.13 du noyau vous permet d'utiliser maintenant les noms que vous souhaitez pour vos fonctions de départ et de fin. On étudiera cette option dans la rubrique 2.3. De fait, la nouvelle méthode doit être préférée, mais vous pouvez rencontrer quelques irréductibles traditionalistes qui préfèrent encore travailler à l'ancienne et utiliser les fonctions init_module() et cleanup_module() pour leurs fonctions de départ et de fin.
</p>

<p>
Généralement, la fonction de départ met en place une fonction gestionnaire pour une fonctionnalité du noyau, ou alors remplace l'une des fonctions du noyau avec le code de votre module (dans quel cas, le module exécute habituellement son code avant d'appeler le code originel). Et la fonction de nettoyage quant à elle est censée défaire tous les changements apportés la fonction de départ, afin de pouvoir décharger le module de manière propre et sécurisée.
</p>

<p>
Enfin, chaque module du noyau doit maintenant inclure le fichier linux/module.h. On a besoin d'inclure également le fichier <b>linux/kernel.h</b> pour avoir accès à la macro pr_alert() de journalisation, fonction que l'on traitera dans la rubrique 2.1.1.
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-1-0-1" name="sec-4-1-0-1"></a>Note à propos du style de code<br  /><div class="outline-text-5" id="text-4-1-0-1">
<p>
Un autre point qu'il faut préciser à quiconque commence avec la programmation au cœur du noyau linux, c'est qu'il faut respecter les conventions de codes du noyau. À ce titre, vous devez utiliser comme indentation des tabulations, et non pas des espaces. C'est l'une des nombreuses conventions du noyau, et vous devez respecter ces conventions du noyau si vous voulez soumettre publiquement votre code.
</p>
</div>
</li>

<li><a id="sec-4-1-0-2" name="sec-4-1-0-2"></a>Introduction aux macros de notations<br  /><div class="outline-text-5" id="text-4-1-0-2">
<p>
Au commencement, ce guide comprenait des fonctions <b>printk</b>, normalement suivies d'une priorité telle que KERN_INFO ou KERN_DEBUG. Mais ces expressions peuvent maintenant être abrégées grâce à l'usage de macros telles que <b>pr_info</b> ou <b>pr_debug</b>. Ces macros servent juste à simplifier votre code et à éviter l'oubli de priorité. Elles peuvent être trouvées au sein du fichier <b>linux/printk.h</b>. Prenez le temps de lire ces définitions, afin de voir toutes les priorités disponibles.
</p>
</div>
</li>

<li><a id="sec-4-1-0-3" name="sec-4-1-0-3"></a>À propos de la compilation<br  /><div class="outline-text-5" id="text-4-1-0-3">
<p>
Les modules noyau doivent être compilés d'une manière légèrement différente d'un programme utilisateur standard. Les premières versions du noyau exigeaient de nous un soin particulier vis-à-vis des paramètres de compilation, habituellement stockés dans les Makefiles. Bien que hiérarchisés, de nombreux paramètres redondants dans les Makefiles de sous-niveaux les rendaient de plus en plus gros et difficiles à mettre à jour. Heureusement, il existe désormais une manière simplifiée de gérer la compilation, appelée kbuild, et le processus de compilation des modules externes chargeables à la volée est maintenant entièrement intégrée aux mécanismes de compilation standard du noyau. Pour en apprendre davantage sur la compilation de modules qui ne font pas officiellement partie du noyau (tel que tous les exemples que vous trouverez dans ce guide), regardez le fichier <b>linux/Documentation/kbuild/modules.txt</b>.
</p>

<p>
Vous trouverez également des détails complémentaires sur les Makefiles pour les modules noyau dans le fichier <b>linux/Documentation/kbuild/makefiles.txt</b>. Lisez ce fichier et ceux qui y sont liés avant de commencer à modifier un Makefile; vous économiserez beaucoup de temps.
</p>

<blockquote>
<p>
Voici un petit exercice pour le lecteur : Vous voyez le commentaire plus haut concernant la valeur renvoyée par la fonction init_module()? Changez cette valeur pour une valeur quelconque négative, recompilez et rechargez le module. Que se passe-t-il ?
</p>
</blockquote>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Salut et Au revoir</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Comme je l'ai précisé précédemment, dans les premières versions du noyau, vous deviez utiliser les fonctions <b>init_module</b> et <b>cleanup_module</b>, comme dans le premier exemple. Mais désormais, vous pouvez appeler vos fonctions comme bon vous semble en utilisant les macros <b>module_init</b> et <b>module_exit</b>. Ces macros sont définies dans <b>linut/init.h</b>. La seule nécessité est que les fonctions soient définies avant d'appeler ces macros, ou vous vous retrouverez avec des erreurs de compilations. Voici un exemple de cette technique :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-2.c - Exemple montrant l'usage des macros module_init() et</span>
<span class="org-comment"> *              module_exit (). Ces macros sont &#224; pr&#233;f&#233;rer aux fonctions</span>
<span class="org-comment"> *              init_module() et cleanup_module().</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_2_init(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world 2\n"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_2_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 2\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_2_init);
<span class="org-function-name">module_exit</span>(hello_2_exit);
</pre>
</div>

<p>
Nous avons maintenant deux modules noyau à notre actif. Ajouter un autre module à notre Makefile se fait aussi simplement que ça :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o
<span class="org-variable-name">obj-m</span> += hello-2.o
<span class="org-makefile-targets">all</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
Maintenant, jetons un œil au fichier linux/drivers/car/Makefile pour un exemple de Makefile en situation réelle.
</p>

<p>
Comme vous pouvez le voir, certains modules sont connectés en dur au noyau (obj-y), mais où sont passés tous les obj-m ? Les lecteurs à l'aise avec le bash verront rapidement où je veux en venir. Pour les débutants, les nombreuses lignes obj-$(CONFIG_EXEMPLE) que vous pouvez voir s'étendent soit en obj-y, soit en obj-m, selon que la variable CONFIG_EXEMPLE soit égale à y ou à m. Ces variables sont affectées dans le fichier linux/.config, au moment où vous lancez make menuconfig ou une autre commande pour configurer votre noyau avant de le compiler.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Les macros __init et __exit</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Ces macros sont une nouveauté du noyau 2.2. Vous observerez les changements dans les définitions des fonctions de départ et de fin. La macro <b>__init</b> conduit la fonction d'entrée à être supprimée du noyau afin que son espace mémoire soit libéré, une fois que la fonction d'entrée s'est terminée. Comme cette fonction n'est faite que pour être appelée qu'une fois, ce mécanisme est sensé. Cette fonctionnalité n'est cependant disponible que pour les pilotes compilés avec votre noyau et n'aura aucun effet sur votre module.
</p>

<p>
Il existe également une macro <b>__initdata</b> donc le fonctionnement est semblable à <b>__init</b> mais pour les variables d'initialisation plutôt que pour les fonctions.
</p>

<p>
Il existe également la macro <b>__exit</b>, qui permet d'ignorer la fonction de sortie au moment de la compilation de votre noyau. Si vous considérez que cette fonction ne doit pas être appelée puisqu'elle ne peut être enlevée de votre noyau, là encore ce mécanisme est utile. Encore une fois, cette fonctionnalité n'a de sens que pour les pilotes compilés avec votre noyau et n'aura aucun effet sur votre module.
</p>

<p>
Ces macros sont définies dans le fichier <b>linux/init.h</b> et ne servent qu'à économiser l'espace mémoire du noyau. Quand vous lancer votre noyau vous aurez peut-être l'occasion de votre un message tel que "Freeing unused kernel memory : 236k freed" C'est précisémment de ce mécanisme qu'il s'agit.
</p>


<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-3.c - Illustre l'usage des macros __init, __initdata et __exit.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">hello3_data</span> __initdata = 3;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_3_init(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world %d\n"</span>, hello3_data);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_3_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 3\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_3_init);
<span class="org-function-name">module_exit</span>(hello_3_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Licences et Documentation du Module</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Soyons honnête : Quel genre de fou charge dans son noyau des modules propriétaires ? Si c'est votre cas, vous avez peut-être déjà vu ce message :
</p>

<div class="org-src-container">

<pre class="src src-txt"># insmod xxxxxx.o
Warning: loading xxxxxx.ko will taint the kernel: no license
  See http://www.tux.org/lkml/#export-tainted for information about tainted modules
Module xxxxxx loaded, with warnings
</pre>
</div>

<p>
Vous pouvez utiliser certaines macros pour indiquer la licence pour votre module. A titre exhaustif, vous pouvez utiliser "GPL", "GPL v2", "GPL and additional rights", "Dual BSD/GPL", "Dual MIT/GPL", "Dual MPL/GPL" comme licence libre. Toutes les autres sont "Proprietary", et ne sont donc pas considérées comme libres. Ces macros sont définies dans le fichier <b>linux/module.h</b>.
</p>

<p>
La macro pour indiquer la licence de votre module est <b>MODULE_LICENSE</b>. Cette macro, ainsi que d'autres servant à décrire le module sont illustrées dans l'exemple suivant.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-4.c - Illustre la documentation des modules.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour tous les modules </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour la macro pr_info </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>         <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour les macros de modules </span><span class="org-comment-delimiter">*/</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"A sample driver"</span>);
MODULE_SUPPORTED_DEVICE(<span class="org-string">"testdevice"</span>);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> init_hello_4(<span class="org-type">void</span>)
{
        pr_info(<span class="org-string">"Hello, world 4\n"</span>);
        <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> cleanup_hello_4(<span class="org-type">void</span>)
{
        pr_info(<span class="org-string">"Goodbye, world 4\n"</span>);
}

<span class="org-function-name">module_init</span>(init_hello_4);
<span class="org-function-name">module_exit</span>(cleanup_hello_4);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Passer un argument à votre module</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Les modules peuvent recevoir un argument via une ligne de commande, mais pas de la manière d'un programme utilisateur.
</p>

<p>
Afin de permettre à votre module de recevoir des arguments, vous devez déclarer des variables globales qui recevront ces arguments. Vous devrez ensuite utiliser la macro module_param (laquelle est définie dans le fichier linux/moduleparam.h) afin d'activer ce mécanisme. Quand votre module sera lancé, la commande insmod va affecter ces variables globales avec les valeurs données (par exemple ./insmod mymodule.ko variable=5). Les variables ainsi que les macros que je viens de décrire doivent être placées au début de votre module pour des raisons de lisibilité. L'exemple suivant démontrera ce point plus facilement qu'un long discours.
</p>

<p>
La macro module_param() prend 3 arguments : le nom de la variable, son type et la permission du fichier correspondant (qui sera créé pour chaque argument) créé avec sysfs. Les entiers peuvent être signés ou non signés. Si vous souhaitez utiliser des tableaux d'entiers ou des chaînes de caractères, vous chercherez les macros module_param_array() et module_param_string().
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-variable-name">myint</span> = 3;
<span class="org-function-name">module_param</span>(myint, <span class="org-type">int</span>, 0);
</pre>
</div>

<p>
Le mécanisme pour les tableaux d'arguments est maintenant différents des premières versions de Linux. Pour garder une trace du nombre de paramètres vous devez passer, en troisième argument, un pointeur vers une variable qui contiendra un compteur. Vous pouvez également ignorer ce compteur et passer la valeur NULL à la place. Voici un exemple traitant ces deux méthodes :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-variable-name">myintarray</span>[2];
<span class="org-function-name">module_param_array</span>(myintarray, <span class="org-type">int</span>, <span class="org-constant">NULL</span>, 0); <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'arguments n'est pas pris en compte </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">short</span> <span class="org-variable-name">myshortarray</span>[4];
<span class="org-type">int</span> <span class="org-variable-name">count</span>;
<span class="org-function-name">module_parm_array</span>(myshortarray, <span class="org-type">short</span>, &amp;count, 0); <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'arguments est pris en compte </span><span class="org-comment-delimiter">*/</span>
</pre>
</div>

<p>
Un bon usage consiste à utiliser des valeurs par défaut pour vos variables, tel qu'un port ou une adresse d'entrée/sortie par défaut. Si les variables contiennent les valeurs par défaut, alors vous lancez une mécanisme d'autodétection (qui sera expliqué plus tard). Sinon vous gardez la valeur passée en argument. Cet aspect sera clarifié par la suite.
</p>

<p>
Ensuite, il existe une macro de fonction, <b>MODULE_PARAM_DESC()</b>, qui est utilisée pour documenter les arguments que votre module peut prendre. Cette macro a besoin de deux paramètres : un nom de variable et une chaîne de caractères qui décrit cette variable.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  hello-5.c - Montre comment recevoir des arguments de la ligne de commande.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/moduleparam.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/stat.h&gt;</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Peter Jay Salzman"</span>);

<span class="org-keyword">static</span> <span class="org-type">short</span> <span class="org-type">int</span> <span class="org-variable-name">myshort</span> = 1;
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myint</span> = 420;
<span class="org-keyword">static</span> <span class="org-type">long</span> <span class="org-type">int</span> <span class="org-variable-name">mylong</span> = 9999;
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">mystring</span> = <span class="org-string">"blah"</span>;
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myintArray</span>[2] = { -1, -1 };
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">arr_argc</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * module_param(foo, int, 0000)</span>
<span class="org-comment"> * Le premier param&#232;tre est le nom du param&#232;tre</span>
<span class="org-comment"> * Le second est son type</span>
<span class="org-comment"> * Le dernier argument d&#233;crit les drapeaux de permissions du fichier au sein</span>
<span class="org-comment"> *   du sysfs qui sera cr&#233;&#233; plus tard (si toutefois cette valeur n'est pas</span>
<span class="org-comment"> *   nulle).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-function-name">module_param</span>(myshort, <span class="org-type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
<span class="org-function-name">MODULE_PARM_DESC</span>(myshort, <span class="org-string">"Un entier short"</span>);
<span class="org-function-name">module_param</span>(myint, <span class="org-type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
<span class="org-function-name">MODULE_PARM_DESC</span>(myint, <span class="org-string">"Un entier"</span>);
<span class="org-function-name">module_param</span>(mylong, <span class="org-type">long</span>, S_IRUSR);
<span class="org-function-name">MODULE_PARM_DESC</span>(mylong, <span class="org-string">"Un entier long"</span>);
<span class="org-function-name">module_param</span>(mystring, charp, 0000);
<span class="org-function-name">MODULE_PARM_DESC</span>(mystring, <span class="org-string">"Une cha&#238;ne de caract&#232;res"</span>);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * module_param_array(name, type, num, perm);</span>
<span class="org-comment"> * Le premier param&#232;tre est le nom du param&#232;tre (ici le nom du tableau)</span>
<span class="org-comment"> * Le second est le type des &#233;l&#233;ments au sein de ce tableau</span>
<span class="org-comment"> * Le troisi&#232;me argument est un pointeur vers une variable qui contiendra</span>
<span class="org-comment"> *   suite &#224; l'appel de cette fonction le nombre d'&#233;l&#233;ments initialis&#233; par</span>
<span class="org-comment"> *   l'utilisateur</span>
<span class="org-comment"> * Le dernier argument d&#233;crit les drapeaux de permissions du fichier au sein</span>
<span class="org-comment"> *   du sysfs qui sera cr&#233;&#233; plus tard (si toutefois cette valeur n'est pas</span>
<span class="org-comment"> *   nulle).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-function-name">module_param_array</span>(myintArray, <span class="org-type">int</span>, &amp;arr_argc, 0000);
<span class="org-function-name">MODULE_PARM_DESC</span>(myintArray, <span class="org-string">"Un tableau d'entiers"</span>);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> hello_5_init(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    pr_info(<span class="org-string">"Hello, world 5\n=============\n"</span>);
    pr_info(<span class="org-string">"myshort is a short integer: %hd\n"</span>, myshort);
    pr_info(<span class="org-string">"myint is an integer: %d\n"</span>, myint);
    pr_info(<span class="org-string">"mylong is a long integer: %ld\n"</span>, mylong);
    pr_info(<span class="org-string">"mystring is a string: %s\n"</span>, mystring);
    <span class="org-keyword">for</span> (i = 0; i &lt; (<span class="org-keyword">sizeof</span> myintArray / <span class="org-keyword">sizeof</span> (<span class="org-type">int</span>)); i++)
    {
        pr_info(<span class="org-string">"myintArray[%d] = %d\n"</span>, i, myintArray[i]);
    }
    pr_info(<span class="org-string">"got %d arguments for myintArray.\n"</span>, arr_argc);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> hello_5_exit(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Goodbye, world 5\n"</span>);
}

<span class="org-function-name">module_init</span>(hello_5_init);
<span class="org-function-name">module_exit</span>(hello_5_exit);
</pre>
</div>

<p>
Je vous recommande d'essayer ce code :
</p>

<div class="org-src-container">

<pre class="src src-txt"># sudo insmod hello-5.ko mystring="bebop" mybyte=255 myintArray=-1
mybyte is an 8 bit integer: 255
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: bebop
myintArray is -1 and 420

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mystring="supercalifragilisticexpialidocious" \
&gt; mybyte=256 myintArray=-1,-1
mybyte is an 8 bit integer: 0
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious
myintArray is -1 and -1

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mylong=hello
hello-5.o: invalid argument syntax for mylong: 'h'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Créer un module depuis plusieurs fichiers</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Vous aurez parfois besoin de diviser le code source de votre module en plusieurs fichiers.
</p>

<p>
Voila l'exemple d'un module avec une telle organisation :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  start.c - Illustration d'un module d&#233;coup&#233; en plusieurs fichiers</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Ce code ex&#233;cute du code noyau </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Et il appelle des fonctions pour modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"Hello, world\n"</span>);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Le second fichier :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  start.c - Illustration d'un module d&#233;coup&#233; en plusieurs fichiers</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Ce code ex&#233;cute du code noyau </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Et il appelle des fonctions pour modules </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    pr_info(<span class="org-string">"Short is the life of a kernel module\n"</span>);
}
</pre>
</div>

<p>
Et finalement : Le Makefile
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">obj-m</span> += hello-1.o
<span class="org-variable-name">obj-m</span> += hello-2.o
<span class="org-variable-name">obj-m</span> += hello-3.o
<span class="org-variable-name">obj-m</span> += hello-4.o
<span class="org-variable-name">obj-m</span> += hello-5.o
<span class="org-variable-name">obj-m</span> += startstop.o
<span class="org-variable-name">startstop-objs</span> := start.o stop.o

<span class="org-makefile-targets">all</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) modules

<span class="org-makefile-targets">clean</span>:
    make -C /lib/modules/$(<span class="org-variable-name">shell</span> uname -r)/build M=$(<span class="org-variable-name">PWD</span>) clean
</pre>
</div>

<p>
Voilà le Makefile complet pour tous les exemples que nous avons traités jusqu'ici. Les cinq premières lignes ne vous étonneront pas, mais pour le dernier exemple vous aurez besoin de deux lignes. Nous inventons d'abord un nom d'objet pour tous nos fichiers combinés, puis on indique au Makefile quels objets forment le module.
</p>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Créer des modules pour un noyau précompilé</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Nous vous recommandons fortement de recompiler votre noyau, afin que vous puissiez activer de nombreuses fonctionnalités utiles pour le débogage, par exemple forcer l'enlèvement du noyau de votre module : (<b>MODULE_FORCE_UNLOAD</b>): cette option vous permettra de décharger votre module du noyau même quand ce dernier estime qu'il est dangereux de le décharger, via la commande <b>sudo rmmod -f module</b>. Cette option vous fera économiser beaucoup de temps et de redémarrage durant le développement de votre module. Si vous ne désirez pas recompiler votre noyau, vous pouvez envisager d'utiliser une machine virtuelle. Si vous commettez une erreur vous pourrez donc facilement redémarrer ou restaurer votre machine virtuelle à son état initial.
</p>

<p>
Il existe également de nombreux cas dans lesquels vous préférerez charger votre module dans un noyau précompilé, tel que ceux fournis avec la plupart des distributions Linux, ou un noyau que vous avez déjà compilé vous-même. Dans certaines circonstances, vous aurez besoin de compiler et d'insérer vos modules dans un noyau que vous ne pouvez pas recompiler, ou sur une machine qu'il ne vaut mieux pas redémarrer. Si vous pensez que ce genre de situation ne vous arrivera jamais, vous pouvez passer à la suite et considérer le reste de ce chapitre comme une grosse note de bas de page.
</p>

<p>
Maintenant, si vous avez installé le code source du noyau, utilisez-le pour compiler votre module et si vous essayez d'insérer votre module au sein du noyau, dans la plupart des cas vous subirez l'erreur suivante :
</p>

<div class="org-src-container">

<pre class="src src-txt">insmod: error inserting 'poet_atkm.ko': -1 Invalid module format
</pre>
</div>

<p>
Des informations moins laconiques sont enregistrées dans le journal systemd :
</p>

<div class="org-src-container">

<pre class="src src-txt">Jun  4 22:07:54 localhost kernel: poet_atkm: version magic '2.6.5-1.358custom 686
REGPARM 4KSTACKS gcc-3.3' should be '2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3'
</pre>
</div>

<p>
En d'autres mots, votre noyau refuse d'accepter votre module car les versions (on parle de version magics) ne correspondent pas. D'ailleurs, les versions sont enregistrées dans votre module compilé sous la forme d'une chaîne de caractères statique, commençant pas vermagic:. Cette version est insérée dans votre module au moment où ce dernier est lié au fichier <b>init/vermagic.o</b>. Afin d'observer la version et les autres chaînes de caractères stockées au sein d'un module, vous pouvez utilisez la commande modinfo :
</p>

<div class="org-src-container">

<pre class="src src-txt"># sudo modinfo hello-4.ko
license:        GPL
author:         Bob Mottram &lt;bob@freedombone.net&gt;
description:    A sample driver
vermagic:       4.15.2-1.358 amd64 REGPARM 4KSTACKS gcc-4.9.2
depends:
</pre>
</div>

<p>
Pour régler le problème soulevé plus haut, nous pouvons avoir recours à l'option <b>&#x2013;force-vermagic</b>, mais cette solution est potentiellement dangereuse, et inacceptable pour un module dont le développement est en phase de production. En conséquence, nous voulons compiler nos modules dans un environnement qui est identique à celui dans le quel notre noyau a été compilé. Comment procéder est l'objet de ce chapitre.
</p>

<p>
Avant tout, assurez-vous d'avoir le code source de votre noyau à portée de main, et dans la même version que celle de votre noyau actuel, ou du noyau de votre machine virtuelle. Ensuite, trouvez le fichier de configuration qui a été utilisé pour compiler votre noyau. Habituellement, vous pouvez le trouver dans votre répertoire <i>boot, sous un nom tel que config-4.7.xxx. Vous voulez peut-être juste le copier dans votre code source : *cp /boot/config-`uname -r` /usr/src/linux-`uname -r`</i>.config*.
</p>

<p>
Concentrons-nous maintenant sur le message d'erreur précédent : en regardant de plus près les versions, on constate que même si les deux fichiers de configurations sont exactement identiques, il existe une légère différence dans les versions, et cette différence suffit à empêcher votre module d'être inséré dans votre noyau. Cette petite différence, à savoir la chaîne de caractères modifiée dans la version du module vient de la modification apportée par le Makefile de certaines distributions. Examinez donc le fichier <b>/usr/src/linux/Makefile</b>, et assurez-vous que la version spécifiée corresponde bien à votre noyau actuel. Par exemple, votre Makefile peut commencer par :
</p>

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-variable-name">VERSION</span> = 4
<span class="org-variable-name">PATCHLEVEL</span> = 7
<span class="org-variable-name">SUBLEVEL</span> = 4
<span class="org-variable-name">EXTRAVERSION</span> = -1.358custom
</pre>
</div>

<p>
Dans ce cas, vous devez restaurer la valeur du symbole <b>EXTRAVERSION</b> à -1.358. Nous vous suggérons cependant de garder une sauvegarde du Makefile utilisé pour compiler votre noyau, lequel est disponible dans <b>/lib/modules/4.15.2-1.358/build</b>. Une simple commande <b>cp /lib/modules/`uname-r`/build/Makefile /usr/src/linux-`uname -r`</b> devrait suffir. De plus si vous avez déjà commencé à compiler un noyau avec le (mauvais) Makefile précédent, vous devriez relancer la compilation, ou alors modifier le symbole UTS_RELEASE dans le fichier <b>/usr/src/linux-4.15.2/include/linux/version.h</b> pour qu'il corresponde au contenu du fichier <b>/lib/modules/4.15.2/build/include/linux/version.h</b> (ou alors écraser le second avec le premier).
</p>

<p>
Maintenant relancez la commande make pour mettre à jour la configuration et les versions :
</p>

<div class="org-src-container">

<pre class="src src-txt"># make
CHK     include/linux/version.h
UPD     include/linux/version.h
SYMLINK include/asm -&gt; include/asm-i386
SPLIT   include/linux/autoconf.h -&gt; include/config/*
HOSTCC  scripts/basic/fixdep
HOSTCC  scripts/basic/split-include
HOSTCC  scripts/basic/docproc
HOSTCC  scripts/conmakehash
HOSTCC  scripts/kallsyms
CC      scripts/empty.o
</pre>
</div>

<p>
Vous n'avez pas besoin de recompiler la totalité de votre noyau, vous pouvez interrompre la compilation avec un Ctrl+C après la ligne SPLIT, parce qu'à ce moment, tous les fichiers dont vous avez besoin ont déjà été recompilés. Vous pouvez revenir dans le répertoire de votre module et le recompiler : Il sera recréé conformément aux exigences des paramètres de votre noyau actuel et pourra donc être chargé sans erreurs.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Avant-propos</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Où la vie d'un module commence et où elle se termine</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Un programme est d'habitude intégré dans une fonction `main()`, y entre, exécute un certain nombre d'instructions avant de se terminer. Les modules du noyau ne fonctionnent pas de cette manière. Un module commence avec la fonction de départ, que ce soit la fonction init_module ou la fonction spécifiée par la macro module_init. C'est la fonction d'entrée pour mes modules; elle informe le noyau des fonctionnalités que ce module fournit, et paramètre le noyau pour lancer les fonctions du module quand nécessaire. Ensuite, la fonction de départ se termine et le module ne fait plus rien tant que le noyau n'a pas décidé d'appeler le code fournit par le module.
</p>

<p>
Tous les modules se terminent par une fonction de fin, soit en <b>cleanup_module</b>, soit la fonction spécifiée par l'appel de la macro <b>module_exit</b>. C'est la fonction de sortie de votre module; elle doit défaire tous les changements apportés par votre fonction de départ. La fonction de fin doit enlever toutes les fonctionnalités que la fonction de départ avait enregistrées.
</p>

<p>
Tous les modules doivent avoir une fonction de départ et une fonction de fin. Comme il y a de nombreuses façons d'appeler ces fonctions, je m'emploierai à faire de mon mieux pour parler de fonction de départ et de sortie, mais si par mégarde j'emploie les termes de fonction d'entrée et de sortie ou de fonction init_module et cleanup_module, vous saurez de quoi je veux parler.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Fonctions disponibles pour votre module</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Les développeurs utilisent sans arrêt des fonctions qu'ils n'ont pas eux-mêmes définies. Un exemple flagrant est la fonction <b>printf()</b> Vous utilisez des bibliothèques de fonctions qui sont fournies par la bibliothèque standard du C, libc. Votre code n'appelle pas réellement ces fonctions avant l'édition de lien, qui s'assure que le code est disponible, et modifie les appels des fonctions recherchées pour qu'il pointe effectivement vers le code concerné.
</p>

<p>
Ici aussi, les modules sont différents. Dans l'exemple hello world, vous avez peut-être remarqué que nous avons utilisé une fonction, <b>pr_info()</b> mais que nous n'avons pas inclut de bibliothèque d'entrée/sortie. C'est parce que les modules sont des fichiers objets dont les symboles sont affectés au moment de l'insertion de votre module. La définition de ces symboles vient du noyau lui-même. Les seuls fonctions externes que vous pouvez utiliser sont celles fournies pas le noyau. Si vous êtes curieux et souhaitez savoir quels symboles sont exportés par votre noyau, vous pouvez regarder <b>/proc/kallsyms</b>.
</p>

<p>
Il faut garder à l'esprit la différence entre fonctions de bibliothèques et appels système. Les fonctions de bibliothèques sont situées à un niveau plus haut, tournent dans l'espace utilisateur et fournissent une interface plus accessible que les fonctions qui font réellement tout le boulot : les appels système. Les appels système sont fournis par le noyau et tournent dans l'espace noyau sur demande de l'utilisateur. La fonction de bibliothèque printf() peut vous sembler être une fonction très généraliste, mais en réalité tout ce qu'elle fait est de formater les informations passées dans une chaîne de caractères et ensuite écrire la chaîne de caractères en utilisant l'appel système bas niveau write(), lequel envoit les données à écrire vers l'affichage standard.
</p>

<p>
Vous souhaitez voir à quels appels système fait appel un simple printf() ? Rien de plus simple ! Compilez le programme suivant avec la commande <b>gcc -Wall -o hello hello.c</b> :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">void</span>)
{
    printf(<span class="org-string">"hello"</span>);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Lancez l'exécutable avec <b>strace ./hello</b>. Impressioné ? Chacune des lignes que vous voyez correspond à un appel système. <a href="https://strace.io/">strace</a> est un programme très utile qui vous détaille la liste des appels système émis, avec quels arguments et quelles sont les valeurs retournées. C'est un outil inestimable pour comprendre à quels fichiers un programme accède. À la fin, vous devriez voir une ligne semblable à (1, "hello", 5hello). Voici le visage derrière le masque d'un printf(). Vous n'êtiez peut-être pas très familiarisé avec la fonction write(), puisque la plupart des développeurs utilisent des bibliothèques utilisateurs pour les entrées/sorties (tel que fopen, fputs, fclose). Si c'est la cas, jetez un coup d'oeil au manuel man 2 write. La deuxième section des manuels (man 2) correspond aux appels système (tel que kill() ou read()). La troisième section quant à elle contient des appels à des bibliothèques utilisateurs (comme cosh() ou random()).
</p>

<p>
Vous pouvez même écrire des modules pour remplacer les appels système du noyau, ce qu'on fera très prochainement. Les pirates utilisent souvent cette technique pour introduire un cheval de Troie au sein d'un système, mais vous pouvez utiliser votre module pour faire des choses bien pus innocentes, comme écrire "You hou, ça chatouille !" à chaque fois que quelqu'un demande à supprimer un fichier sur votre système.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Mode utilisateur, mode noyau</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Il existe bien des manières de résumer un système d'exploitation. L'une d'entre elles est de le voir comme un gestionnaire de ressources, que ces ressources en questions soient une carte graphique, un disque dur ou même la mémoire. Plusieurs programmes rentrent souvent en compétition avec la même ressource. Alors que je viens juste de sauvegarder ce document, updatedb a commencé a mettre à jour sa base de donnée locale. Mon éditeur de texte et updatedb doivent tous les deux utiliser mon disque dur, en même temps. Le noyau doit gérer ces demandes concurrentes, et ne pas donner à l'utilisateur tous les accès ressources quand ce dernier le souhaite. Pour répondre à cete exigeance, un processeur peut gérer plusieurs modes. Chaque mode donne certains droits sur le système. Par exemple, l'architecture Intel 80386 d'Intel gère ainsi quatre niveaux de privilèges différents. Unix n'en utilise que deux : le niveau le plus haut (niveau 0, aussi appelé mode noyau, ou superviseur), et le niveau le plus bas, appelé niveau utilisateur.
</p>

<p>
Revenons sur les différences entre bibliothèques utilisateur et appels système. Le plus souvent, vous utilisez une fonction d'une bibliothèque utilisateur en mode utilisateur. Cette fonction appelle un ou plusieurs appels système, et ces derniers, exécutés sur demande de l'utilisateur, sont lancés en mode noyau, puisqu'ils font partie du noyau. Au retour des appels système, l'exécution est de nouveau transférée en mode utilisateur.
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Convention de nommage</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Quand vous écrivez un petit programme en C, vous utilisez des variables avec un nom cohérent et qui sont facilement compréhensibles pour le lecteur. Mais si vous écrivez des fonctions qui seront insérées dans un noyau, toutes vos variables globales seront confondues avec toutes les variables globales du système. Et comme deux variables ne peuvent être homonymes, des conflits peuvent apparaître. Quand un programme utilise de nombreuses variables globales qui ne sont pas assez précises et que des conflits apparaissent, alors on parle de pollution de nommage. De manière générale, dans les projets imposants, un effort particulier doit être porté pour respecter une convention de nommage, afin de nommer les variables et les macros de manière unique et standardisée.
</p>

<p>
Quand vous écrivez du code pour le noyau, même le plus petit module peut être lié avec tout le noyau, et le faire entièrement dérailler, alors il faut prendre ce problème au sérieux. La meilleure manière de procéder est de déclarer toutes vos variables de manières statiques et d'utiliser des préfixes bien définis pour vos symboles. La convention pour le noyau est de créer des préfixes en minuscule. Et si vous ne voulez pas déclarer toutes vos variables en statiques, vous avez la possibilité de déclarer une table des symboles et de l'enregistrer dans le noyau. Nous y reviendrons plus tard.
</p>

<p>
Le fichier <b>/proc/kallsyms</b> détient tous les symboles dont le noyau a conscience qui sont donc accessible depuis votre module, tant que ce dernier partage l'espace du noyau.
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Espace de code</h3>
<div class="outline-text-3" id="text-5-5">
<p>
La gestion de la mémoire est un sujet très compliqué, et la majorité du livre de O'Reilly's <b>Understanding The Linux Kernel</b> se résume à expliquer la gestion de mémoire de Linux ! Pour continuer ce cours, vous n'aurez pas besoin d'être des experts en gestion de mémoire, mais il est important de savoir certaines choses avant de commencer à créer de vrais modules.
</p>

<p>
Si vous ne vous êtes jamais vraiment demandé le mécanisme derrière une segfault, vous serez surpris de savoir que les pointeurs ne pointent pas vraiment vers un emplacement mémoire réel. Quand un processus est créé, le noyau lui attribue une partie de la mémoire physique, que le processus va utiliser pour stocker son code d'exécution, ses variables, sa pile, ses allocations etc. Cette mémoire commence à l'adresse 0x0 (pour 0) et s'étend tant qu'elle en a besoin. L'espace mémoire de deux processus ne peuvent pas se confondre. Imaginons donc un processus P1 qui accède à une adresse donnée, disons 0x7fca. Ce dernier n'accédera pas à l'adresse physique réelle 0x7fca, mais à un index qui porte ce nom, et qui pointe vers la zone mémoire fournie par le noyau à P1, à une sorte de curseur déterminé par la valeur 0x7fca. Un second processus P2 qui souhaite accéder à la même adresse 0x7fca, n'accédera donc pas du tout à la même adresse physique que celle demandée par P1. Pour le commun des mortels, un processus ne peut pas accéder à l'espace mémoire d'un autre processus, mais il y a pour les initiés une manière de procéder qu'on va traiter un peu plus tard.
</p>

<p>
De même que chaque processus a son propre espace dans la mémoire, le noyau a son espace réservé. Comme un module est un code qui est inséré dynamiquement, puis supprimé du noyau, alors le module partage l'espace de code du noyau, et c'est donc dans cet espace que son code est inséré. Par conséquent, si votre module commet une erreur de segmentation, c'est tout le noyau qui est responsable de cette erreur. Et si par erreur vous dépasser de votre espace mémoire, c'est dans le noyau que vous écrirez, et les répercussions peuvent être catastrophiques. Soyez donc très attentifs car une erreur ici peut causer la mort définitive de tout votre système.
</p>

<p>
Je tiens aussi à insister sur le fait que ceci est vrai pour tous les systèmes d'exploitation conçus sur base d'un noyau monolithique. Mais il existe aussi ce qu'on appelle les micro-noyaux, qui sont des systèmes d'exploitation où les modules ont un espace mémoire qui leur est propre. Le GNU Hurd et le QNX Neutrino sont des exemples de micro-noyaux.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Les pilotes de périphériques</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Les pilotes de périphériques forment une catégorie de modules, qui fournissent des fonctionnalités au matériel telle qu'un port série. Sur Unix, chaque périphérique matériel est représenté par un fichier, appelé fichier de périphérique dans le répertoire /dev. Ce fichier fournit des moyens pour communiquer avec le matériel. Le pilote de périphérique fournit donc au programme utilisateur une communication avec le matériel. Ainsi, le pilote de périphérique de carte son es1370.o doit connecter le fichier de périphérique /dev/sound à la carte son Ensoniq IS1370. L'intérêt, c'est qu'un programme utilisateur comme mp3blaster pourra utiliser /dev/sound sans se soucier du modèle de carte son présent sur la machine.
</p>

<p>
Dans Unix, tout est fichier. Votre périphérique et son pilote seront tous deux représentés par leur propre fichier. Par la suite, il peut m'arriver d'employer le terme fichier de périphérique pour parler du fichier associé à un périphérique, et de fichier de pilote, ou juste pilote, pour parler du fichier associé au pilote de votre périphérique.
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-6-0-1" name="sec-5-6-0-1"></a>Numéros majeurs et numéros mineurs<br  /><div class="outline-text-5" id="text-5-6-0-1">
<p>
Jetons un œil à certains fichiers associés aux périphériques.
Voici les fichiers de périphériques qui représentent les trois premières partitions d'un disque dur SATA :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">ls -l /dev/sda[1-3]</span>
brw-rw---- 1 root disk 8, 1 Mar 27 13:09 sda1
brw-rw---- 1 root disk 8, 2 Mar 27 13:09 sda2
brw-rw---- 1 root disk 8, 3 Mar 27 13:09 sda3
</pre>
</div>

<p>
Observez les colonnes de chiffres séparés par une virgule. Le premier chiffre est le numéro majeur du périphérique. Le second chiffre est le numéro mineur. Le numéro majeur vous précise quel pilote est utilisé pour accéder au matériel. À chaque pilote est donc attribué un numéro majeur unique, et tous les périphériques partageant un numéro majeur partagent également un pilote commun. Dans notre exemple, tous les numéro majeurs sont 8, parce que tous ces périphériques sont contrôlés par le même pilote.
</p>

<p>
Le numéro mineur quant à lui est utilisé par le pilote pour faire une distinction entre tous les périphériques qu'il contrôle. Pour revenir sur l'exemple plus haut, bien que les périphériques aient un numéro majeur en commun, ils ont tous un numéro mineur différent parce que les pilote les voit comme des matériels différents.
</p>

<p>
Le monde des fichiers de périphérique se divise en deux catégories : ceux en mode caractère, et ceux en mode bloc. La différence vient du fait que les fichiers de périphériques en mode bloc possèdent un tampon pour ses requêtes, afin qu'ils puissent choisir avec soin dans quel ordre répondre à ces requêtes. Cette stratégie est très importante dans le cas d'un périphérique de stockage, comme un disque dur, où il est plus rapide de lire et d'écrire des espaces mémoire voisins, plutôt que de réaliser les requêtes dans n'importe quel ordre. Une autre différence est que les fichiers de périphériques en mode bloc ne peuvent recevoir et renvoyer que des données sous la forme de blocs (dont la taille varie selon le périphérique) alors que les fichiers périphériques en mode caractère sont autorisés à lire et à écrire autant d'octets qu'ils le souhaitent. La plupart des fichiers de périphériques sont en mode caractère, parce qu'ils n'ont pas besoin d'un tampon et qu'ils ne travaillent pas avec une taille fixe de donnée. Vous pouvez savoir quel est le type d'un fichier de périphérique en regardant le premier caractère affiché sur une ligne par la commande `ls -l`. Si elle commence par un 'b', alors la ligne décrit un fichier de périphérique en mode bloc. Si elle commence par un 'c', alors il s'agit du mode caractère. Les fichiers de périphériques vus précédemment sont donc en mode bloc. Voilà quelques fichiers périphériques de mode caractère (les ports séries) :
</p>

<div class="org-src-container">

<pre class="src src-sh">crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
</pre>
</div>

<p>
Si vous souhaitez savoir quels numéros majeurs ont déjà été assignés, alors jetez un œil au fichier `/usr/src/linux/Documentation/devices.txt`.
</p>

<p>
Quand le système a été installé, tous ces fichiers de périphériques ont été créés par la commande mknod. Pour créer un nouveau fichier périphérique en mode caractère appelé 'chocolat' avec les numéros majeurs et mineurs respectivement 12 et 2, vous n'avez qu'à utiliser la commande mknod /dev/chocolat c 12 2. Vous n'êtes pas obligé d'insérer votre fichier de périphérique dans le dossier /dev, mais comme c'est une convention utilisée par Linux, vous devriez le faire si vous souhaitez éviter le bûcher. Bien sûr, quand vous créez un fichier de périphérique à des fins d'essais ou de débogage, vous pouvez le créer dans votre répertoire de travail. Assurez-vous cependant de le placer au bon endroit quand vous aurez terminé votre module.
</p>

<p>
Je souhaiterais cependant insister sur le fait qu'au moment où on accède à un fichier de périphérique, le noyau utilise le numéro majeur du fichier pour déterminer quel pilote il doit utiliser. Cela veut donc dire que le noyau n'a pas à se préoccuper du numéro mineur, mais c'est le pilote de périphérique qui regarde ce dernier afin de savoir quel à quel matériel il doit accéder.
</p>

<p>
D'ailleurs, quand je parle de "matériel", je veux parler d'une chose plus abstraite qu'une carte PCI que vous pouvez tenir dans votre main. Par exemple, regardez ces deux fichiers de périphériques :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">ls -l mmcblk0*</span>
brw-rw---- 1 root disk 179, 0 Apr  7 23:45 mmcblk0
brw-rw---- 1 root disk 179, 1 Apr  7 23:45 mmcblk0p1
</pre>
</div>

<p>
Maintenant vour savez que ces deux fichiers de périphériques sont des périphériques de blocs et qu'ils sont gérés par le même pilote (numéro majeur 179). Vous savez peut-être également qu'ils ne représentent tous deux qu'une seule et même carte SD connectée à votre ordinateur. Pourquoi alors deux fichiers pour une seule carte SD ? Une représente la carte SD dans son ensemble, et l'autre une partition de votre carte (même si cette dernière ne contient qu'une partition). Donc même si techniquement ces deux fichiers ne représentent qu'un seul matériel physique, le noyau voit deux matériaux différents. Soyez donc avertis que le mot "matériel", peut, dans notre cas, évoquer quelque chose d'abstrait.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Pilote de périphérique en mode caractère</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">La structure `file_operations`</h3>
<div class="outline-text-3" id="text-6-1">
<p>
La structure `file_operations` est définie dans le fichier `linux/fs.h`, et contient des pointeurs vers des fonctions définies par le pilote et qui effectue diverses opérations sur le périphérique. Chaque champ de cette structure correspond à une requête particulière et permet au pilote d'appeler la bonne fonction selon la demande.
</p>

<p>
Par exemple, chaque pilote en mode caractère peut définir une fonction qui lit une information depuis le périphérique. La structure `file_operations` contient l'adresse de la fonction de votre module qui va permettre d'effectuer cette opération. Voici à quoi ressemble une telle définition pour le noyau 3.0 :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> {
    <span class="org-keyword">struct</span> <span class="org-type">module</span> *<span class="org-variable-name">owner</span>;
    loff_t (*llseek) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span>, <span class="org-type">int</span>);
    ssize_t (*read) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">char</span> <span class="org-variable-name">__user</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
    ssize_t (*write) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">__user</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
    ssize_t (*aio_read) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">iovec</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">loff_t</span>);
    ssize_t (*aio_write) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">iovec</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">loff_t</span>);
    <span class="org-type">int</span> (*iterate) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">dir_context</span> *);
    <span class="org-type">unsigned</span> <span class="org-type">int</span> (*poll) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">poll_table_struct</span> *);
    <span class="org-type">long</span> (*unlocked_ioctl) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">int</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">long</span> (*compat_ioctl) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">int</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">int</span> (*mmap) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">vm_area_struct</span> *);
    <span class="org-type">int</span> (*open) (<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
    <span class="org-type">int</span> (*flush) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">fl_owner_t</span> <span class="org-variable-name">id</span>);
    <span class="org-type">int</span> (*release) (<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
    <span class="org-type">int</span> (*fsync) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span>, <span class="org-type">loff_t</span>, <span class="org-type">int</span> <span class="org-variable-name">datasync</span>);
    <span class="org-type">int</span> (*aio_fsync) (<span class="org-keyword">struct</span> <span class="org-type">kiocb</span> *, <span class="org-type">int</span> <span class="org-variable-name">datasync</span>);
    <span class="org-type">int</span> (*fasync) (<span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>);
    <span class="org-type">int</span> (*lock) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> *);
    ssize_t (*sendpage) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">struct</span> <span class="org-type">page</span> *, <span class="org-type">int</span>, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *, <span class="org-type">int</span>);
    <span class="org-type">unsigned</span> <span class="org-type">long</span> (*get_unmapped_area)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span>);
    <span class="org-type">int</span> (*check_flags)(<span class="org-type">int</span>);
    <span class="org-type">int</span> (*flock) (<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">int</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> *);
    ssize_t (*splice_write)(<span class="org-keyword">struct</span> <span class="org-type">pipe_inode_info</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span> *, <span class="org-type">size_t</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span>);
    ssize_t (*splice_read)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">loff_t</span> *, <span class="org-keyword">struct</span> <span class="org-type">pipe_inode_info</span> *, <span class="org-type">size_t</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span>);
    <span class="org-type">int</span> (*setlease)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">long</span>, <span class="org-keyword">struct</span> <span class="org-type">file_lock</span> **);
    <span class="org-type">long</span> (*fallocate)(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-type">int</span> <span class="org-variable-name">mode</span>, <span class="org-type">loff_t</span> <span class="org-variable-name">offset</span>,
              <span class="org-type">loff_t</span> <span class="org-variable-name">len</span>);
    <span class="org-type">int</span> (*show_fdinfo)(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">m</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">f</span>);
};
</pre>
</div>

<p>
Toutes les opérations ne sont pas implantées par un pilote. Par exemple, un pilote qui gère une carte graphique n'a pas besoin de lire un répertoire. Le champ correspondant à la lecture de répertoire d'un pilote de carte graphique devrait être assigné à la valeur NULL, afin que le noyau ait conscience que cette opération n'est pas gérée par le pilote en question.
</p>

<p>
Il existe une extension de gcc qui vous permet d'assigner cette structure de manière plus confortable. Voici une autre manière, déjà un peu plus moderne, de créer cette structure :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">fops</span> = {
        read: device_read,
        write: device_write,
        open: device_open,
        release: device_release
};
</pre>
</div>

<p>
Il existe également une manière plus gracieuse depuis C99 d'assigner des éléments à une structure, qui doit être préférée aux autre pour des raisons de lisibilité et de portabilité.
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">fops</span> = {
        .read = device_read,
        .write = device_write,
        .open = device_open,
        .release = device_release
};
</pre>
</div>

<p>
Cette méthode est claire, et vous devez avoir conscience que les membres de la structure qui ne sont pas explicitement assignés sont assignés à NULL par gcc.
</p>

<p>
L'instance de la struct <b>file_operations</b> (et qui est donc utilisée pour implanter des fonctions de lecture, d'écriture, d'ouverture&#x2026;) d'un module est communément appelée fops.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">La structure `file`</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Chaque périphérique est représenté dans le noyau par une structure <b>file</b>, laquelle est définie par <b>linux/fs.h</b>. Gardez en tête que cette structure reste au niveau du noyau, et l'utilisateur n'y a jamais accès. Il ne faut pas le confondre avec la structure FILE, qui est définie par la glibc et qui, elle, ne devrait jamais apparaître dans une fonction dans l'espace noyau. La structure <b>file</b> a un nom traître : cette structure ne réprésente pas un "vrai" fichier sur le disque (ce dernier est représenté par la structure <b>inode</b>).
</p>

<p>
L'instance de la struct <b>file</b> d'un module est communément appelé filp. Mais vous la verrez parfois porter le nom de file (struct <b>file</b> file). Je vous déconseille d'utiliser un tel nom.
</p>

<p>
Continuez et regardez dans vos sources la définition de la structure <b>file</b>. La plupart des variables que vous voyez, comme la <b>dentry</b>, ne sont pas utilisées par les pilotes de périphériques, et vous pouvez les ignorer. C'est parce que les pilotes ne remplissent pas directement de structure <b>file</b> mais ils ne font qu'utiliser les membres d'une structure <b>file</b> créée ailleurs.
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Enregistrer un périphérique</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Comme nous l'avons dit plus tôt, on peut accéder à un périphérique à travers des fichiers le représentant, appelés fichiers de périphériques, localisés par convention dans le répertoire <b>/dev</b>. Le numéro majeur vous renvoie à quel pilote gère le fichier de périphérique. Le numéro mineur n'est utilisé que par le pilote pour différencier les différents périphériques sur lesquels il opère.
</p>

<p>
Ajouter un pilote à votre système veut dire l'enregistrer dans votre noyau. Ce qui revient à y assigner un numéro majeur au moment de l'initialisation du module. C'est ce que vous faites en utilisant la fonction <b>register_chrdev</b>, définie dans <b>linux/fs.h</b> :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">register_chrdev</span>(<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">major</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>, <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> *<span class="org-variable-name">fops</span>);
</pre>
</div>

<p>
Ici, <b>unsigned int major</b> est le numéro majeur que vous souhaitez avoir, <b>const char \</b> name* est le nom de votre périphérique tel qu'il apparaîtra dans le répertoire <b>/proc/devices</b> et <b>struct file_operations \*fops</b> est un pointeur vers la structure <b>file_operations</b> de votre pilote. Un retour négatif de cette fonction signifie que l'enregistrement a échoué. Notez que nous n'avons pas fourni le numéro mineur à cette fonction, pour la simple et bonne raison que le noyau ne se préoccupe pas du numéro mineur. Encore une fois, il n'y a que notre pilote qui gère le numéro mineur.
</p>

<p>
La vraie question maintenant est : comment demander un numéro majeur qui n'est pas déjà utilisé ? Une manière serait de regarder la liste de nos périphériques et d'en choisir un non utilisé. C'est une mauvaise solution parce que vous ne savez pas si le numéro que vous avez choisi ne sera pas utilisé plus tard. La meilleure chose à faire pour régler ce problème est de demander au noyau de vous assigner un numéro majeur dynamiquement.
</p>

<p>
Si vous passez le numéro majeur 0 à la fonction `register_chrdev`, alors la valeur renvoyée sera le numéro majeur qui vous est alloué. L'inconvénient de cette solution est que vous ne pouvez pas créer un fichier de périphérique en avance, puisque vous ne savez pas alors quel numéro majeur vous allez utiliser. Il existe cependant des manières de contourner ce problème. Par exemple, le pilote lui-même peut afficher la valeur assignée, et nous pouvons créer le fichier à la main. Une autre manière de procéder est la suivante : le périphérique fraîchement enregistré aura une ligne dédiée dans le fichier <b>/proc/devices</b>, et on peut soit créer un fichier à la main, soit créer un script shell pour lire ce fichier et ensuite créer le fichier de périphérique correspondant. Une autre méthode est que notre fichier de périphérique soit créé par notre pilote en utilisant la fonction <b>device_create</b> après une insertion réussie, et qu'elle appelle la fonction <b>device_destroy</b>  durant l'appel de la fonction de sortie de votre module.
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Supprimer un périphérique</h3>
<div class="outline-text-3" id="text-6-4">
<p>
On ne peut pas permettre qu'un module noyau soit enlevé du noyau quand le superviseur le souhaite. Si jamais le fichier de périphérique est ouvert par un processus et qu'à ce moment on supprime le module du noyau, alors utiliser ce fichier conduirait à faire un appel d'une fonction (par exemple pour une fonction de lecture/écriture) à une adresse mémoire qui était pointée par le fichier de périphérique avant que ce dernier ne soit supprimé du noyau. Dans le meilleur des cas, vous aurez droit à un message d'erreur. Dans le pire cas, un autre module a été chargé et vous accédez à une autre fonction du noyau et les résultats peuvent être catastrophiques. Dans tous les cas, vous voulez éviter que cette situation arrive.
</p>

<p>
En temps normal, quand vous refusez d'autoriser quelque chose, vous renvoyer un code d'erreur (un chiffre négatif). Mais c'est impossible avec la fonction <b>cleanup_module</b> car celle-ci ne renvoie rien. Cependant, il existe un compteur qui garde une trace de tous les processus qui utilisent votre module. Vous pouvez voir sa valeur en regardant le troisième champ du fichier <b>/proc/modules</b>. Si cette valeur n'est pas nulle, alors la commande <b>rmmod</b> va échouer. Vous n'avez pas cependant à vous en préoccuper dans la fonction <b>cleanup_module</b> car cette vérification est faite pour vous par l'appel système <b>sys_delete_module</b> (défini dans <b>linux/module.c</b>). Vous ne devriez par accéder directement à ce compteur, mais des fonctions définies dans le fichier <b>linux/module.h</b> vous permettent de décrémenter, d'incrémenter ou d'obtenir la valeur de ce compteur :
</p>

<div class="org-src-container">

<pre class="src src-bash">* try_module_get(THIS_MODULE): Incrémente le compteur d'utilisation.
* module_put(THIS_MODULE): Decrémente le compteur d'utilisation.
</pre>
</div>

<p>
Il est essentiel de garder ce compteur à jour. Si vous perdez sa valeur correcte, vous ne serez jamais à même de décharger le module, et il ne vous restera plus qu'à redémarrer votre machine. Et je peux vous garantir que ça vous arrivera tôt ou tard durant votre développement.
</p>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">chardev.c</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Le prochain code crée un pilote en mode caractère appelé <b>chardev</b>.
Vous pouvez lire son fichier de périphérique via la commande suivante :
</p>

<div class="org-src-container">

<pre class="src src-bash">cat /proc/devices
</pre>
</div>

<p>
Et le pilote vous renverra le nombre de fois que le fichier de périphérique a été lu. Notre module ne gère pas l'écriture vers notre fichier (tel que <b>echo "hi" &gt; /dev/hello</b>), mais il prend en compte ces essais et informe l'utilisateur que cette opération n'est pas gérée. Ne vous inquiétez pas si vous ne savez pas comment gérer le tampon lors d'une écriture sur notre fichier, ce n'est pas notre problème. On ne fait ici que lire une donnée et afficher un accusé de réception.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  chardev.c: Cr&#233;e un p&#233;riph&#233;rique de type caract&#232;re en mode lecture-seule</span>
<span class="org-comment"> *  qui contient le nombre de lecture du fichier dev</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/device.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/uaccess.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/io.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/poll.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/cdev.h&gt;</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  Prototypes - Dans le meilleur des mondes, contenu dans un fichier .h</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>);
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>);
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *, <span class="org-keyword">struct</span> <span class="org-type">file</span> *);
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-type">char</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *, <span class="org-keyword">const</span> <span class="org-type">char</span> *, <span class="org-type">size_t</span>, <span class="org-type">loff_t</span> *);

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SUCCESS</span> 0
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_NAME</span> <span class="org-string">"chardev"</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Nom du p&#233;riph&#233;rique tel qu'il apparait</span>
<span class="org-comment">                                 * dans in /proc/devices </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">BUF_LEN</span> 80              <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille maximum du message lu depuis le</span>
<span class="org-comment">                                 * p&#233;riph&#233;rique. </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Les variables globales sont d&#233;clar&#233;es statiques, et sont donc globales aux</span>
<span class="org-comment"> * yeux du code contenu dans le fichier.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> Major;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#233;ro majeur attribu&#233; &#224; notre pilote </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Device_Open</span> = 0;     <span class="org-comment-delimiter">/* </span><span class="org-comment">Le fichier est-il d&#233;j&#224; ouvert ?       *</span>
<span class="org-comment">                                 * Variable utilis&#233;e pour &#233;viter les     *</span>
<span class="org-comment">                                 * acc&#232;s concurrents au p&#233;riph&#233;riques    </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">msg</span>[BUF_LEN];       <span class="org-comment-delimiter">/* </span><span class="org-comment">La r&#233;ponse du p&#233;riph&#233;rique en cas de  *</span>
<span class="org-comment">                                 * lecture                               </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">msg_Ptr</span>;

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">class</span> *<span class="org-variable-name">cls</span>;

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">chardev_fops</span> = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#233;e au chargement du module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    Major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);

    <span class="org-keyword">if</span> (Major &lt; 0) {
        pr_alert(<span class="org-string">"Registering char device failed with %d\n"</span>, Major);
        <span class="org-keyword">return</span> Major;
    }

    pr_info(<span class="org-string">"I was assigned major number %d.\n"</span>, Major);

    cls = class_create(THIS_MODULE, DEVICE_NAME);
    device_create(cls, <span class="org-constant">NULL</span>, MKDEV(Major, 0), <span class="org-constant">NULL</span>, DEVICE_NAME);

    pr_info(<span class="org-string">"Device created on /dev/%s\n"</span>, DEVICE_NAME);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#233;e au d&#233;chargement du module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Supprime le p&#233;riph&#233;rique</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    unregister_chrdev(Major, DEVICE_NAME);
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonctions :</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233;e quand un processus essaie d'ouvrir le fichier du p&#233;roph&#233;rique</span>
<span class="org-comment"> * par exemple "cat /dev/mycharfile"</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">counter</span> = 0;

    <span class="org-keyword">if</span> (Device_Open)
        <span class="org-keyword">return</span> -EBUSY;

    Device_Open++;
    sprintf(msg, <span class="org-string">"I already told you %d times Hello world!\n"</span>, counter++);
    msg_Ptr = msg;
    try_module_get(THIS_MODULE);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233;e quand un processus ferme le fichier associ&#233; au p&#233;riph&#233;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    Device_Open--; <span class="org-comment-delimiter">/* </span><span class="org-comment">Nous sommes maintenant pr&#234;t pour l'appel suivant </span><span class="org-comment-delimiter">*/</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * D&#233;cr&#233;mente le compteur d'utilisation du fichier,</span>
<span class="org-comment">     * sans quoi une fois que vous aurez ouvert votre</span>
<span class="org-comment">     * fichier, vous ne pourrez plus jamais d&#233;charger</span>
<span class="org-comment">     * votre module</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    module_put(THIS_MODULE);

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233;e quand un processus, qui a d&#233;j&#224; ouvert le fichier, essaie de lire</span>
<span class="org-comment"> * son contenu.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">Voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">Tampon &#224; remplir         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille du tampon         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nombres d'octets &#233;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">int</span> <span class="org-variable-name">bytes_read</span> = 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si la t&#234;te de lecture atteint la fin du message,</span>
<span class="org-comment">     * Renvoyer la valeur 0 signifie la "fin du fichier"</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (*msg_Ptr == 0)
        <span class="org-keyword">return</span> 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Insertion des donn&#233;es dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (length &amp;&amp; *msg_Ptr) {

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Le tampon est dans l'espace m&#233;moire de l'utilisateur, mais pas</span>
<span class="org-comment">         * dans l'espace noyau. C'est pourquoi l'assignement via pointeur '*'</span>
<span class="org-comment">         * ne fonctionnera pas. Nous devons donc utiliser la fonction put_user</span>
<span class="org-comment">         * qui copie des donn&#233;es depuis l'espace noyau vers l'espace</span>
<span class="org-comment">         * utilisateur.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        put_user(*(msg_Ptr++), buffer++);

        length--;
        bytes_read++;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La plupart des fonctions de lecture renvoient le nombre d'octets</span>
<span class="org-comment">     * &#233;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> bytes_read;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233;e quand un processus &#233;crit dans le fichier associ&#233; au p&#233;riph&#233;rique</span>
<span class="org-comment"> * par exemple: echo "hi" &gt; /dev/hello</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>,
                            <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buff</span>,
                            <span class="org-type">size_t</span> <span class="org-variable-name">len</span>,
                            <span class="org-type">loff_t</span> * <span class="org-variable-name">off</span>)
{
    pr_alert(<span class="org-string">"Sorry, this operation isn't supported.\n"</span>);
    <span class="org-keyword">return</span> -EINVAL;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Ecrire des modules pour plusieurs versions du noyau.</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Les appels système, qui font l'interface primaire entre le noyau et les processus, restent généralement similaires selon les versions de Linux. Un nouvel appel système peut être rajouté, mais, sauf exception rarissime, les appels système déjà implantés ne seront pas modifiés. Cette stratégie est nécessaire pour la compatibilité; une nouvelle version Linux doit faire fonctionner des processus créés pour une version plus vieille. Dans la plupart des cas, les fichiers de périphérique resteront les mêmes. Cependant, les interfaces internes au noyau peuvent changer entre chaque version.
</p>

<p>
Les versions du noyau sont définies par trois numéros x.y.z. Le numéro x représente le numéro majeur, le numéro y représente le numéro mineur et le numéro z représente la correction. Le numéro x n'est qu'un symbole et deux versions différentes n'impliquent pas nécessairement un changement profond du noyau. Ainsi, le changement du noyau de la version 2.6 en 3.0 n'a rien apporté de révolutionnaire au noyau, alors que le changement de version 2.4 en 2.6 a, lui, apporté beaucoup de changement, sans que le numéro majeur ne change.
</p>

<p>
Les versions mineures du noyau Linux sont divisées entre les versions stables (y est un numéro pair) et les versions de développements (y est un numéro impair). Ces dernières contiennent toutes les idées originales, y compris celles qui seront par la suite reconsidérées comme des erreurs, ou qui seront modifiées. Par conséquent, si vous travaillez avec ces versions instables, sachez que les interfaces sur lesquelles vous travaillez risquent de changer, c'est pourquoi vous ne pouvez donc pas trop compter sur elles. C'est la raison pour laquelle je ne traiterai pas ces versions instables dans ce livre : elles impliquent trop de changement qui ne seront qu'éphémères et ça conduirait à trop de travail pour mettre à jour ce livre. Les versions stables cependant reposent sur une interface immuable, quel que soit le numéro de correction (le numéro z).
</p>

<p>
Différentes versions du noyau impliquent de multiples disparités, et si vous souhaitez créer du code qui soit compatible avec de nombreuses versions du noyau, vous devrez alors utiliser des consignes conditionnelles de compilation. La manière de procéder et de comparer deux macros : LINUX_VERSION_CODE et KERNEL_VERSION. Pour une version du noyau x.y.z, la valeur de cette macro sera (x\*(2^16))+(y\*(2^8))+z.
</p>

<p>
Les versions précédentes de ce guide vous montraient précisément comment écrire du code compatible avec des versions antérieures, mais nous avons décidé de briser cette tradition. Les lecteurs désireux d'un tel savoir devraient donc lire une version de ce guide qui corresponde à leur noyau. On a donc décidé d'une gestion de version pour ce guide identique au noyau (en ce qui concerne les numéros majeurs et mineurs). En ce qui concerne les correctifs, nous utilisons nos propres correctifs indépendamment du noyau. Si vous cherchez un guide pour le noyau 2.6.39, vous devrez donc chercher le guide dans sa version 2.6.z (le numéro de correction importe peu). Assurez-vous juste d'avoir le correctif le plus à jour du guide, et du noyau.
</p>

<p>
Vous aurez peut-être remarqué que certaines versions du noyau comportent quatre numéros de versions. Dans ce cas, les trois premières versions ont le même sens qu'avant, mais la quatrième indique des mises à jours de sécurité, en attendant qu'un correctif stable sorte.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Le système de fichier /proc</h2>
<div class="outline-text-2" id="text-7">
<p>
Dans Linux, il y existe des mécanismes pour que le noyau et ses modules envoient des informations aux processus : le système de fichier /proc. À l'origine créé pour permettre un accès aisé aux informations des processus (d'où le nom), ce mécanisme est désormais utilisé de toute part dans le noyau quand ce dernier doit signaler quelque chose, tel que <b>proc/modules</b>, qui fournit la liste des modules, ou <b>proc/meminfo</b> qui affiche des statistiques d'utilisation de la mémoire.
</p>

<p>
La manière d'utiliser le système de fichier proc est similaire à la méthode utilisée avec les pilotes de périphériques : une structure est créée, laquelle contient toutes les informations requises par le fichier <b>/proc</b>, y compris des pointeurs vers les fonctions qui vont gérer notre fichier (dans notre cas, il n'existe qu'un pointeur : celui qui est appelé quand un programme essaie de lire le fichier <b>/proc</b>). Ensuite, init_module enregistre la structure au sein du noyau et cleanup_module la supprime.
</p>

<p>
Un système de fichier standard décrira des documents qui seront localisés sur le disque plutôt qu'en mémoire (contrairement au système de fichier <b>/proc</b>).  Dans le cas d'un fichier sur le disque, l'index du noeud (inode) contiendra un pointeur vers la position, au sein du disque, où le fichier décrit par l'inode est localisé. L'inode possède également certaines informations relatives au fichier, tel que les permissions du fichier.
</p>

<p>
Parce qu'aucun code ne sera appelé quand le fichier sera ouvert, ou fermé, on ne peut mettre en place les fonctions try_module_get et try_module_put dans notre module. C'est pourquoi il n'existe aucun moyen d'éviter les conséquences, si un fichier est ouverte, puis que le module est enlevé du noyau.
</p>

<p>
Voilà un exemple élémentaire qui vous montre comment utiliser un fichier <b>/proc</b>. C'est le "HelloWorld" du système de fichier <b>/proc</b>. Cette méthode contient trois parties. La première, c'est de créer le fichier <b>/proc/helloworld</b> dans la fonction init_module. La seconde, c'est de renvoyer une valeur (et un tampon) quand le fichier <b>/proc/helloworld</b> est lu, via la fonction de rappel <b>procfile_read</b>. La troisième, c'est de supprimer le fichier <b>/proc/helloworld</b> dans la fonction cleanup_module.
</p>

<p>
Le fichier <b>/proc/helloworld</b> sera créé via la fonction <b>proc_create</b> quand le module sera chargé. La valeur renvoyée est une <b>struct proc_dir_entry</b>, et elle sera utilisée pour configurer le fichier <b>/proc/helloworld</b> (par exemple, pour y inscrire le propriétaire du fichier). Une valeur nulle renvoyée signifie que la création a échoué.
</p>

<p>
À chaque fois que le fichier <b>/proc/helloworld</b> sera lu, alors la fonction <b>procfile_read</b> sera appelée. Deux paramètres de cette function sont très importants : le tampon (le premier paramètre) et le curseur (le troisième paramètre). Ainsi, sera modifié le contenu du tampon passé par le processus lecteur du fichier (par exemple, une commande cat) en fonction du curseur, qui désigne la position actuelle de la tête de lecture au sein du fichier. Attention cependant, si la fonction ne renvoie pas une valeur nulle, alors cette fonction sera rappelée. Ainsi, si cette fonction ne renvoie jamais 0, alors cette fonction sera appelée en boucle infiniment.
</p>

<div class="org-src-container">

<pre class="src src-txt"># cat /proc/helloworld
HelloWorld!
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> procfs1.c</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">procfs_name</span> <span class="org-string">"helloworld"</span>

<span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Notre Fichier Proc </span><span class="org-comment-delimiter">*/</span>


<span class="org-type">ssize_t</span> <span class="org-function-name">procfile_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filePointer</span>,<span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                      <span class="org-type">size_t</span> <span class="org-variable-name">buffer_length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>=0;
    <span class="org-keyword">if</span>(strlen(buffer) ==0) {
        pr_info(<span class="org-string">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span class="org-string">"HelloWorld!\n"</span>,<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>));
        ret=<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>);
    }
    <span class="org-keyword">return</span> ret;

}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_file_fops</span> = {
    .owner = THIS_MODULE,
    .read  = procfile_read,
};

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(procfs_name,0644,<span class="org-constant">NULL</span>,&amp;proc_file_fops);
    <span class="org-keyword">if</span>(<span class="org-constant">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span class="org-string">"Error:Could not initialize /proc/%s\n"</span>,procfs_name);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    pr_info(<span class="org-string">"/proc/%s created\n"</span>, procfs_name);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span class="org-string">"/proc/%s removed\n"</span>, procfs_name);
}
</pre>
</div>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Lire et écrire un fichier /proc</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Nous avons vu un exemple rudimentaire d'un fichier /proc, <b>/proc/helloworld</b>, qu'on ne pouvait que lire. Mais il est également possible d'écrire au sein d'un fichier /proc file. De la même manière qu'une lecture, une fonction est appelée quand une écriture est demandée sur le fichier /proc. Mais il existe une légère différence avec la fonction de lecture, où les données viennent de l'espace utilisateur, et vous devez donc importer ces données depuis l'espace utilisateur vers l'espace noyau (grâce aux fonctions copy_from_user ou get_user).
</p>

<p>
La raison pour laquelle l'usage de la fonction copy_from_user ou get_user est nécessaire vient du fait qu'au sein de Linux, la mémoire est segmentée (en tout cas pour les architectures Intel, mais ceci peut être différent sur d'autres processeurs). Ce qui signifie qu'un pointeur, ne référence pas une location dans la mémoire, mais une location dans un segment de la mémoire, et vous devez savoir à quel segment il appartient. Il existe un segment mémoire pour le noyau, et un segment mémoire pour chaque processus.
</p>

<p>
Un processus n'a accès qu'à son propre segment mémoire, afin qu'à l'écriture d'un simple programme à lancer en tant que processus, le développeur n'ait pas à se préoccuper des segments mémoires. Quand vous écrivez un noyau module, vous cherchez la plupart du temps à accéder au segment mémoire du noyau, lequel est géré par le système. Cependant, quand le contenu d'un tampon mémoire doit être passé d'un segment mémoire à un autre, en l'occurrence du processus en train de tourner vers le noyau, alors la fonction du noyau reçoit un pointeur vers un espace du segment mémoire du processus qui le demande. Les macros put_user et get_user permettent au noyau d'accéder à ce segment mémoire. Ces fonctions ne gèrent qu'un seul caractère. Vous pouvez maniez plusieurs caractères avec les fonctions copy_to_user et copy_from_user. Comme le tampon (dans une fonction de lecture ou d'écriture) est situé dans le segment mémoire du noyau, vous n'avez pas besoin de gérer ces différents espaces dans le cas d'une lecture, car les données sont déjà dans l'espace noyau. Cependant, dans le cas d'une écriture, vous aurez besoin d'importer ces données car elles viennent de l'espace utilisateur.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-doc">/**</span>
<span class="org-doc"> *  procfs2.c -  Cr&#233;&#233; un "fichier"</span>
<span class="org-doc"> */</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire parce qu'on utilise le proc fs  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour la fonction copy_from_user </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_MAX_SIZE</span>         1024
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_NAME</span>             <span class="org-string">"buffer1k"</span>

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette structure contient les informatiosn relative au fichier /proc</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Notre Fichier Proc </span><span class="org-comment-delimiter">*/</span>

<span class="org-doc">/**</span>
<span class="org-doc"> * Le tampon qui contiendra les caract&#232;res pour ce module</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">procfs_buffer</span>[PROCFS_MAX_SIZE];

<span class="org-doc">/**</span>
<span class="org-doc"> * La taille du tampon</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">procfs_buffer_size</span> = 0;

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e quand le fichier /proc est lu</span>
<span class="org-doc"> */</span>
<span class="org-type">ssize_t</span> <span class="org-function-name">procfile_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filePointer</span>,<span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                      <span class="org-type">size_t</span> <span class="org-variable-name">buffer_length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>=0;
    <span class="org-keyword">if</span>(strlen(buffer) ==0) {
        pr_info(<span class="org-string">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span class="org-string">"HelloWorld!\n"</span>,<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>));
        ret=<span class="org-keyword">sizeof</span>(<span class="org-string">"HelloWorld!\n"</span>);
    }
    <span class="org-keyword">return</span> ret;
}


<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e quand on &#233;crit dans le fichier /proc</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfile_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buff</span>,
                              <span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">off</span>)
{
    procfs_buffer_size = len;
    <span class="org-keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;

    <span class="org-keyword">if</span> (copy_from_user(procfs_buffer, buff, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;

    procfs_buffer[procfs_buffer_size] = <span class="org-string">'\0'</span>;
    <span class="org-keyword">return</span> procfs_buffer_size;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">proc_file_fops</span> = {
    .owner = THIS_MODULE,
    .read  = procfile_read,
    .write  = procfile_write,
};

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e quand le module est charg&#233;</span>
<span class="org-doc"> */</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_NAME,0644,<span class="org-constant">NULL</span>,&amp;proc_file_fops);
    <span class="org-keyword">if</span>(<span class="org-constant">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span class="org-string">"Error:Could not initialize /proc/%s\n"</span>,PROCFS_NAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    pr_info(<span class="org-string">"/proc/%s created\n"</span>, PROCFS_NAME);
    <span class="org-keyword">return</span> 0;
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e quand le module est d&#233;charg&#233;</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span class="org-string">"/proc/%s enleve\n"</span>, PROCFS_NAME);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Gérer un fichier /proc avec un système de fichier standard</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Nous avons vu comment lire et écrire dans un fichier /proc, avec l'interface du système de fichier proc. Mais il est également possible de gérer un fichier /proc avec des inodes. Pour cela, il faut utiliser des fonctions avancées, telles que les permissions.
</p>

<p>
Dans Linux, il existe un mécanisme standard pour l'enregistrement des systèmes de fichiers. Comme chaque système de fichier doit avoir ses propres fonctions pour gérer les inodes et les opérations sur les fichiers, il existe une structure particulière qui contient les pointeurs vers toutes ces fonctions, à savoir struct <b>inode_operations</b>, laquelle inclut un pointeur vers une struct file_operations.
</p>

<p>
La différence entre une opération sur une inode et une opération sur un fichier tient au fait qu'une opération sur un fichier intervient sur le fichier lui-même, alors qu'une opération sur son inode n'interagit avec le référencement du fichier, tel que la création de liens vers le fichier.
</p>

<p>
Dans /proc, quand nous enregistrons un nouveau fichier, nous pouvons spécifier quelle structure inode_operations sera utilisée pour interagir avec le fichier. Cette dernière contient un pointeur vers une structure file_operations, qui elle-même contient des pointeurs vers nos fonctions procfs_read et procfs_write.
</p>

<p>
Une autre partie intéressante est la fonction module_permission. Cette dernière est appelée quand un processus essaie d'accéder à notre fichier /proc. Cette fonction accorde ou refuse la permission d'accéder à notre fichier. Pour l'instant, cette décision n'est basée que sur l'opération demandée et le numéro de l'utilisateur (qu'on peut connaître via un pointeur vers une structure qui contient toutes les informations sur le processus qui tourne actuellement), mais on pourrait baser cette décision sur toutes les conditions que l'on souhaite, telles que l'heure, ce que d'autres processus font avec ce fichier, les dernières données qu'on a reçues, ou bien d'autres encore.
</p>

<p>
Il faut également noter que les rôles des fonctions de lecture et d'écriture sont inversés dans le noyau. En effet, une fonction de lecture doit renvoyer une valeur lue, alors qu'une fonction d'écriture doit recevoir des données à écrire. La fonction de lecture envoie des données, l'écriture en reçoit. La raison pour laquelle cette notion est inversée vient du fait que par convention, les fonctions de lecture et d'écriture sont nommées du point de vue de l'utilisateur. Si un processus utilisateur veut lire une information via le noyau, ce dernier doit renvoyer cette information à l'utilisateur, et inversement.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment">    procfs3.c</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_MAX_SIZE</span>         2048
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROCFS_ENTRY_FILENAME</span>   <span class="org-string">"buffer2k"</span>

<span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>;
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">procfs_buffer</span>[PROCFS_MAX_SIZE];
<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">procfs_buffer_size</span> = 0;

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfs_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>, <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">offset</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">finished</span> = 0;
    <span class="org-keyword">if</span>(finished)
    {
        pr_debug(<span class="org-string">"procfs_read: END\n"</span>);
        finished = 0;
        <span class="org-keyword">return</span> 0;
    }
    finished = 1;
    <span class="org-keyword">if</span>(copy_to_user(buffer, procfs_buffer, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;
    pr_debug(<span class="org-string">"procfs_read: read %lu bytes\n"</span>, procfs_buffer_size);
    <span class="org-keyword">return</span> procfs_buffer_size;
}
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">procfs_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,  <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buffer</span>,
                            <span class="org-type">size_t</span> <span class="org-variable-name">len</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">off</span>)
{
    <span class="org-keyword">if</span>(len&gt;PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;
    <span class="org-keyword">else</span>
        procfs_buffer_size = len;
    <span class="org-keyword">if</span>(copy_from_user(procfs_buffer, buffer, procfs_buffer_size))
        <span class="org-keyword">return</span> -EFAULT;
    pr_debug(<span class="org-string">"procfs_write: write %lu bytes\n"</span>, procfs_buffer_size);
    <span class="org-keyword">return</span> procfs_buffer_size;
}
<span class="org-type">int</span> <span class="org-function-name">procfs_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    try_module_get(THIS_MODULE);
    <span class="org-keyword">return</span> 0;
}
<span class="org-type">int</span> <span class="org-function-name">procfs_close</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    module_put(THIS_MODULE);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">File_Ops_4_Our_Proc_File</span> = {
    .read       = procfs_read,
    .write      = procfs_write,
    .open       = procfs_open,
    .release    = procfs_close,
};

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_ENTRY_FILENAME, 0644, <span class="org-constant">NULL</span>,&amp;File_Ops_4_Our_Proc_File);
    <span class="org-keyword">if</span>(Our_Proc_File == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Erreur : Impossible d'initialiser /proc/%s\n"</span>, PROCFS_ENTRY_FILENAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_debug(<span class="org-string">"/proc/%s cree\n"</span>, PROCFS_ENTRY_FILENAME);
    <span class="org-keyword">return</span> 0;
}
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s removed\n"</span>, PROCFS_ENTRY_FILENAME);
}
</pre>
</div>

<p>
Si vous souhaitez en apprendre plus sur le système de fichier procfs, sachez que procfs a été rendu obsolète et qu'il est maintenant conseillé d'utiliser sysfs (que nous verrons dans un prochain chapitre). Si malgré tout vous souhaitez en apprendre plus, il existe une documentation que je vous recommande pour le système de fichier procfs au sein de linux/Documentation/DocBook/. Utilisez la commande make help à la racine de vos sources Linux pour apprendre comment convertir ces informations dans votre format de prédilection. Par exemple : make htmldocs. Je vous conseille d'utiliser ce mécanisme si vous souhaitez documenter des informations relatives au noyau.
</p>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Gérer un fichier /proc avec seq_file</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Comme vous l'avez remarqué, créer un fichier /proc tient plus du parcours du combattant que de la balade enfantine. C'est pourquoi une API appelée seq_file a été implantée, afin d'aider les programmeurs. Le principe d'utilisation de cette API repose sur des séquences, qui sont composées de trois fonctions : start(), next(), et stop(). L'API seq_file commencera une séquence quand le fichier /proc associé sera lu.
</p>

<p>
Une séquence commence avec l'appel à la fonction start(). Si la valeur renvoyée est non nulle, alors la fonction next() est appelée. Cette fonction est un itérateur. Son but est de parcourir les données de notre fichier. À chaque fois que la fonction next() est appelée, la fonction show() l'est également. Cette dernière écrit la valeur des données lues dans le tampon lu par l'utilisateur. La fonction next() est appelée continuellement jusqu'à ce qu'elle renvoie une valeur nulle. Quand la fonction next renvoie une valeure nulle, alors la séquence se termine par l'appel à la fonction stop().
</p>

<p>
Attention cependant : Quand une séquence se termine, une autre est lancée. Ce qui signifie quà la fin de la fonction stop(), la fonction start() est rappelée. Cette boucle se termine quand la fonction start() renvoie une valeur nulle. Vous pouvez voir un schéma décrivant le comportement décrit plus haut intitulé "Comment seq_file fonctionne".
</p>


<div class="figure">
<p><img src="img/seq_file.png" alt="seq_file.png" />
</p>
</div>

<p>
Seq_file fournit des fonctions basiques pour la structure file_operations, telles que seq_read, seq_lseek ou d'autres. Mais aucune fonction n'est fournit pour écrire dans notre fichier. Vous pouvez bien sûr utiliser les mêmes méthodes que dans notre exemple précédent pour le faire.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-doc">/**</span>
<span class="org-doc"> *  procfs4.c -  Cree un "fichier" dans /proc</span>
<span class="org-doc"> *      Ce programme utilise la biblioth&#232;que seq_file pour g&#233;rer</span>
<span class="org-doc"> *      le fichier /proc</span>
<span class="org-doc"> */</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span>      <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour utiliser le proc fs </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/seq_file.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour seq_file </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROC_NAME</span>       <span class="org-string">"iter"</span>

MODULE_AUTHOR(<span class="org-string">"Philippe Reynes"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e au d&#233;but d'une s&#233;quence, par exemple quand :</span>
<span class="org-doc"> *      - Le fichier /proc est lu (pout la premi&#232;re fois)</span>
<span class="org-doc"> *      - A la fin de la la fonction stop (fin de s&#233;quence)</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> *<span class="org-function-name">my_seq_start</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">pos</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">counter</span> = 0;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Est-ce qu'on commande une nouvelle s&#233;quence ? </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> ( *pos == 0 ) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Si oui =&gt; Renvoie une valeur non nulle pour d&#233;marrer la s&#233;quence </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">return</span> &amp;counter;
    }
    <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Sinon =&gt; Signifie la fin de la s&#233;quence, renvoie NULL pour</span>
<span class="org-comment">         * arr&#234;ter la lecture</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        *pos = 0;
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e apr&#232;s le d&#233;but la s&#233;quence.</span>
<span class="org-doc"> * Elle est appel&#233;e en boucle jusqu'&#224; ce qu'elle renvoie la valeur NULL.</span>
<span class="org-doc"> * Cette valeur signifie la fin de la s&#233;quence.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> *<span class="org-function-name">my_seq_next</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>, <span class="org-type">loff_t</span> *<span class="org-variable-name">pos</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> *<span class="org-variable-name">tmp_v</span> = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)v;
    (*tmp_v)++;
    (*pos)++;
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Cette fonction est appel&#233;e &#224; la fin de la s&#233;quence.</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">my_seq_stop</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Rien &#224; faire, on utilise une variable</span>
<span class="org-comment">     * statique dans la fonction start()</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#233;e &#224; chaque &#233;tape d'une s&#233;quence.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">my_seq_show</span>(<span class="org-keyword">struct</span> <span class="org-type">seq_file</span> *<span class="org-variable-name">s</span>, <span class="org-type">void</span> *<span class="org-variable-name">v</span>)
{
    <span class="org-type">loff_t</span> *<span class="org-variable-name">spos</span> = (<span class="org-type">loff_t</span> *) v;

    seq_printf(s, <span class="org-string">"%Ld\n"</span>, *spos);
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure d&#233;finit les fonctions qui g&#232;reront la s&#233;quence</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">seq_operations</span> <span class="org-variable-name">my_seq_ops</span> = {
        .start = my_seq_start,
        .next  = my_seq_next,
        .stop  = my_seq_stop,
        .show  = my_seq_show
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#233;e quand le fichier /proc sera ouvert</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">my_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-keyword">return</span> seq_open(file, &amp;my_seq_ops);
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure d&#233;finit les fonctions qui g&#233;reront le fichier /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">my_file_ops</span> = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = seq_release
};


<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#233;e quand le module sera charg&#233;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>(<span class="org-type">void</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">entry</span>;

    entry = proc_create(PROC_NAME, 0, <span class="org-constant">NULL</span>, &amp;my_file_ops);
    <span class="org-keyword">if</span>(entry == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROC_NAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Error: Could not initialize /proc/%s\n"</span>, PROC_NAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#233;e quand le module sera d&#233;charg&#233; du noyau</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>(<span class="org-type">void</span>)
{
    remove_proc_entry(PROC_NAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s supprime\n"</span>, PROC_NAME);
}
</pre>
</div>

<p>
Si vous désirez plus d'informations, je vous conseille ce lien :
</p>

<ul class="org-ul">
<li><a href="http://lwn.net/Articles/22355/">http://lwn.net/Articles/22355/</a>
</li>

<li><a href="http://www.kernelnewbies.org/documents/seq_file_howto.txt">http://www.kernelnewbies.org/documents/seq_file_howto.txt</a>
</li>
</ul>

<p>
Vous pouvez également lire le code de fs/seq_file.c au sein du noyau.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">sysfs : Interagissez avec votre module</h2>
<div class="outline-text-2" id="text-8">
<p>
<i>sysfs</i> vous permet d'interagir avec le noyau depuis l'espace utilisateur, via la lecture ou l'écriture de variable au sein de modules. Ça peut être très utile à des fins de débogage, ou encore cela peut vous servir d'interface pour vos applications ou vos scripts. Vous pouvez trouvez des répertoires et des fichiers sysfs au sein du répertoire <i>sys</i> de votre système.
</p>

<div class="org-src-container">

<pre class="src src-bash">ls -l /sys
</pre>
</div>

<p>
L'éternel exemple du module hello world incluant la création d'une variable accessible via sysfs est fourni plus bas :
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * hello-sysfs.c sysfs example</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kobject.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sysfs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/string.h&gt;</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">mymodule</span>;

<span class="org-comment-delimiter">/* </span><span class="org-comment">La variable que vous souhaitez pouvoir modifier </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">myvariable</span> = 0;

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">myvariable_show</span>(<span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">kobj</span>,
                               <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> *<span class="org-variable-name">attr</span>,
                               <span class="org-type">char</span> *<span class="org-variable-name">buf</span>)
{
    <span class="org-keyword">return</span> sprintf(buf, <span class="org-string">"%d\n"</span>, myvariable);
}

<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">myvariable_store</span>(<span class="org-keyword">struct</span> <span class="org-type">kobject</span> *<span class="org-variable-name">kobj</span>,
                                <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> *<span class="org-variable-name">attr</span>,
                                <span class="org-type">char</span> *<span class="org-variable-name">buf</span>, <span class="org-type">size_t</span> <span class="org-variable-name">count</span>)
{
    sscanf(buf, <span class="org-string">"%du"</span>, &amp;myvariable);
    <span class="org-keyword">return</span> count;
}


<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">kobj_attribute</span> <span class="org-variable-name">myvariable_attribute</span> =
    __ATTR(myvariable, 0660, myvariable_show,
           (<span class="org-type">void</span>*)myvariable_store);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> mymodule_init (<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">error</span> = 0;

    pr_info(<span class="org-string">"mymodule: initialised\n"</span>);

    mymodule =
        kobject_create_and_add(<span class="org-string">"mymodule"</span>, kernel_kobj);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>mymodule)
        <span class="org-keyword">return</span> -ENOMEM;

    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr);
    <span class="org-keyword">if</span> (error) {
        pr_info(<span class="org-string">"failed to create the myvariable file "</span> \
               <span class="org-string">"in /sys/kernel/mymodule\n"</span>);
    }

    <span class="org-keyword">return</span> error;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> mymodule_exit (<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"mymodule: Exit success\n"</span>);
    kobject_put(mymodule);
}

<span class="org-function-name">module_init</span>(mymodule_init);
<span class="org-function-name">module_exit</span>(mymodule_exit);
</pre>
</div>

<p>
Créez et installez votre module :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
sudo insmod hello-sysfs.ko
</pre>
</div>

<p>
Vérifiez qu'il existe :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo lsmod | grep hello_sysfs
</pre>
</div>

<p>
Quelle est la valeur de <i>myvariable</i> ?
</p>

<div class="org-src-container">

<pre class="src src-sh">cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Modifiez la valeur de <i>myvariable</i> et vérifiez qu'elle a changée
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">echo</span> <span class="org-string">"32"</span> &gt; /sys/kernel/mymodule/myvariable
cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Finalement, supprimez ce module exemple :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod hello_sysfs
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Interagir avec un fichier de périphérique</h2>
<div class="outline-text-2" id="text-9">
<p>
Les fichiers de périphériques sont censés représenter des périphériques physiques. La plupart de ces périphériques physiques sont utilisés aussi bien en lecture qu'en écriture, il existe donc des mécanismes pour que le pilote du périphérique concerné reçoive des informations du processus qui souhaite écrire dans le périphérique. Ce mécanisme est réalisé en ouvrant le fichier du périphérique pour une écriture, et en écrivant dedans, tout comme vous écririez dans un simple fichier. Dans l'illustration suivante, un exemple vous est donné via la fonction device_write.
</p>

<p>
Mais ce n'est pas suffisant. Imaginez que vous disposez d'un port série, lequel est connecté à une carte réseau (même si vous avez une carte réseau intégrée dans votre carte mère, celle-ci est implantée, du point de vue du processeur, comme un port série connecté à une carte réseau, vous n'aurez donc pas à pousser loin votre imagination). Le comportement qui pourra vous sembler naturel sera d'utiliser le fichier de périphérique du port série vers la carte réseau pour y écrire (soit des ordres pour commander la carte réseau, soit des données à transmettre sur la ligne) ou pour y lire des informations depuis la carte réseau (soit les réponses des commandes, soit des données reçues depuis la ligne). Vous avez réglé le problème, mais la question reste ouverte de savoir comment vous ferez quand vous souhaiterez interagir avec le port-série lui-même, par exemple pour définir à quelle fréquence il doit recevoir et envoyer des données.
</p>

<p>
La réponse au sein d'Unix est d'utiliser une fonction spéciale appelée <b>ioctl</b> (raccourci pour Input Output ConTrol). Chaque périphérique a ses propres commandes ioctl, qui peuvent être soit en lecture (envoyer des informations du processus vers le noyau), soit en écriture (renvoyer les informations Au processus), soit les deux, soit aucune des deux. Vous noterez qu'ici, les rôles des fonctions de lecture et d'écritures sont inversées une fois de plus. Ainsi avec les ioctl, la lecture consiste à envoyer des informations vers le noyau, et l'écriture consiste à recevoir des informations du noyau.
</p>

<p>
Les fonctions ioctl sont appelées avec trois paramètres : le file descriptor du fichier de périphérique approprié, le numéro d'ioctl, et un paramètre de type long afin que vous puissiez le caster pour passer l'adresse de tout ce que vous souhaitez.
</p>

<p>
Le numéro de l'ioctl est une valeur formatée qui contient le numéro majeur de votre périphérique, le type de l'ioctl, la commande, et le type de votre paramètre. Le numéro d'ioctl est habituellement créé dans une fichier d'en-tête via un appel de macro (\_IO, \_IOR, \_IOW ou \_IOWR , en fonction du type). Ce fichier d'entête devra ensuite également être inclus à la fois par le programme utilisateur qui va employer l'ioctl (afin qu'il puisse générer un numéro correct), et par le module (afin qu'il puisse comprendre ce numéro). Dans l'exemple suivant, le fichier d'en-tête est chardev.h et le programme utilisateur qui exécute l'ioctl est ioctl.c
</p>

<p>
Si vous souhaitez utiliser les ioctls pour votre propre module, la meilleure manière est de demander un numéro officiel, ainsi vous ne risquez pas de partager votre numéro avec un autre, dans quel cas le résultat pourrait être désastreux. Pour plus d'informations, jetez un oeil au fichier Documentation/ioctl-number.txt au sein des sources de votre noyau.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * chardev2.c - Cr&#233;&#233; un p&#233;riph&#233;rique d'entr&#233;e/sortie en mode caract&#232;re</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/fs.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/device.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/uaccess.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/irq.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/io.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/poll.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/cdev.h&gt;</span>

<span class="org-preprocessor">#include</span> <span class="org-string">"chardev.h"</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">SUCCESS</span> 0
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_NAME</span> <span class="org-string">"char_dev"</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">BUF_LEN</span> 80

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Est-ce que le p&#233;riph&#233;rique est</span>
<span class="org-comment"> * actuellement ouvert ?</span>
<span class="org-comment"> * Utilis&#233; pour &#233;viter les acc&#232;s</span>
<span class="org-comment"> * concurrents au m&#234;me p&#233;riph&#233;riques</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Device_Open</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le message que fournira le p&#233;riph&#233;rique quand on lui demandera</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> <span class="org-variable-name">Message</span>[BUF_LEN];

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * O&#249; en est le processus qui lit le message ?</span>
<span class="org-comment"> * Utile si message est plus grand que la taille du tampon &#224; remplir dans</span>
<span class="org-comment"> * la fonction device_read()</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">char</span> *<span class="org-variable-name">Message_Ptr</span>;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">Major</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#233;ro Major associ&#233; au pilote de notre p&#233;riph&#233;rique </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">class</span> *<span class="org-variable-name">cls</span>;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * C'est appel&#233; quand un processus demande une ouverture du fichier associ&#233;</span>
<span class="org-comment"> * &#224; notre p&#233;riph&#233;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
<span class="org-preprocessor">#ifdef</span> DEBUG
        pr_info(<span class="org-string">"device_open(%p)\n"</span>, file);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On ne souhaite pas traiter deux processus concurentiellement</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (Device_Open)
        <span class="org-keyword">return</span> -EBUSY;

    Device_Open++;
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Initialise le message</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Message_Ptr = Message;
    try_module_get(THIS_MODULE);
    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">device_release</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_release(%p,%p)\n"</span>, inode, file);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nous sommes maintenant pr&#234;t pour traiter l'appel suivant</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Device_Open--;

    module_put(THIS_MODULE);
    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction est appel&#233;e quand un processus qui a d&#233;j&#224; ouvert le fichier</span>
<span class="org-comment"> * associ&#233; &#224; notre p&#233;riph&#233;rique demande une lecture de ce dernier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">device_read</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">char</span> <span class="org-variable-name">__user</span> * buffer,        <span class="org-comment-delimiter">/* </span><span class="org-comment">Tampon qui sera  *</span>
<span class="org-comment">                                                         * remplis          </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille du tampon         </span><span class="org-comment-delimiter">*/</span>
                           <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Nombre d'octets r&#233;ellement &#233;crits dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">int</span> <span class="org-variable-name">bytes_read</span> = 0;

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_read(%p,%p,%d)\n"</span>, file, buffer, length);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si on atteint la fin du message, renvoie un 0 pour signifier</span>
<span class="org-comment">     * la fin du fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (*Message_Ptr == 0)
        <span class="org-keyword">return</span> 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Insertion des donn&#233;es dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (length &amp;&amp; *Message_Ptr) {
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Parce que le tampon est dans l'espace utilisateur, et non pas dans</span>
<span class="org-comment">     * l'espace noyau o&#249; nous nous trouvons au moment o&#249; l'on ex&#233;cute ce</span>
<span class="org-comment">     * code, une simple modification de valeur par les variable ne</span>
<span class="org-comment">     * fonctionnerait pas. C'est pourquoi nous devons utiliser la fonction</span>
<span class="org-comment">     * put_user() qui copie des donn&#233;es de l'espace noyau vers l'espace</span>
<span class="org-comment">     * utilisateur</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
     put_user(*(Message_Ptr++), buffer++);
     length--;
     bytes_read++;
}

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"Read %d bytes, %d left\n"</span>, bytes_read, length);
<span class="org-preprocessor">#endif</span>
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La plupart des fonctions de lecture renvoie le nombre d'octets</span>
<span class="org-comment">     * qui ont &#233;t&#233; ins&#233;r&#233; dans le tampon</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> bytes_read;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#233;e quand quelqu'un commandera une &#233;criture</span>
<span class="org-comment"> * dans le fichier associ&#233; &#224; notre p&#233;riph&#233;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span>
<span class="org-function-name">device_write</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,
             <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">__user</span> * buffer, <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

<span class="org-preprocessor">#ifdef</span> DEBUG
    pr_info(<span class="org-string">"device_write(%p,%s,%d)"</span>, file, buffer, length);
<span class="org-preprocessor">#endif</span>

    <span class="org-keyword">for</span> (i = 0; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++)
        get_user(Message[i], buffer + i);

    Message_Ptr = Message;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Une fois n'est pas coutume, nous renvoyons</span>
<span class="org-comment">     * le nombre de caract&#232;res trait&#233;s</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> i;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction sera appel&#233;e quand un processus essaiera de commander</span>
<span class="org-comment"> * un ioctl sur le fichier associ&#233; &#224; notre p&#233;riph&#233;rique. Par rapport aux</span>
<span class="org-comment"> * structures inode et file, on a ici deux param&#232;tres suppl&#233;mentaires :</span>
<span class="org-comment"> * le num&#233;ro de l'ioctl appel&#233; et le param&#232;tre pass&#233; &#224; la fonction ioctl.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Si l'ioctl est en mode &#233;criture, ou lecture/&#233;criture, ce qui implique</span>
<span class="org-comment"> * qu'une valeur sera renvoy&#233;e au processus l'ex&#233;cutant, alors l'appel</span>
<span class="org-comment"> * ioctl renverra la m&#234;me chose que cette fonction.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">long</span> <span class="org-function-name">device_ioctl</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,
                  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">ioctl_num</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">Num&#233;ro de l'appel ioctl    </span><span class="org-comment-delimiter">*/</span>
                  <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">ioctl_param</span>) <span class="org-comment-delimiter">/* </span><span class="org-comment">Param&#232;tre de l'appel ioctl </span><span class="org-comment-delimiter">*/</span>
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> *<span class="org-variable-name">temp</span>;
    <span class="org-type">char</span> <span class="org-variable-name">ch</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Switch en fonction du num&#233;ro de l'appel ioctl</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">switch</span> (ioctl_num) {
    <span class="org-keyword">case</span> IOCTL_SET_MSG:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Re&#231;oit via le param&#232;tre de l'appel ioctl</span>
<span class="org-comment">         * un pointeur vers un message (dans l'espace utilisateur)</span>
<span class="org-comment">         * et le modifie pour qu'il pointe vers le message de notre</span>
<span class="org-comment">         * p&#233;riph&#233;rique.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        temp = (<span class="org-type">char</span> *)ioctl_param;

         <span class="org-comment-delimiter">/*</span>
<span class="org-comment">          * Cherche la taille de notre message</span>
<span class="org-comment">          </span><span class="org-comment-delimiter">*/</span>
         get_user(ch, temp);
         <span class="org-keyword">for</span> (i = 0; ch &amp;&amp; i &lt; BUF_LEN; i++, temp++)
             get_user(ch, temp);

         device_write(file, (<span class="org-type">char</span> *)ioctl_param, i, 0);
         <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> IOCTL_GET_MSG:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Renvoie un message au processus qui demande une lecture</span>
<span class="org-comment">         * Notre param&#232;tre est un pointeur, il faut donc le remplir</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        i = device_read(file, (<span class="org-type">char</span> *)ioctl_param, 99, 0);

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Puis pour faire faire les choses proprement,</span>
<span class="org-comment">         * il faut ins&#233;rer un 0 &#224; la fin du tampon</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        put_user(<span class="org-string">'\0'</span>, (<span class="org-type">char</span> *)ioctl_param + i);
        <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> IOCTL_GET_NTH_BYTE:
        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cette ioctl est &#224; la fois en mode entr&#233;e (ioctl_param)</span>
<span class="org-comment">         * et en mode sortie (la valeur renvoy&#233;e par cette fonction)</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">return</span> Message[ioctl_param];
        <span class="org-keyword">break</span>;
    }

    <span class="org-keyword">return</span> SUCCESS;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;clarations des module </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette structure va contenir les fonctions qui seront appel&#233;es au moment</span>
<span class="org-comment"> * o&#249; un processus agira sur le p&#233;riph&#233;rique qu'on a cr&#233;&#233;. Comme un pointeur</span>
<span class="org-comment"> * vers cette structure est conserv&#233; dans la table des p&#233;riph&#233;riques, ce</span>
<span class="org-comment"> * dernier ne peut pas &#234;tre local &#224; init_module.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * La valeur NULL est assign&#233;e aux fonctions non implant&#233;es.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">Fops</span> = {
        .read = device_read,
        .write = device_write,
        .unlocked_ioctl = device_ioctl,
        .open = device_open,
        .release = device_release,     <span class="org-comment-delimiter">/* </span><span class="org-comment">Fonction de fermeture </span><span class="org-comment-delimiter">*/</span>
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialiser le module - Enregistrer le p&#233;riph&#233;rique de type caract&#232;re</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Enregistre le p&#233;riph&#233;rique de type caract&#232;re</span>
<span class="org-comment">     * (ou du moins essaie de le faire)</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;Fops);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Les valeurs n&#233;gatices signifient des erreurs</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        pr_alert(<span class="org-string">"%s failed with %d\n"</span>,
                 <span class="org-string">"Sorry, registering the character device "</span>, ret_val);
        <span class="org-keyword">return</span> ret_val;
    }

    Major = ret_val;

    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);
    device_create(cls, <span class="org-constant">NULL</span>, MKDEV(Major, MAJOR_NUM), <span class="org-constant">NULL</span>, DEVICE_FILE_NAME);

    pr_info(<span class="org-string">"Device created on /dev/%s\n"</span>, DEVICE_FILE_NAME);

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Nettoyage - Supprime le fichier appropri&#233; de /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Supprime le p&#233;riph&#233;rique</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    unregister_chrdev(Major, DEVICE_NAME);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  chardev.h - Le fichier d'en-t&#234;te qui contient toutes les d&#233;finitions</span>
<span class="org-comment"> *  d'ioctl</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Les d&#233;clarations ici doivent obligatoirement &#234;tre contenues dans ce type</span>
<span class="org-comment"> *  de fichier, parce qu'elles doivent &#234;tre connues &#224; la fois :</span>
<span class="org-comment"> *  - de notre module (dans le fichier chardev.c)</span>
<span class="org-comment"> *  - et par le processus qui appelle les ioctl (ioctl.c).</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> CHARDEV_H
<span class="org-preprocessor">#define</span> <span class="org-variable-name">CHARDEV_H</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/ioctl.h&gt;</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le num&#233;ro majeur de p&#233;riph&#233;rique.</span>
<span class="org-comment"> * On ne peut plus utiliser un m&#233;canisme d'attribution dynamique, car les</span>
<span class="org-comment"> * ioctls doivent le conna&#238;tre.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MAJOR_NUM</span> 100

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Assigne le message du pilote de notre p&#233;riph&#233;rique</span>
<span class="org-comment"> * depuis un processus utilisateur</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_SET_MSG</span> _IOW(MAJOR_NUM, 0, <span class="org-type">char</span> *)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * _IOW signifie qu'on est en train de cr&#233;er un num&#233;ro d'ioctl</span>
<span class="org-comment"> * pour passer des informations depuis un processus utilisateur</span>
<span class="org-comment"> * vers un module noyau.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le premier argument, MAJOR_NUM, est le num&#233;ro majeur du p&#233;riph&#233;rique</span>
<span class="org-comment"> * qu'on utilise.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le deuxi&#232;me argument est le num&#233;ro de la commande.</span>
<span class="org-comment"> * Au sein d'un pilote, il peut exister diff&#233;rentes commandes ioctl. Ce num&#233;ro</span>
<span class="org-comment"> * sert &#224; les identifier</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Le troisi&#232;me argument est le type qu'on attend du processus ex&#233;cutant</span>
<span class="org-comment"> * une commande ioctl.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Obtiens le message du pilote de notre p&#233;riph&#233;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_GET_MSG</span> _IOR(MAJOR_NUM, 1, <span class="org-type">char</span> *)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cet IOCTL est utilis&#233; pour diffuser une information, pour informer le</span>
<span class="org-comment"> * processus du contenu de notre pilote. Cependant, on a encore besoin</span>
<span class="org-comment"> * d'un tampon pour y ins&#233;rer les donn&#233;es que l'utilisateur souhaite,</span>
<span class="org-comment"> * tampon qui nous est fourni par ce dernier.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Obtenir le N&#232;me caract&#232;re de notre message</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">IOCTL_GET_NTH_BYTE</span> _IOWR(MAJOR_NUM, 2, <span class="org-type">int</span>)
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * L'IOCTL est utilis&#233; &#224; la fois en sortie et en entr&#233;e.</span>
<span class="org-comment"> * Il re&#231;oit un num&#233;ro N de l'utilisateur, et renvoie Message[N]</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Le nom du fichier associ&#233; &#224; notre p&#233;riph&#233;rique</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEVICE_FILE_NAME</span> <span class="org-string">"char_dev"</span>

<span class="org-preprocessor">#endif</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  ioctl.c - Le programme utilisateur qui ex&#233;cutera des ioctls pour</span>
<span class="org-comment"> *  int&#233;ragir avec notre module</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Jusqu'&#224; maintenant, nous pouvions utiliser des commandes comme cat</span>
<span class="org-comment"> *  pour commander une entr&#233;e ou une sortie sur nos modules, mais</span>
<span class="org-comment"> *  pour ex&#233;cuter un appel ioctl, il faut n&#233;cessairement &#233;crire notre</span>
<span class="org-comment"> *  propre programme utilisateur</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Sp&#233;cifique &#224; notre p&#233;riph&#233;rique, ce fichier contient les num&#233;ro des ioctls</span>
<span class="org-comment"> * et le num&#233;ro majeur du fichier associ&#233; &#224; notre p&#233;riph&#233;rique.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">"../chardev.h"</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;fcntl.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">open </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">exit </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;sys/ioctl.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">ioctl </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction pour les appels ioctls</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">ioctl_set_msg</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>, <span class="org-type">char</span> *<span class="org-variable-name">message</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;

    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);

    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        printf(<span class="org-string">"ioctl_set_msg failed:%d\n"</span>, ret_val);
        exit(-1);
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">ioctl_get_msg</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret_val</span>;
    <span class="org-type">char</span> <span class="org-variable-name">message</span>[100];

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Attention ! Ceci est dangereux parce qu'on ne dit pas au noyau</span>
<span class="org-comment">     * jusqu'o&#249; il doit &#233;crire, alors il existe un risque de d&#233;passement</span>
<span class="org-comment">     * du tampon. En condition r&#233;elle de programmation noyau, nous</span>
<span class="org-comment">     * aurions utilis&#233; deux appels ioctls :</span>
<span class="org-comment">     * - un pour informer le noyau de la taille du tampon</span>
<span class="org-comment">     * - un second avec le tampon &#224; remplir</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);

    <span class="org-keyword">if</span> (ret_val &lt; 0) {
        printf(<span class="org-string">"ioctl_get_msg failed:%d\n"</span>, ret_val);
        exit(-1);
    }

    printf(<span class="org-string">"get_msg message:%s\n"</span>, message);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">int</span> <span class="org-function-name">ioctl_get_nth_byte</span>(<span class="org-type">int</span> <span class="org-variable-name">file_desc</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">c</span>;

    printf(<span class="org-string">"get_nth_byte message:"</span>);

    i = 0;
    <span class="org-keyword">do</span> {
        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);

        <span class="org-keyword">if</span> (c &lt; 0) {
            printf(<span class="org-string">"ioctl_get_nth_byte failed at the %d'th byte:\n"</span>,
                   i);
            exit(-1);
        }

        putchar(c);
    } <span class="org-keyword">while</span> (c != 0);
    putchar(<span class="org-string">'\n'</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Main - Appel des fonctions d'ioctls</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">file_desc</span>, <span class="org-variable-name">ret_val</span>;
    <span class="org-type">char</span> *<span class="org-variable-name">msg</span> = <span class="org-string">"Message passed by ioctl\n"</span>;

    file_desc = open(DEVICE_FILE_NAME, 0);
    <span class="org-keyword">if</span> (file_desc &lt; 0) {
        printf(<span class="org-string">"Can't open device file: %s\n"</span>, DEVICE_FILE_NAME);
        exit(-1);
    }

    ioctl_get_nth_byte(file_desc);
    ioctl_get_msg(file_desc);
    ioctl_set_msg(file_desc, msg);

    close(file_desc);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Les appels système</h2>
<div class="outline-text-2" id="text-10">
<p>
Jusqu'ici, tout ce qu'on a fait était d'utiliser des mécanismes prédéfinis pour enregistrer un fichier <b>/proc</b> et des gestionnaires de périphériques. Ça vous suffira tant que vous vous cantonnez à ce que les développeurs noyaux ont prévu pour vous, comme écrire un pilote de périphérique. Mais qu'en est-il si vous souhaitez aller plus loin ? Si vous souhaitez modifier le fonctionnement du système ?
</p>

<p>
Si vous n'avez pas encore succombé aux sirènes de la machine virtuelle, alors c'est ici que le développement du noyau peut vraiment devenir dangereux. Pendant que j'ai écrit l'exemple plus bas, J'ai tué l'appel système <b>open()</b>. Ce qui signifie que : je ne pouvais plus ouvrir aucun fichier, je ne pouvais plus lancer aucun programme, et je ne pouvais plus éteindre le système. J'ai dû redémarrer brutalement ma machine virtuelle. Je n'ai perdu aucun fichier important, mais si j'avais fait de même sur une vraie machine, ce cauchemar aurait pu devenir réalité. Pour vous assurer de ne pas perdre de fichier, même au sein d'un environnement d'essai, pensez à exécuter <b>sync</b> juste avant d'appeler <b>insmod</b> et <b>rmmod</b>.
</p>

<p>
Oubliez tout à propos des fichiers <b>/proc</b> et des fichiers de périphériques. Ce ne sont que des détails sans importance à l'échelle de votre système. Les vrais mécanismes de communication du noyau sont les appels système. Ce sont eux qui sont appelés par tous les processus. Quand un processus demande un service au noyau (tel qu'ouvrir un fichier, créer un nouveau processus, ou demander plus de mémoire), c'est ce mécanisme qui est appelé. Si vous souhaitez changer le fonctionnement de votre noyau, c'est par là que vous devrez passer. Comme j'en ai parlé plus tôt, si vous souhaitez voir tous les appels système effectués par un programme, utilisez la commande <b>strace</b>.
</p>

<p>
En général, un processus n'est pas censé pouvoir accéder au noyau. Il ne peut ni accéder à la mémoire du noyau, ni appeler les fonctions du noyau. Le matériel, via le CPU, s'en assure (c'est la raison pour laquelle ce mécanisme est appelé 'mode superviseur', ou 'protection de pages').
</p>

<p>
Les appels système sont une exception à cette règle générale. Ce qui se passe, c'est que les processus remplissent des registres avec des valeurs en guise de paramètres, et appellent ensuite une instruction particulière qui saute à une adresse définie précédemment, au sein du noyau (bien sûr, cette adresse peut être lue par les processus utilisateurs, mais ces derniers ne peuvent pas y écrire). Au sein des CPU Intels, on y accède via l'interruption 0x80. Le matériel sait qu'une fois que vous avez sauté à cette adresse, votre processeur n'est plus en mode utilisateur, mais en mode noyau &#x2014; vous êtes donc libre de faire tout ce que vous souhaitez.
</p>

<p>
L'adresse au sein du noyau où un processus peut sauter est appelé system_call. L'algorithme à l'arrivée de ce code regarde le numéro d'appel système, qui définit quelle fonction système est demandée. Ensuite, le programme regarde dans la table d'appels système (appelée sys_call_table) quelle est l'adresse de la fonction demandée. Pour finir, le processeur saute à cette fonction, et avant d'en revenir, effectue quelques vérifications systèmes avant de redonner la main au processus utilisateur appelant (ou à un autre processus si le premier à été trop long). Si vous souhaitez lire ce code, il est disponible dans le code source (arch/$&lt;$architecture$&gt;$/kernel/enty.S, après la ligne ENTRY(system_call)).
</p>

<p>
Ainsi, si vous souhaitez, d'une certaine manière, changer le fonctionnement d'un certain appel système, ce que vous devez faire est de créer votre propre fonction pour l'insérer (généralement cette fonction exécutera votre code avant d'appeler la fonction système originale) et ensuite changer le pointeur de la table sys_call_table pour que cette dernière pointe vers votre fonction. Attention ! Parce que vous ne souhaitez pas que votre module soit enlevé en laissant le système dans un état instable, il est important que la fonction cleanup_module modifie la table dans son état précédent.
</p>

<p>
Le code source suivant est un exemple d'un tel module noyau. On souhaite ici "espionner" un certain utilisateur, afin de notifier, via <b>pr_info()</b>, quand cet utilisateur ouvre un fichier. Pour procéder, on remplace l'appel système lancé à l'ouverture d'un fichier par notre propre fonction, appelée ici <b>our_sys_open</b>. Cette fonction vérifie l'uid (l'identifiant de l'utilisateur) du processus courant, et si cet uid est égal à celui qu'on surveille, alors la fonction appelle <b>pr_info()</b> afin d'afficher le nom du fichier en cours d'ouverture. Ensuite, et peu importe l'uid, notre fonction appelle la fonction originale open() avec les mêmes paramètres, pour effectivement ouvrir le fichier.
</p>

<p>
La fonction <b>init_module</b> remplace la fonction concernée dans la table <b>sys_call_table</b> avec notre fonction, et conserve l'originale dans une variable. La fonction cleanup_module utilise cette variable pour restaurer le système dans l'état où il se trouvait avant cette modification. Cette méthode est très dangereuse, dans le cas ou deux modules noyaux modifient le même appel système.
</p>

<p>
Imaginez deux modules, A et B. L'ouverture de A sera A_open, et celle de B B_open. Maintenant, quand A est inséré dans le noyau, l'appel système open est remplacé par A_open, qui appellera l'appel original open à sa fin. Ensuite, si on insère B au sein de noyau, ce dernier remplacera l'appel système A_open avec le B_open. L'appel de A_open sera sonc effectué à la fin de la fonction B_open.
</p>

<p>
Ensuite, enlevons ces modules. Si B est enlevé en premier, alors il n'y aura aucun problème &#x2014; l'appel système sera restauré à A_open, qui lui-même appelle l'open() original. Cependant, si A est enlevé, alors l'appel système original sera restauré (ce qui signifie que B_open ne sera jamais appelé). C'est problématique, mais pas catastrophique. Cependant, si vous enlevez ensuite B, la suppression de ce dernier va restaurer l'appel système à ce qu'il pense être l'original, <b>A_open</b>, lequel n'est plus présent en mémoire. Les conséquences seront désastreuses.
</p>

<p>
À première vue, un module peut régler ce problème en vérifiant, lors de sa suppression, si l'appel système présent dans la table sys_call_table est bien sa propre fonction, et si ce n'est pas le cas, il ne doit rien changer (ainsi B ne changerait aucun appel système à sa suppression), mais cette solution conduirait en réalité à un problème plus grave encore. Quand A est enlevé, ce dernier voit que l'appel système a été changé à <b>B_open</b>. Ce dernier ne restaurera donc pas l'appel système original. Mais malheureusement, B n'a pas conscience de ça. <b>B_open</b> commencera, puis appellera <b>A_open</b>, qui n'existe pas en mémoire. Donc même sans enlever B du système, votre système va planter.
</p>

<p>
Notez que tous les problèmes relatifs à cette situation rendent tout simplement la redéfinition des appels système impossible pour des usages en situation de production. Afin de ne pas tenter les développeurs du dimanche de faire des choses potentiellement désastreuses, la table <b>sys_call_table</b> n'est plus exportée, ce qui signifie que si vous souhaitez exécuter l'exemple suivant, vous devrez modifier votre noyau pour exporter la table en question. Dans le répertoire examples, vous trouverez un README et la modification à apporter. Comme vous l'imaginez, une telle modification ne doit pas être prise à la légère. N'essayez pas de réaliser une telle action sur un système important (par exemple un système que vous ne possédez pas ou que vous ne pouvez pas restaurer aisément). Vous aurez besoin d'accéder au code source complet de ce guide pour avoir accès aux modifications et au README. En fonction de votre version du noyau, vous risquez même devoir effectuer cette modification à la main.
</p>

<p>
C'est ici que se clôt ce chapitre. Sachez cependant que si Le Coyote chassant Bip Bip était un hacker noyau, ce serait la première chose qu'il essaierait pour attraper son repas !
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  syscall.c</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Exemple de "vol" d'un d'appel syst&#232;me.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  D&#233;sactive la protection des pages au niveau du processeur</span>
<span class="org-comment"> *  en changeant le 16&#232;me bit dans le registre cr0</span>
<span class="org-comment"> *  (sp&#233;cifique aux processeurs Intel)</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  D&#233;monstration bas&#233;e sur l'exemple de Peter Jay Salzman et sur</span>
<span class="org-comment"> *  https://bbs.archlinux.org/viewtopic.php?id=139406</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/syscalls.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;asm/paravirt.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/moduleparam.h&gt;</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">Qui contiendra les param&#232;tres </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/unistd.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">La liste des appels syst&#232;me </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * On a besoin de ces fichiers afin de conna&#238;tre qui est</span>
<span class="org-comment"> * l'utilisateur dans la structure du processus actuel</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span>

<span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-variable-name">sys_call_table</span>;
<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">original_cr0</span>;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * UID qu'on souhaite espionner - sera affect&#233;e</span>
<span class="org-comment"> * par la ligne de commande</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">uid</span>;
<span class="org-function-name">module_param</span>(uid, <span class="org-type">int</span>, 0644);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La prochaine variable est un pointeur qui contiendra l'adresse</span>
<span class="org-comment"> * de l'appel syst&#232;me avant notre modification.</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * On garde cette adresse dans ce pointeur pour pouvoir, quand on d&#233;chargera</span>
<span class="org-comment"> * notre module, remettre le syst&#232;me dans son &#233;tat initial. On doit garder en</span>
<span class="org-comment"> * m&#233;moire dans ce pointeur l'appel syst&#232;me avant qu'on le modifie, et on ne</span>
<span class="org-comment"> * peut pas juste utiliser l'appel syst&#232;me original (sys_open) dans le cas ou</span>
<span class="org-comment"> * un autre module a modifi&#233; cet appel syst&#232;me avant non. Notez bien que cette</span>
<span class="org-comment"> * s&#233;curit&#233; n'est pas absolument s&#251;re, car dans le cas redout&#233; d&#233;crit dans</span>
<span class="org-comment"> * ce guide de deux modules modifiant le m&#234;me appel syst&#232;me, alors si le</span>
<span class="org-comment"> * module qui a modifi&#233; l'appel syst&#232;me original est supprim&#233; avant le notre,</span>
<span class="org-comment"> * alors si j'appelle une fonction de ce module supprim&#233; d&#233;puis, je ne sais</span>
<span class="org-comment"> * pas ce qui attends notre noyau !</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * Une autre raison pour laquelle on utilise ce pointeur c'est que sys_open</span>
<span class="org-comment"> * est une variable statique, et elle n'est donc pas export&#233;e.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
asmlinkage <span class="org-type">int</span> (*<span class="org-function-name">original_call</span>) (<span class="org-keyword">const</span> <span class="org-type">char</span> *, <span class="org-type">int</span>, <span class="org-type">int</span>);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La fonction suivante va remplacer sys_open</span>
<span class="org-comment"> * Elle sera donc appel&#233;e quand n'importe quel processus ex&#233;cutera l'appel</span>
<span class="org-comment"> * syst&#232;me open.</span>
<span class="org-comment"> * Pour trouver le prototype exact, afin que correspondent parfaitement</span>
<span class="org-comment"> * les arguments, vous devrez faire un tour dans le fichier qui contient la</span>
<span class="org-comment"> * fonction originale (fs/open.c).</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * En th&#233;orie, &#231;a veut dire que notre code est donc d&#233;pendant de la version</span>
<span class="org-comment"> * actuelle du noyau, puisque notre fonction d&#233;pend des types et nombres</span>
<span class="org-comment"> * d'arguments que prennent l'appel syst&#232;me original.</span>
<span class="org-comment"> * En pratique, ne vous inqui&#233;tez pas, les appels syst&#232;me ne sont quasiment</span>
<span class="org-comment"> * jamais modifi&#233;s (cela signifirai que tous les programmes con&#231;us avant cette</span>
<span class="org-comment"> * mise &#224; jour soit recompil&#233;s, puisque les appels syst&#232;me sont l'interface</span>
<span class="org-comment"> * entre le noyau et les processus, et &#231;a causerait donc des ravages</span>
<span class="org-comment"> * d&#233;vastateurs pour le noyau et sa r&#233;putation)</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
asmlinkage <span class="org-type">int</span> <span class="org-function-name">our_sys_open</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">filename</span>, <span class="org-type">int</span> <span class="org-variable-name">flags</span>, <span class="org-type">int</span> <span class="org-variable-name">mode</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
    <span class="org-type">char</span> <span class="org-variable-name">ch</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Note l'ouverture du fichier, si n&#233;cessaire</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    pr_info(<span class="org-string">"Opened file by %d: "</span>, uid);
    <span class="org-keyword">do</span> {
        get_user(ch, filename + i);
        i++;
        pr_info(<span class="org-string">"%c"</span>, ch);
    } <span class="org-keyword">while</span> (ch != 0);
    pr_info(<span class="org-string">"\n"</span>);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * A l&#224; fin de notre appel syst&#232;me, notre code doit, bien sur, appeler</span>
<span class="org-comment">     * le code original, sinon quoi on perdrait la capacit&#233; d'ouvrir</span>
<span class="org-comment">     * tous les fichiers</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> original_call(filename, flags, mode);
}

<span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-function-name">aquire_sys_call_table</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">int</span> <span class="org-variable-name">offset</span> = PAGE_OFFSET;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> **<span class="org-variable-name">sct</span>;

    <span class="org-keyword">while</span> (offset &lt; ULLONG_MAX) {
        sct = (<span class="org-type">unsigned</span> <span class="org-type">long</span> **)offset;

        <span class="org-keyword">if</span> (sct[__NR_close] == (<span class="org-type">unsigned</span> <span class="org-type">long</span> *) sys_close)
            <span class="org-keyword">return</span> sct;

        offset += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
    }

    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> syscall_start(<span class="org-type">void</span>)
{
    <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>(sys_call_table = aquire_sys_call_table()))
        <span class="org-keyword">return</span> -1;

    original_cr0 = read_cr0();

    write_cr0(original_cr0 &amp; ~0x00010000);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Garde l'adresse de l'appel syst&#232;me open original </span><span class="org-comment-delimiter">*/</span>
    original_call = (<span class="org-type">void</span>*)sys_call_table[__NR_open];

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Modifie la table des appels syst&#232;me pour utiliser notre fonction </span><span class="org-comment-delimiter">*/</span>
    sys_call_table[__NR_open] = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)our_sys_open;

    write_cr0(original_cr0);

    pr_info(<span class="org-string">"Spying on UID:%d\n"</span>, uid);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> syscall_end(<span class="org-type">void</span>)
{
    <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>sys_call_table) {
        <span class="org-keyword">return</span>;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Restaure la table des appels syst&#232;me &#224;</span>
<span class="org-comment">     * son &#233;tat avant notre modification</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (sys_call_table[__NR_open] != (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)our_sys_open) {
        pr_alert(<span class="org-string">"Somebody else also played with the "</span>);
        pr_alert(<span class="org-string">"open system call\n"</span>);
        pr_alert(<span class="org-string">"The system may be left in "</span>);
        pr_alert(<span class="org-string">"an unstable state.\n"</span>);
    }

    write_cr0(original_cr0 &amp; ~0x00010000);
    sys_call_table[__NR_open] = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)original_call;
    write_cr0(original_cr0);

    msleep(2000);
}

<span class="org-function-name">module_init</span>(syscall_start);
<span class="org-function-name">module_exit</span>(syscall_end);

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Processus bloquants et threads</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Sleep</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Que faites-vous quand quelqu'un vous demande de faire quelque chose que vous ne pouvez pas faire immédiatement ? Si vous êtes un Corse dérangé par quelqu'un vous lui répondrez sans doute "<i>Pas maintenant, laisse-moi dormir !</i>". Mais si vous êtes un module et que vous êtes dérangé par un processus, vous avez une autre possibilité : Vous pouvez endormir le processus qui vous demande jusqu'à ce que vous puissiez vous en occuper. Après tout, les processus sont endormis et réveillés sans arrêt par le noyau (c'est la raison pour laquelle de nombreux processus donnent l'impression de tourner en même temps sur un seul processeur).
</p>

<p>
Le module noyau suivant est un exemple de ça. Le fichier (appelé <b>/proc/sleep</b>) ne peut être ouvert que par un seul processus à la fois. Si le fichier est déjà ouvert, le module appelle wait_event_interruptible. La manière la plus simple de garder un fichier ouvert est la suivante :
</p>

<div class="org-src-container">

<pre class="src src-bash">tail -f
</pre>
</div>

<p>
La fonction wait_event_interruptible change l'état de la tâche (une tâche est ni plus ni moins qu'une structure de données dans le noyau qui contient les informations d'un processus et les appels système utilisés) pour <b>TASK_INTERRUPTIBLE</b>, qui signifie que la tâche ne sera pas lancée avant qu'elle ne soit réveillée d'une quelconque manière. La fonction wait_event_interruptible va ensuite ajouter la tâche en question à WaitQ, la file des tâches qui attendent pour accéder au fichier. Ensuite, la fonction appelle l'ordonnanceur pour changer le contexte d'exécution de la thread à endormir pour une autre, qui sera vraiment utilisée par le CPU.
</p>

<p>
Quand le processus qui utilisait le fichier n'en a plus besoin, ce processus ferme le fichier, la fonction module_close est alors appelée. Cette fonction réveille tous les processus dans la file d'attente (il n'y a pas de moyen de n'en réveiller qu'un). Quand cette fonction se termine, alors le processus qui vient de fermer le fichier peut continuer sa vie. En temps voulu, l'ordonnanceur décidera que ce processus a assez profité du processeur, et "donnera" le processeur à un autre processus. Et tôt ou tard, l'un des processus qui était dans la file d'attente pour le fichier se verra donner l'accès au processeur par l'ordonnanceur. Et il reprendra sa vie juste après l'appel à <b>module_interruptible_sleep_on</b>.
</p>

<p>
Ça signifie que le processus est encore en train d'exécuter du code noyau. D'un point de vue du code utilisateur du programme, on est encore situé dans l'appel système open, lequel ne s'est pas encore terminé. Le processus n'a absolument aucune idée qu'un autre processus a utilisé le processeur entre le moment où il a exécuté l'appel à la fonction open() et le moment où cette fonction s'est terminée.
</p>

<p>
Une fois que le processus qui attendait l'accès au fichier a la main sur le processeur et sur le fichier, il peut ensuite affecter une variable globale pour signaler aux autres processus que le fichier est encore ouvert (en l'occurrence par lui), et continuer son affaire. Quand les autres processus qui attendent l'accès à ce fichier auront accès au processeur, ils liront que cette variable globale signale que le fichier sur lequel ils attendent un accès est encore occupé, et se rendormiront aussitôt.
</p>

<p>
Dans notre cas, nous utiliserons tail -f pour garder le fichier ouvert continuellement en tâche de fond, pendant que nous essaierons d'y accéder avec d'autres processus (toujours en tâche de fond, afin que nous n'ayons pas besoin de basculer vers un autre terminal). Dès que le premier fichier sera tué avec la commande kill%1, alors le second se réveillera, aura finalement accès au fichier avant de se terminer.
</p>

<p>
Pour rendre cette expérience plus intéressante, sachez que bien que notre processus endormi attend son prince charmant, la fonction <b>module_close</b> n'a pas le monopole du réveil de notre processus. Ce dernier peut être également réveillé par d'autre interruptions, telles qu'un signal Ctrl+c/ (<b>SIGINT</b>). Ceci vient du fait qu'on a préféré utiliser <b>module_interruptible_sleep_on</b>. On aurait pu utiliser <b>module_sleep_on</b> à la place, lequel ignore les signaux, mais pour une raison qui m'échappe, les utilisateurs n'aiment pas avoir l'impression que le contrôle de leur machine leur échappe.
</p>

<p>
Dans le cas d'un réveil par Ctrl+c/, on veut terminer la fonction immédiatement et renvoyer un <b>-EINTR</b>. C'est essentiel afin que les utilisateurs puissent tuer un processus avant que ce dernier ne reçoivent le fichier qu'il attend.
</p>

<p>
Il y a encore un point important à retenir. Parfois, les processus sont exigeants et ne souhaitent pas s'endormir. Ils veulent soit obtenir ce qu'ils demandent immédiatement, soit qu'on leur informe que la ressource qu'ils demandent n'est pas disponible. De tels processus utilisent le drapeau <b>O_NONBLOCK</b> quand ils ouvrent un fichier. Le noyau est censé intervenir en renvoyant une erreur <b>-EAGAIN</b> à l'appel d'une opération qui ignorerait ce drapeau pour bloquer le processus appelant. Le programme cat_noblock, disponible dans le code source de ce chapitre de votre guide, peut être utiliser pour illustrer l'ouverture d'un fichier avec l'option <b>O_NONBLOCK</b>.
</p>

<div class="org-src-container">

<pre class="src src-sh">hostname:~/lkmpg-examples/09-BlockingProcesses# insmod sleep.ko
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses# tail -f /proc/sleep &amp;
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
tail: /proc/sleep: file truncated
[1] 6540
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Open would block
hostname:~/lkmpg-examples/09-BlockingProcesses# kill %1
[1]+  Terminated              tail -f /proc/sleep
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses#
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  sleep.c - Cr&#233;er un fichier /proc, et si</span>
<span class="org-comment"> *  plusieurs processus essaient d'y acc&#232;der</span>
<span class="org-comment"> *  en m&#234;me temps, les endorts tous sauf un</span>
<span class="org-comment"> *  &#224; qui la lecture est accord&#233;e</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/proc_fs.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire comme nous utilisons proc fs </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour endormir les processus  *</span>
<span class="org-comment">                              et les r&#233;veiller                        </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/uaccess.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">N&#233;cessaire pour les fonctions get_user  *</span>
<span class="org-comment">                              et put_user                             </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Les fonctions de notre module</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Dans ce tableau on garde le dernier message re&#231;u,</span>
<span class="org-comment"> * afin de prouver que notre fichier g&#232;re les entr&#233;es</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#define</span> <span class="org-variable-name">MESSAGE_LENGTH</span> 80
<span class="org-keyword">static</span> <span class="org-type">char</span> Message[MESSAGE_LENGTH];

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">proc_dir_entry</span> *<span class="org-variable-name">Our_Proc_File</span>;
<span class="org-preprocessor">#define</span> <span class="org-variable-name">PROC_ENTRY_FILENAME</span> <span class="org-string">"sleep"</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction de lecture associ&#233;e dans notre struct file operations</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">module_output</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>, <span class="org-comment-delimiter">/* </span><span class="org-comment">Voir include/linux/fs.h  </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">char</span> *<span class="org-variable-name">buf</span>,         <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon dans lequel on *</span>
<span class="org-comment">                                                   va ins&#233;rer les donn&#233;es   *</span>
<span class="org-comment">                                                   (situ&#233; dans l'espace     *</span>
<span class="org-comment">                                                   utilisateur)             </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">size_t</span> <span class="org-variable-name">len</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">La taille du tampon      </span><span class="org-comment-delimiter">*/</span>
                             <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)
{
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">finished</span> = 0;
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">message</span>[MESSAGE_LENGTH + 30];

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Renvoie 0 pour signifier la fin du fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (finished) {
        finished = 0;
        <span class="org-keyword">return</span> 0;
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si vous ne comprenez pas &#231;a au point o&#249; vous en &#234;tes,</span>
<span class="org-comment">     * alors vous &#234;tes aussi d&#233;sesp&#233;rant qu'un programmeur noyau</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    sprintf(message, <span class="org-string">"Last input:%s\n"</span>, Message);
    <span class="org-keyword">for</span> (i = 0; i &lt; len &amp;&amp; message[i]; i++)
        put_user(message[i], buf + i);

    finished = 1;
    <span class="org-keyword">return</span> i;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Renvoie le nombre d'octets "lus" </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Cette fonction re&#231;oit des donn&#233;es de l'utilisateur quand ce dernier &#233;crit</span>
<span class="org-comment"> * quelque chose dans notre fichier /proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">ssize_t</span> <span class="org-function-name">module_input</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>,  <span class="org-comment-delimiter">/* </span><span class="org-comment">Le fichier en question   </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">buf</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon contenant les  *</span>
<span class="org-comment">                                                   donn&#233;es &#224; "&#233;crire"       </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-type">size_t</span> <span class="org-variable-name">length</span>,      <span class="org-comment-delimiter">/* </span><span class="org-comment">La taille du tampon      </span><span class="org-comment-delimiter">*/</span>
                            <span class="org-type">loff_t</span> * <span class="org-variable-name">offset</span>)    <span class="org-comment-delimiter">/* </span><span class="org-comment">Curseur de notre fichier *</span>
<span class="org-comment">                                                   (&#224; ignorer)              </span><span class="org-comment-delimiter">*/</span>
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Modifie notre tableau Message avec les donn&#233;es pass&#233;es par</span>
<span class="org-comment">     * l'utilisateur, afin que que notre fonction module_output</span>
<span class="org-comment">     * puisse par la suite s'en servir</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; MESSAGE_LENGTH - 1 &amp;&amp; i &lt; length; i++)
        get_user(Message[i], buf + i);
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On souhaite une cha&#238;ne de caract&#232;res bien faite, termin&#233;e par un 0</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Message[i] = <span class="org-string">'\0'</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * On doit renvoyer le nombre de caract&#232;res pass&#233;s par l'utilisateur</span>
<span class="org-comment">     * qu'on a effectivement utilis&#233;s</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">return</span> i;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Vaut 1 si le fichier est actuellement ouvert par un processus</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-variable-name">Already_Open</span> = 0;

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * File des processus qui veulent ouvrir notre fichier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-function-name">DECLARE_WAIT_QUEUE_HEAD</span>(WaitQ);
<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233;e quand notre fichier /proc est ouvert</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">module_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si les drapeaux de notre fichier incluent O_NONBLOCK, &#231;a signifie que</span>
<span class="org-comment">     * le processus qui a essaie d'ouvrir notre fichier ne souhaite pas</span>
<span class="org-comment">     * &#234;tre bloqu&#233; si ce dernier n'est pas disponible. Dans ce cas, si</span>
<span class="org-comment">     * le fichier est d&#233;j&#224; ouvert, on doit terminer la fonction avec la valeur</span>
<span class="org-comment">     * d'&#233;chec -EAGAIN, qui signifie "Essaie encore !" plut&#244;t que de bloquer</span>
<span class="org-comment">     * un processus qui pr&#233;f&#232;re rester libre et r&#233;veill&#233;</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; Already_Open)
        <span class="org-keyword">return</span> -EAGAIN;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * C'est le bon endroit pour ins&#233;rer la fonction</span>
<span class="org-comment">     * try_module_get(THIS_MODULE), car si jamais un</span>
<span class="org-comment">     * processus est dans la boucle qui vient juste</span>
<span class="org-comment">     * apr&#232;s, laquelle se situe dans le code noyau,</span>
<span class="org-comment">     * alors notre module ne doit pas &#234;tre supprim&#233;</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    try_module_get(THIS_MODULE);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si le fichier est d&#233;j&#224; ouvert, attendre qu'il ne le soit plus</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">while</span> (Already_Open) {
        <span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">is_sig</span> = 0;

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cette fonction endort le processus en-cours (y compris tous les</span>
<span class="org-comment">         * appels syst&#232;me). Son ex&#233;cution reprendra juste apr&#232;s l'appel &#224;</span>
<span class="org-comment">         * cette fonction, soit parce qu'un autre processus a ex&#233;cut&#233;</span>
<span class="org-comment">         * wake_up(&amp;WaitQ) (seulement module_close fait cela, quand le</span>
<span class="org-comment">         * fichier est ferm&#233;), soit quand un signal (par exemple un Ctrl+C)</span>
<span class="org-comment">         * est envoy&#233; au dit-processus</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        wait_event_interruptible(WaitQ, <span class="org-negation-char">!</span>Already_Open);

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Si le processus est r&#233;veill&#233; parce qu'il a re&#231;ut un signal,</span>
<span class="org-comment">         * alors il faut renvoyer -EINTR(ce qui signifie un &#233;chec de l'appel</span>
<span class="org-comment">         * syst&#232;me). Cela permet aux processus qui attendent un fichier</span>
<span class="org-comment">         * d'&#234;tre tu&#233;s ou arr&#234;t&#233;s par un signal.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Cmmentaire de Emmanuel Papirakis traduit :</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Ceci est une petite mise &#224; jour par rapport &#224; la version 2.2.*.</span>
<span class="org-comment">         * Les signaux sont maintenant contenus dans deux mots (de 64 bits)</span>
<span class="org-comment">         * et sont stock&#233;s dans une structure qui contient un tableau de</span>
<span class="org-comment">         * deux entiers longs non sign&#233;s.</span>
<span class="org-comment">         * On doit donc faire deux v&#233;rifications dans notre "si"</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Commentaire de Ori Pomerantz traduit :</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Personne n'a jamais promis de ne pas utiliser des mots plus longs</span>
<span class="org-comment">         * que 64 bits, ou que ce guide ne serait pas utilis&#233; pour des</span>
<span class="org-comment">         * versions de Linux qui utilisent des mots de 16 bits.</span>
<span class="org-comment">         * C'est pourquoi ce code marchera quelque soit votre architecture.</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">for</span> (i = 0; i &lt; _NSIG_WORDS &amp;&amp; <span class="org-negation-char">!</span>is_sig; i++)
            is_sig =
                current-&gt;pending.signal.sig[i] &amp; ~current-&gt;
                blocked.sig[i];

        <span class="org-keyword">if</span> (is_sig) {
            <span class="org-comment-delimiter">/*</span>
<span class="org-comment">             * Il est important de d&#233;cr&#233;menter le compteur d'utilisation dans</span>
<span class="org-comment">             * le cas ou le processus voulant ouvrir notre fichier a re&#231;u</span>
<span class="org-comment">             * un signal. Si on oublie de d&#233;cr&#233;menter ce compteur, notre</span>
<span class="org-comment">             * module sera immortel et ne pourra pas &#234;tre enlev&#233; du noyau</span>
<span class="org-comment">             * autrement que par un red&#233;marrage.</span>
<span class="org-comment">             </span><span class="org-comment-delimiter">*/</span>
            module_put(THIS_MODULE);
            <span class="org-keyword">return</span> -EINTR;
        }
    }

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si on est ici, alors la variable Already_Open doit &#234;tre &#233;gale &#224; 0</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Ouvre le fichier</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Already_Open = 1;
    <span class="org-keyword">return</span> 0;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Autorise l'acc&#232;s </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Appel&#233; quand notre fichier /proc est ferm&#233;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">int</span> <span class="org-function-name">module_close</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">inode</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>)
{
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Met la variable Already_Open &#224; 0, afin que l'un des processus qui</span>
<span class="org-comment">     * attend sagement d'ouvrir le fichier puisse enfin mettre la main</span>
<span class="org-comment">     * dessus, en signalant son utilisation en remettant la variable</span>
<span class="org-comment">     * Already_Open &#224; 1 avant d'effectivement ouvrir le fichier.</span>
<span class="org-comment">     * Tous les processus qui attendent notre fichier verront alors</span>
<span class="org-comment">     * qu'Already_Open vaut 1, signifiant qu'un processus a d&#233;j&#224; la main</span>
<span class="org-comment">     * sur le fichier. Ces processus s'endormiront alors une fois encore.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    Already_Open = 0;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * R&#233;veille tous les processus pr&#233;sent dans la file d'attente WaitQ,</span>
<span class="org-comment">     * Afin que ces derniers puissent enfin prendre la main sur le fichier</span>
<span class="org-comment">     * qu'ils attendent.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    wake_up(&amp;WaitQ);

    module_put(THIS_MODULE);

    <span class="org-keyword">return</span> 0;               <span class="org-comment-delimiter">/* </span><span class="org-comment">Succ&#232;s </span><span class="org-comment-delimiter">*/</span>
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Structure pour enregister le fichier /proc, contenant des</span>
<span class="org-comment"> * pointeurs vers les fonctions associ&#233;es.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La structure file operations pour notre fichier proc. C'est ici qu'on place</span>
<span class="org-comment"> * les pointeurs vers toutes les fonctions appel&#233;es quand quelqu'un essaie de</span>
<span class="org-comment"> * faire quoique ce soit avec notre fichier. La valeur NULL signifie qu'on</span>
<span class="org-comment"> * n'a pas implant&#233; la fonction associ&#233;e.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">File_Ops_4_Our_Proc_File</span> = {
    .read = module_output,   <span class="org-comment-delimiter">/* </span><span class="org-comment">"Lecture" de notre fichier              </span><span class="org-comment-delimiter">*/</span>
    .write = module_input,   <span class="org-comment-delimiter">/* </span><span class="org-comment">"Ecriture" de notre fichier             </span><span class="org-comment-delimiter">*/</span>
    .open = module_open,     <span class="org-comment-delimiter">/* </span><span class="org-comment">Appel&#233;e quand notre fichier sera ouvert </span><span class="org-comment-delimiter">*/</span>
    .release = module_close, <span class="org-comment-delimiter">/* </span><span class="org-comment">Appel&#233;e quand notre fichier sera ferm&#233;  </span><span class="org-comment-delimiter">*/</span>
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialisation et suppression de notre module.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Initialise notre module en enregistrant le fichier proc</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    Our_Proc_File = proc_create(PROC_ENTRY_FILENAME, 0644, <span class="org-constant">NULL</span>, &amp;File_Ops_4_Our_Proc_File);
    <span class="org-keyword">if</span>(Our_Proc_File == <span class="org-constant">NULL</span>)
    {
        remove_proc_entry(PROC_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
        pr_debug(<span class="org-string">"Error: Could not initialize /proc/%s\n"</span>, PROC_ENTRY_FILENAME);
        <span class="org-keyword">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_info(<span class="org-string">"/proc/test created\n"</span>);

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction de sortie de notre module - Supprime notre fichier de /proc.</span>
<span class="org-comment"> * Cela pourrait &#234;tre dangereux si il y avait encore des processus pr&#233;sents</span>
<span class="org-comment"> * dans WaitQ, attendant la lib&#233;ration de notre fichier, parcequ'ils ont leurs</span>
<span class="org-comment"> * pointeurs de code dirig&#233;s vers notre fonction open(), qui va &#234;tre d&#233;charg&#233;e</span>
<span class="org-comment"> * du noyau. J'expliquerai dans le chapitre 10 comment &#233;viter de d&#233;charger un</span>
<span class="org-comment"> * module du noyau dans un tel cas.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    remove_proc_entry(PROC_ENTRY_FILENAME, <span class="org-constant">NULL</span>);
    pr_debug(<span class="org-string">"/proc/%s removed\n"</span>, PROC_ENTRY_FILENAME);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * cat_noblock.c - Ouvre un fichier et affiche son contenu, mais pr&#233;f&#232;re</span>
<span class="org-comment"> * s'arr&#233;ter plutot que d'attendre le fichier</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">Copyright (C) 1998 de Ori Pomerantz </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Entr&#233;e/Sortie standard </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;fcntl.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction open  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unistd.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction read  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdlib.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la fonction exit  </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;errno.h&gt;</span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour les erreurs       </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">MAX_BYTES</span> 1024*4


<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> *<span class="org-variable-name">argv</span>[])
{
    <span class="org-type">int</span>    <span class="org-variable-name">fd</span>;                <span class="org-comment-delimiter">/* </span><span class="org-comment">Le descripteur de fichier pour le fichier *</span>
<span class="org-comment">                               * qu'on souhaite lire                       </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>;             <span class="org-comment-delimiter">/* </span><span class="org-comment">Le nombre d'octets lus                    </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">char</span>   <span class="org-variable-name">buffer</span>[MAX_BYTES]; <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tampon qui recevra les donn&#233;es         </span><span class="org-comment-delimiter">*/</span>


    <span class="org-comment-delimiter">/* </span><span class="org-comment">V&#233;rification du bon utilisation de notre programme </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (argc != 2) {
        printf(<span class="org-string">"Usage: %s &lt;filename&gt;\n"</span>, argv[0]);
        puts(<span class="org-string">"Reads the content of a file, but doesn't wait for input"</span>);
        exit(-1);
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ouvre le fichier pour une lecture en mode non bloquant </span><span class="org-comment-delimiter">*/</span>
    fd = open(argv[1], O_RDONLY | O_NONBLOCK);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Si l'ouverture a &#233;chou&#233;e </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (fd == -1) {
        <span class="org-keyword">if</span> (errno = EAGAIN)
            puts(<span class="org-string">"Open would block"</span>);
        <span class="org-keyword">else</span>
            puts(<span class="org-string">"Open failed"</span>);
        exit(-1);
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lit le fichier et affiche son contenu </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">do</span> {
        <span class="org-type">int</span> <span class="org-variable-name">i</span>;

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Lit les caract&#232;res depuis le fichier </span><span class="org-comment-delimiter">*/</span>
        bytes = read(fd, buffer, MAX_BYTES);

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Si une erreur est renvoy&#233;e, la signaler *</span>
<span class="org-comment">         * avant de terminer le processus          </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">if</span> (bytes == -1) {
            <span class="org-keyword">if</span> (errno = EAGAIN)
                puts(<span class="org-string">"Normally I'd block, but you told me not to"</span>);
            <span class="org-keyword">else</span>
                puts(<span class="org-string">"Another read error"</span>);
            exit(-1);
        }

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Affiche les caract&#232;res </span><span class="org-comment-delimiter">*/</span>
        <span class="org-keyword">if</span> (bytes &gt; 0) {
            <span class="org-keyword">for</span>(i=0; i&lt;bytes; i++)
                putchar(buffer[i]);
        }

        <span class="org-comment-delimiter">/* </span><span class="org-comment">Continuer tant qu'il reste des caract&#232;res *</span>
<span class="org-comment">         * &#224; lire dans notre fichier                 </span><span class="org-comment-delimiter">*/</span>
    } <span class="org-keyword">while</span> (bytes &gt; 0);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">Achèvements</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Parfois, certaines choses doivent se dérouler avec d'autres au sein d'un module disposant de plusieurs threads. Plutôt que d'utiliser la commande <b>/proc/sleep</b>, le noyau a un autre moyen de réaliser ce mécanisme, tout en permettant les temporisations et les interruptions.
</p>

<p>
Dans l'exemple suivant, deux threads sont démarrées au sein d'un module, mais l'une d'entre elle doit commencer après l'autre pour le bon fonctionnement du module.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kthread.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/completion.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> {
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">crank_comp</span>;
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">flywheel_comp</span>;
} <span class="org-variable-name">machine</span>;

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">machine_crank_thread</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
    pr_info(<span class="org-string">"Turn the crank\n"</span>);

    complete_all(&amp;machine.crank_comp);
    complete_and_exit(&amp;machine.crank_comp, 0);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">machine_flywheel_spinup_thread</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>)
{
    wait_for_completion(&amp;machine.crank_comp);

    pr_info(<span class="org-string">"Flywheel spins up\n"</span>);

    complete_all(&amp;machine.flywheel_comp);
    complete_and_exit(&amp;machine.flywheel_comp, 0);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">completions_init</span>(<span class="org-type">void</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">task_struct</span>* <span class="org-variable-name">crank_thread</span>;
    <span class="org-keyword">struct</span> <span class="org-type">task_struct</span>* <span class="org-variable-name">flywheel_thread</span>;

    pr_info(<span class="org-string">"completions example\n"</span>);

    init_completion(&amp;machine.crank_comp);
    init_completion(&amp;machine.flywheel_comp);

    crank_thread =
        kthread_create(machine_crank_thread,
                       <span class="org-constant">NULL</span>, <span class="org-string">"KThread Crank"</span>);
    <span class="org-keyword">if</span> (IS_ERR(crank_thread))
        <span class="org-keyword">goto</span> <span class="org-constant">ERROR_THREAD_1</span>;

    flywheel_thread =
        kthread_create(machine_flywheel_spinup_thread,
                       <span class="org-constant">NULL</span>, <span class="org-string">"KThread Flywheel"</span>);
    <span class="org-keyword">if</span> (IS_ERR(flywheel_thread))
        <span class="org-keyword">goto</span> <span class="org-constant">ERROR_THREAD_2</span>;

    wake_up_process(flywheel_thread);
    wake_up_process(crank_thread);

    <span class="org-keyword">return</span> 0;

<span class="org-constant">ERROR_THREAD_2</span>:
    kthread_stop(crank_thread);
<span class="org-constant">ERROR_THREAD_1</span>:

    <span class="org-keyword">return</span> -1;
}

<span class="org-type">void</span> <span class="org-function-name">completions_exit</span>(<span class="org-type">void</span>)
{
    wait_for_completion(&amp;machine.crank_comp);
    wait_for_completion(&amp;machine.flywheel_comp);

    pr_info(<span class="org-string">"completions exit\n"</span>);
}

<span class="org-function-name">module_init</span>(completions_init);
<span class="org-function-name">module_exit</span>(completions_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Completions example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
La structure <i>machine</i> contient l'état de complétude de ces deux threads. À la sortie de chacune de ces threads, l'état associé est mis à jour pour signaler une terminaison, et <i>wait_for_completion</i> est utilisée par la thread flywheel pour s'assurer qu'elle ne démarre pas prématurément.
</p>

<p>
Ainsi, même si <i>flywheel_thread</i> est démarrée en premier, vous noterez, si vous chargez ce module avec de jeter un coup d'oeil aux entrées du journal du noyau, que la note "turning the crank" apparaît toujours en premier. C'est parce que la thread flywheel attend toujours la complétion de l'autre thread avant de s'exécuter.
</p>

<p>
Il existe d'autres versions de la fonction <i>wait_for_completion</i>, qui incluent des temporisations ou des interruptions, mais ce mécanisme basique conviendra dans la plupart des situations, en ayant l'avantage de limiter la complexité de votre module.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Eviter les collisions et les interblocages</h2>
<div class="outline-text-2" id="text-12">
<p>
Si des processus qui tournent sur différents processeurs ou dans différentes threads essaient d'accéder au même espace mémoire, il est possible que des choses surprenantes arrivent, voir que votre système se bloque. Pour éviter ces problèmes, plusieurs types de fonction d'exclusion mutuelles sont disponibles au sein du noyau. Celles-ci indiquent si une partie de code est "verrouillé" ou "libre", afin d'éviter des exécutions concurrentes du même code.
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">Mutex</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Vous pouvez utiliser les mutex noyau (exclusions mutuelles) de la même manière que vous les exécuteriez en espace utilisateur. Ce mécanisme sera suffisant pour éviter les collisions dans la plupart des cas.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/mutex.h&gt;</span>

<span class="org-function-name">DEFINE_MUTEX</span>(mymutex);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_mutex_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    pr_info(<span class="org-string">"example_mutex init\n"</span>);

    ret = mutex_trylock(&amp;mymutex);
    <span class="org-keyword">if</span> (ret != 0) {
        pr_info(<span class="org-string">"mutex is locked\n"</span>);

        <span class="org-keyword">if</span> (mutex_is_locked(&amp;mymutex) == 0)
            pr_info(<span class="org-string">"The mutex failed to lock!\n"</span>);

        mutex_unlock(&amp;mymutex);
        pr_info(<span class="org-string">"mutex is unlocked\n"</span>);
    }
    <span class="org-keyword">else</span>
        pr_info(<span class="org-string">"Failed to lock\n"</span>);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_mutex_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_mutex exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_mutex_init);
<span class="org-function-name">module_exit</span>(example_mutex_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Mutex example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">Verrou tournant</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Le verrou tournant, ou spinlock, est un mécanisme de verrou basé sur l'attente active ; La thread qui essaie d'acquérir une ressource vérouillée va mobiliser toutes les ressources du processeur en vue d'acquérir ce verrou. Elle va faire la demande de la ressource des millions de fois, jusqu'à ce qu'elle l'obtienne. C'est la raison pour laquelle vous ne devriez utiliser ce verrou que pour du code qui peut espérer réaliser sa tâche en moins de quelques millisecondes. Dans le cas contraire l'utilisateur risquera d'être témoin de ralentissements du système.
</p>

<p>
L'exemple ici est /"irq safe"/ dans le sens oùles interruptions qui peuvent arriver durant le verrou ne seront pas omises grâce à la variable <i>flags</i> qui les retiendra. Elles seront ensuite traitées quand le verrou sera libéré.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/spinlock.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-function-name">DEFINE_SPINLOCK</span>(sl_static);
<span class="org-type">spinlock_t</span> <span class="org-variable-name">sl_dynamic</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_static</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    spin_lock_irqsave(&amp;sl_static, flags);
    pr_info(<span class="org-string">"Locked static spinlock\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous devez &#234;tre s&#251;r de ce que vous</span>
<span class="org-comment">       faites. Parce que vous avez verrouill&#233;</span>
<span class="org-comment">       une ressource, et qu'un autre programme</span>
<span class="org-comment">       qui attendra l'acc&#232;s &#224; cette ressource</span>
<span class="org-comment">       utilisera TOUTES les ressources de</span>
<span class="org-comment">       votre processeur, ce code ne doit</span>
<span class="org-comment">       jamais demander plus de quelques</span>
<span class="org-comment">       millisecondes pour &#234;tre ex&#233;cut&#233;. </span><span class="org-comment-delimiter">*/</span>

    spin_unlock_irqrestore(&amp;sl_static, flags);
    pr_info(<span class="org-string">"Unlocked static spinlock\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_dynamic</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    spin_lock_init(&amp;sl_dynamic);
    spin_lock_irqsave(&amp;sl_dynamic, flags);
    pr_info(<span class="org-string">"Locked dynamic spinlock\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous devez &#234;tre s&#251;r de ce que vous</span>
<span class="org-comment">       faites. Parce que vous avez verrouill&#233;</span>
<span class="org-comment">       une ressource, et qu'un autre programme</span>
<span class="org-comment">       qui attendra l'acc&#232;s &#224; cette ressource</span>
<span class="org-comment">       utilisera TOUTES les ressources de</span>
<span class="org-comment">       votre processeur, ce code ne doit</span>
<span class="org-comment">       jamais demander plus de quelques</span>
<span class="org-comment">       millisecondes pour &#234;tre ex&#233;cut&#233;. </span><span class="org-comment-delimiter">*/</span>

    spin_unlock_irqrestore(&amp;sl_dynamic, flags);
    pr_info(<span class="org-string">"Unlocked dynamic spinlock\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_spinlock_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example spinlock started\n"</span>);

    example_spinlock_static();
    example_spinlock_dynamic();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_spinlock_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example spinlock exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_spinlock_init);
<span class="org-function-name">module_exit</span>(example_spinlock_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Spinlock example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3">Verrou lecture/écriture</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Le verrou de type lecture/écriture est une sorte de verrou tournant spécialisé, afin que vous puissiez exclusivement lire ou écrire vers une certaine ressource. Comme l'exemple de verrou tournant précédent, cet exemple est "irq safe", dans le sens où si d'autres fonctions doivent être appelées en raison d'interruptions reçues, leurs exécutions seront différées sans être oubliées. Comme précédemment, c'est une bonne idée de n'utiliser le verrou qu'un minimum de temps possible afin de ne pas ralentir le système. Ceci bien sûr afin d'éviter le soulèvement des utilisateurs contre le diktat de votre module.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-function-name">DEFINE_RWLOCK</span>(myrwlock);

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_read_lock</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    read_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Read Locked\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lecture </span><span class="org-comment-delimiter">*/</span>

    read_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Read Unlocked\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_write_lock</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">flags</span>;

    write_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Write Locked\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ecriture </span><span class="org-comment-delimiter">*/</span>

    write_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span class="org-string">"Write Unlocked\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_rwlock_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_rwlock started\n"</span>);

    example_read_lock();
    example_write_lock();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_rwlock_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_rwlock exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_rwlock_init);
<span class="org-function-name">module_exit</span>(example_rwlock_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Read/Write locks example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Bien sûr, si vous êtes certain qu'aucune fonction déclenchée par des interruptions ne pourra gêner votre algorithme, alors vous pouvez vous contenter des fonctions <i>read_lock(&amp;myrwlock)</i> et <i>read_unlock(&amp;myrwlock)/</i>
</p>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4">Opérations atomiques</h3>
<div class="outline-text-3" id="text-12-4">
<p>
Si vous réalisez des opérations arithmétiques simple : ajouter, soustraire ou réaliser des opérations bit-à-bit, alors il existe un autre moyen pour s'assurer, dans un monde où plusieurs processeurs et programmes tournent en concurrence, qu'un étranger ne vous a pas dérangé dans votre travail. En utilisant les opérations atomiques, vous êtes assuré que votre opération s'est déroulé exactement comme vous le souhaitez, et qu'un tierce programme n'a pas modifié la valeur sur laquelle vous travaillez en même temps que lui. En voici un exemple :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">BYTE_TO_BINARY_PATTERN</span> <span class="org-string">"%c%c%c%c%c%c%c%c"</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">BYTE_TO_BINARY</span>(<span class="org-variable-name">byte</span>)  \
  (byte &amp; 0x80 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x40 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x20 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x10 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x08 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x04 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x02 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>), \
  (byte &amp; 0x01 ? <span class="org-string">'1'</span> : <span class="org-string">'0'</span>)

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">atomic_add_subtract</span>(<span class="org-type">void</span>)
{
    <span class="org-type">atomic_t</span> <span class="org-variable-name">debbie</span>;
    <span class="org-type">atomic_t</span> <span class="org-variable-name">chris</span> = ATOMIC_INIT(50);

    atomic_set(&amp;debbie, 45);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;cr&#233;mentation atomique </span><span class="org-comment-delimiter">*/</span>
    atomic_dec(&amp;debbie);

    atomic_add(7, &amp;debbie);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Incr&#233;mentation atomique </span><span class="org-comment-delimiter">*/</span>
    atomic_inc(&amp;debbie);

    pr_info(<span class="org-string">"chris: %d, debbie: %d\n"</span>,
           atomic_read(&amp;chris), atomic_read(&amp;debbie));
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">atomic_bitwise</span>(<span class="org-type">void</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">word</span> = 0;

    pr_info(<span class="org-string">"Bits 0: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    set_bit(3, &amp;word);
    set_bit(5, &amp;word);
    pr_info(<span class="org-string">"Bits 1: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    clear_bit(5, &amp;word);
    pr_info(<span class="org-string">"Bits 2: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    change_bit(3, &amp;word);

    pr_info(<span class="org-string">"Bits 3: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    <span class="org-keyword">if</span> (test_and_set_bit(3, &amp;word))
        pr_info(<span class="org-string">"wrong\n"</span>);
    pr_info(<span class="org-string">"Bits 4: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));

    word = 255;
    pr_info(<span class="org-string">"Bits 5: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_atomic_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_atomic started\n"</span>);

    atomic_add_subtract();
    atomic_bitwise();

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_atomic_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"example_atomic exit\n"</span>);
}

<span class="org-function-name">module_init</span>(example_atomic_init);
<span class="org-function-name">module_exit</span>(example_atomic_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Atomic operations example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Remplacer les macros Print</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">Remplacement</h3>
<div class="outline-text-3" id="text-13-1">
<p>
Dans la section 1.2.1.2, j'ai dit que les interfaces graphiques et les modules ne vont pas bien ensemble. C'est vrai pour le développement de modules noyau, mais en situation réelle, vous souhaitez être capable d'envoyer des messages au terminal qui vous a demandé de charger le module en question.
</p>

<p>
"tty" est une abréviation de <i>teletype</i>: à l'origine, il s'agissait d'un périphérique matériel, une combinaison clavier-moniteur utilisée pour communiquer avec un système Unix. C'est aujourd'hui devenu, par abstraction, un flot de texte utilisé par un programme Unix, que ce soit un terminal physique, un terminal virtuel au sein d'une interface graphique, une connexion réseau utilisée par le réseau via ssh, et bien d'autres&#x2026;
</p>

<p>
Cette abstraction est implantée de la manière suivante : On dispose d'un pointeur, current, vers la tâche en cours d'exécution, à partir duquel on peut obtenir la structure tty de cette tâche. Ensuite, au sein de cette structure tty, on dispose d'un pointeur vers une fonction d'écriture, qui sera appelée pour écrire une chaîne de caractères sur le terminal du programme en cours.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  print_string.c - Affichage de donn&#233;es sur le terminal, qu'il</span>
<span class="org-comment"> *  s'agisse d'un terminal graphique, d'une liaison ssh, etc.</span>
<span class="org-comment"> *  Pour agir, il suffit d'&#233;crire une cha&#238;ne de caract&#232;res sur le</span>
<span class="org-comment"> *  terminal associ&#233; &#224; la t&#226;che courante.</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/sched.h&gt;</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">Fournit l'acc&#232;s &#224; la structure   *</span>
<span class="org-comment">                            * associ&#233;e &#224; la t&#226;che courrante    </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/tty.h&gt;</span>     <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour les d&#233;clarations du tty     </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/version.h&gt;</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour la macro LINUX_VERSION_CODE </span><span class="org-comment-delimiter">*/</span>

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Peter Jay Salzman"</span>);

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">print_string</span>(<span class="org-type">char</span> *<span class="org-variable-name">str</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">tty_struct</span> *<span class="org-variable-name">my_tty</span>;
    <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">tty_operations</span> *<span class="org-variable-name">ttyops</span>;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * La location de la structure tty a chang&#233;</span>
<span class="org-comment">     * depuis la version 2.6.6 du noyau</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,5) )
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Pour le tty de la t&#226;che courante, pour les noyaux plus vieux que 2.6.6</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    my_tty = current-&gt;tty;
<span class="org-preprocessor">#else</span>
    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Pour le tty de la t&#226;che courante, pour les noyaux les plus r&#233;cents</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    my_tty = get_current_tty();
<span class="org-preprocessor">#endif</span>
    ttyops = my_tty-&gt;driver-&gt;ops;

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * Si my_tty est NULL, &#231;a signifie qu'aucun tty n'est associ&#233; &#224; la</span>
<span class="org-comment">     * t&#226;che courante. (Cela peut vous arriver, par exemple si c'est un</span>
<span class="org-comment">     * d&#233;mon). Si c'est le cas, vous &#234;tes pieds et poings li&#233;s et ne</span>
<span class="org-comment">     * pouvez rien faire.</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (my_tty != <span class="org-constant">NULL</span>) {

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * my_tty-&gt;driver est une structure qui contient les fonctions</span>
<span class="org-comment">         * du tty, dont l'une d'entre elle (write) est utilis&#233;e pour</span>
<span class="org-comment">         * &#233;crire des cha&#238;nes de caract&#232;res au tty.</span>
<span class="org-comment">         * On peut s'en servir pour &#233;crire une cha&#238;ne, qu'elle soit</span>
<span class="org-comment">         * localis&#233;e dans l'espace utilisateur, ou dans l'espace noyau</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le premier param&#232;tre de la fonction est le tty vers lequel</span>
<span class="org-comment">         * vous souhaitez &#233;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le second param&#232;tre est un bool&#233;en qui stipule si la cha&#238;ne</span>
<span class="org-comment">         * de caract&#232;re re&#231;ue vient de l'espace noyau (0/faux), o&#249;</span>
<span class="org-comment">         * s'il vient de l'espace utilisateur (vrai/positif).</span>
<span class="org-comment">         * Attention cependant : Depuis les versions du Noyau sup&#233;rieures</span>
<span class="org-comment">         * &#224; 2.6.9, ce param&#232;tre a &#233;t&#233; supprim&#233;.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le param&#232;tre suivant est un pointeur vers la cha&#238;ne de</span>
<span class="org-comment">         * caract&#232;res &#224; &#233;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Le dernier param&#232;tre est la taille de la cha&#238;ne de caract&#232;res</span>
<span class="org-comment">         * &#224; &#233;crire.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * Comme vous le verrez plus bas, il est parfois n&#233;cessaire</span>
<span class="org-comment">         * d'utiliser le pr&#233;processeur pour cr&#233;er du code qui marchera</span>
<span class="org-comment">         * sur diff&#233;rentes versions du noyau. L'approche na&#239;vre qu'on a</span>
<span class="org-comment">         * adopt&#233; ici est loin d'&#234;tre parfaite. Le meilleur moyen de</span>
<span class="org-comment">         * r&#233;gler ces probl&#232;mes  est d&#233;crit dans la seconde section de</span>
<span class="org-comment">         * linux/Documentation/SubmittingPatches</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>
        (ttyops-&gt;write) (my_tty,      <span class="org-comment-delimiter">/* </span><span class="org-comment">Le tty </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
                         0,            <span class="org-comment-delimiter">/* </span><span class="org-comment">La cha&#238;ne de caract&#232;res           *</span>
<span class="org-comment">                                        * est localis&#233;e en espace           *</span>
<span class="org-comment">                                        * noyau                             </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#endif</span>
                         str,          <span class="org-comment-delimiter">/* </span><span class="org-comment">La cha&#238;ne de caract&#232;res</span>
<span class="org-comment">                                        * &#224; &#233;crire                          </span><span class="org-comment-delimiter">*/</span>
                         strlen(str)); <span class="org-comment-delimiter">/* </span><span class="org-comment">Taille de la cha&#238;ne de caract&#232;res </span><span class="org-comment-delimiter">*/</span>

        <span class="org-comment-delimiter">/*</span>
<span class="org-comment">         * Les ttys &#233;taient &#224; l'origine des p&#233;riph&#233;riques physiques</span>
<span class="org-comment">         * qui, le plus souvant, suivaient &#224; la lettre la r&#232;gle ASCII</span>
<span class="org-comment">         * standard. En ASCII, pour acc&#232;der &#224; une nouvelle ligne,</span>
<span class="org-comment">         * vous avez besoin de deux caract&#232;res : un retour de chariot</span>
<span class="org-comment">         * et un saut de ligne. Sur Unix, le saut de ligne sert aussi</span>
<span class="org-comment">         * de retour chariot, mais pas pour votre tty. C'est pourquoi</span>
<span class="org-comment">         * on ne peut donc pas se contenter d'un \n. Il faut rajouter</span>
<span class="org-comment">         * un retour chariot, ou sinon quoi notre terminal continuera</span>
<span class="org-comment">         * bien son affichage sur la ligne suivante, mais sur la m&#234;me</span>
<span class="org-comment">         * colonne.</span>
<span class="org-comment">         *</span>
<span class="org-comment">         * C'est pourquoi les fichiers de texte sont diff&#233;rents selon</span>
<span class="org-comment">         * Unix ou Windows. Dans CP/M est ses d&#233;riv&#233;s, tel que MS-DOS</span>
<span class="org-comment">         * et MS-Windows, la r&#232;gle ASCII a &#233;t&#233; suivie &#224; la lettre, ce</span>
<span class="org-comment">         * qui signifie qu'une nouvelle ligne inclut un saut de ligne</span>
<span class="org-comment">         * ET un retour chariot (d'ou le \rn).</span>
<span class="org-comment">         </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
        (ttyops-&gt;write) (my_tty, 0, <span class="org-string">"\015\012"</span>, 2);
<span class="org-preprocessor">#else</span>
        (ttyops-&gt;write) (my_tty, <span class="org-string">"\015\012"</span>, 2);
<span class="org-preprocessor">#endif</span>
    }
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> print_string_init(<span class="org-type">void</span>)
{
    print_string(<span class="org-string">"The module has been inserted.  Hello world!"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> print_string_exit(<span class="org-type">void</span>)
{
    print_string(<span class="org-string">"The module has been removed.  Farewell world!"</span>);
}

<span class="org-function-name">module_init</span>(print_string_init);
<span class="org-function-name">module_exit</span>(print_string_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">Faire clignoter les LEDS du clavier</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Vous chercherez parfois un moyen plus simple et plus concret de communiquer avec le monde extérieur. Un exemple frappant : les LEDs de votre clavier qui vous signalent que vous êtes en mode majuscule ou minuscule. On peut se servir de ces LEDs pour attirer l'attention ou afficher un état de votre système. Les LEDs sont présents sur quasiment tous les claviers, dans quel cas ils sont toujours visibles, n'ont pas besoin d'être installés, en plus de quoi leur usage est plus simple et discret que l'écriture sur un terminal ou sur un fichier.
</p>

<p>
Le code suivant est un exemple de noyau minimal qui permet, une fois qu'il est chargé de faire clignoter les LEDs du clavier jusqu'à son déchargement du noyau.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  kbleds.c - Fait clignoter les LEDs du clavier tant que le module est</span>
<span class="org-comment"> *  charg&#233; au sein du noyau</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/vt_kern.h&gt;</span>              <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#232;s &#224; fg_console    </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/tty.h&gt;</span>                  <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#232;s &#224; fg_console,   *</span>
<span class="org-comment">                                         * et &#224; la macroMAX_NR_CONSOLES </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kd.h&gt;</span>                   <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#232;s &#224; KDSETLED      </span><span class="org-comment-delimiter">*/</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/vt.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/console_struct.h&gt;</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">Pour l'acc&#232;s &#224; vc_cons       </span><span class="org-comment-delimiter">*/</span>

MODULE_DESCRIPTION(<span class="org-string">"Example module illustrating the use of Keyboard LEDs."</span>);
MODULE_AUTHOR(<span class="org-string">"Daniele Paolo Scarpazza"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);

<span class="org-keyword">struct</span> <span class="org-type">timer_list</span> <span class="org-variable-name">my_timer</span>;
<span class="org-keyword">struct</span> <span class="org-type">tty_driver</span> *<span class="org-variable-name">my_driver</span>;
<span class="org-type">char</span> <span class="org-variable-name">kbledstatus</span> = 0;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">BLINK_DELAY</span>   HZ/5
<span class="org-preprocessor">#define</span> <span class="org-variable-name">ALL_LEDS_ON</span>   0x07
<span class="org-preprocessor">#define</span> <span class="org-variable-name">RESTORE_LEDS</span>  0xFF

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * La fonction my_timer_func fait clignoter les LEDs du clavier de mani&#232;re</span>
<span class="org-comment"> * p&#233;riodique en appelant la commande KDSETLED (qui est un appel ioctl sur</span>
<span class="org-comment"> * une console virtuelle) sur le pilote du clavier.</span>
<span class="org-comment"> * Pour en apprendre plus sur les op&#233;rations sur les consoles virtuelles,</span>
<span class="org-comment"> * regardez le fichier :</span>
<span class="org-comment"> *     /usr/src/linux/drivers/char/vt_ioctl.c, fonction vt_ioctl().</span>
<span class="org-comment"> *</span>
<span class="org-comment"> * L'argument de KDSETLED est affect&#233; &#224; tour de r&#244;le &#224; 0x07 et &#224; 0xFF.</span>
<span class="org-comment"> * 0x07 conduit les Leds &#224; &#234;tre affect&#233;es &#224; LED_SHOW_IOCTL, ce qui les allume</span>
<span class="org-comment"> * 0xFF affecte les Leds &#224; LED_SHOW_FLAGS, o&#249; ces derni&#232;res correspondes &#224;</span>
<span class="org-comment"> * l'&#233;tat du clavier.</span>
<span class="org-comment"> * Pour en apprendre plus, regardez :</span>
<span class="org-comment"> *     /usr/src/linux/drivers/char/keyboard.c, fonction setledstate().</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">my_timer_func</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">ptr</span>)
{
    <span class="org-type">unsigned</span> <span class="org-type">long</span> *<span class="org-variable-name">pstatus</span> = (<span class="org-type">unsigned</span> <span class="org-type">long</span> *)ptr;
    <span class="org-keyword">struct</span> <span class="org-type">tty_struct</span>* <span class="org-variable-name">t</span> = vc_cons[fg_console].d-&gt;port.tty;

    <span class="org-keyword">if</span> (*pstatus == ALL_LEDS_ON)
        *pstatus = RESTORE_LEDS;
    <span class="org-keyword">else</span>
        *pstatus = ALL_LEDS_ON;

    (my_driver-&gt;ops-&gt;ioctl) (t, KDSETLED, *pstatus);

    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">__init</span> kbleds_init(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"kbleds: loading\n"</span>);
    pr_info(<span class="org-string">"kbleds: fgconsole is %x\n"</span>, fg_console);
    <span class="org-keyword">for</span> (i = 0; i &lt; MAX_NR_CONSOLES; i++) {
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>vc_cons[i].d)
            <span class="org-keyword">break</span>;
        pr_info(<span class="org-string">"poet_atkm: console[%i/%i] #%i, tty %lx\n"</span>, i,
               MAX_NR_CONSOLES, vc_cons[i].d-&gt;vc_num,
               (<span class="org-type">unsigned</span> <span class="org-type">long</span>)vc_cons[i].d-&gt;port.tty);
    }
    pr_info(<span class="org-string">"kbleds: finished scanning consoles\n"</span>);

    my_driver = vc_cons[fg_console].d-&gt;port.tty-&gt;driver;
    pr_info(<span class="org-string">"kbleds: tty driver magic %x\n"</span>, my_driver-&gt;magic);

    <span class="org-comment-delimiter">/*</span>
<span class="org-comment">     * R&#232;gle le temporisateur de clignotement pour la premi&#232;re fois</span>
<span class="org-comment">     </span><span class="org-comment-delimiter">*/</span>
    timer_setup(&amp;my_timer, (<span class="org-type">void</span>*)&amp;my_timer_func, (<span class="org-type">unsigned</span> <span class="org-type">long</span>)&amp;kbledstatus);
    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">__exit</span> kbleds_cleanup(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"kbleds: unloading...\n"</span>);
    del_timer(&amp;my_timer);
    (my_driver-&gt;ops-&gt;ioctl) (vc_cons[fg_console].d-&gt;port.tty,
                             KDSETLED, RESTORE_LEDS);
}

<span class="org-function-name">module_init</span>(kbleds_init);
<span class="org-function-name">module_exit</span>(kbleds_cleanup);
</pre>
</div>

<p>
Si aucun des exemples présents dans ce chapitre ne répond à vos besoins en terme de débogage, il existe encore quelques astuces à essayer. Vous êtes vous déjà demandé à quoi la macro CONFIG_LL_DEBUG du make menuconfig sert ? Si vous l'activez, alors vous aurez un accès bas niveau au port série. Bien que ça ne semble pas très utile, sachez que vous pourrez alors modifier <b>kernel/printk.c</b> ou n'importe quel autre appel système pour utiliser printascii, ce qui vous permettra de laisser une trace sur absolument tout ce que fait votre code, de près ou de loin, sur le port série. Si vous souhaitez porter le noyau sur une nouvelle architecture, cette manipulation est généralement la première à réaliser. Se connecter à votre noyau à travers une console via le réseau pourra aussi être une chose très utile à des fin de débogage.
</p>

<p>
Bien que vous ayez lu quelques manières de déboguer, sachez que le débogage est presque toujours une méthode très intrusive vis-à-vis de votre code. La simple insertion de code de débogage pour localiser un problème peut changer en profondeur votre code jusqu'à ce que vous ayez l'impression que votre problème est résolu. C'est un problème qui vous arrivera tôt ou tard. C'est la raison pour laquelle vous devrez limiter le code de débogage au strict minimum, et surtout faire des essais, sans cesse et sans arrêt, pour s'assurer que les problèmes ne reviendront pas en situation de production.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Tâches ordonnancées</h2>
<div class="outline-text-2" id="text-14">
<p>
Il existe deux manières de lancer un tâche : via le mécanisme de tasklet et via les files de travaux. Les tasklets sont un moyen rapide et facile d'ordonnancer une tâche unique, par exemple en la déclanchant suite à une interruption, alors que les files de travaux sont plus complexes, mais plus efficaces pour exécuter plusieurs tâches.
</p>
</div>

<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">Tasklets</h3>
<div class="outline-text-3" id="text-14-1">
<p>
Voici un exemple de module qui utilise les tasklets. La fonction <i>tasklet_fn</i> est lancée pour quelques secondes, durant lesquelles l'exécution de <i>example_tasklet_init</i> continue jusqu'à se terminer.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">tasklet_fn</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">data</span>)
{
    pr_info(<span class="org-string">"Example tasklet starts\n"</span>);
    mdelay(5000);
    pr_info(<span class="org-string">"Example tasklet ends\n"</span>);
}

<span class="org-function-name">DECLARE_TASKLET</span>(mytask, tasklet_fn, 0L);

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">example_tasklet_init</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"tasklet example init\n"</span>);
    tasklet_schedule(&amp;mytask);
    mdelay(200);
    pr_info(<span class="org-string">"Example tasklet init continues...\n"</span>);
    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">example_tasklet_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"tasklet example exit\n"</span>);
    tasklet_kill(&amp;mytask);
}

<span class="org-function-name">module_init</span>(example_tasklet_init);
<span class="org-function-name">module_exit</span>(example_tasklet_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Tasklet example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Ansi, avec cet exemple, les notes au sein de <i>dmesg</i> devraient contenir :
</p>

<div class="org-src-container">

<pre class="src src-bash">tasklet example init
Example tasklet starts
Example tasklet init continues...
Example tasklet ends
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">Files de travaux</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Pour ajouter une tâche à l'ordonnanceur, vous pouvez utiliser une file de travaux. Le noyau utilise ensuite le Completely Fair Scheduler (CFS) (entendez l'ordonnanceur parfaitement équitable) pour exécuter les travaux dans cette file d'attente.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/init.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/workqueue.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">workqueue_struct</span> *<span class="org-variable-name">queue</span>=<span class="org-constant">NULL</span>;
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">work_struct</span> <span class="org-variable-name">work</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">work_handler</span>(<span class="org-keyword">struct</span> <span class="org-type">work_struct</span> *<span class="org-variable-name">data</span>)
{
    pr_info (<span class="org-string">"work handler function.\n"</span>);
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    queue = alloc_workqueue(<span class="org-string">"HELLOWORLD"</span>, WQ_UNBOUND, 1);
    INIT_WORK(&amp;work, work_handler);
    schedule_work(&amp;work);

    <span class="org-keyword">return</span> 0;

}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    destroy_workqueue(queue);
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Workqueue example"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Gestionnaire d'interruptions</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">Gestionnaire d'interruptions</h3>
<div class="outline-text-3" id="text-15-1">
<p>
À l'exception du dernier chapitre, tout ce qu'on a réalisé dans le noyau jusqu'ici était du code appelé par un processus qui le demandait, que ce soit à travers un fichier spécial, à travers l'envoi d'un ioctl(), ou un appel système. Mais ce n'est pas la principale fonction d'un noyau. Un système d'exploitation a la tâche essentielle de communiquer avec le matériel connecté à la machine.
</p>

<p>
Il existe deux interactions différentes entre le processeur et les autres périphériques. La première, c'est quand le processeur ordonne des actions au matériel, et les transferts de données qui en découlent. La seconde interaction, appelée interruption, advient quand le matériel doit informer le processus d'une situation particulière. Les interruptions sont dures à implanter, parce que le développeur doit tenir compte des contraintes matérielles que le processeur ignore. Par exemple, de nombreux périphériques ont une mémoire très limitée. Si vous ne lisez pas les bons registres du périphérique quand elle est disponible, cette information risque d'être perdue très vite. Par exemple, certains claviers ont un registre unique qui contient la dernière touche tapée par l'utilisateur. Si l'information n'est pas lue avant que l'utilisateur appuie sur une nouvelle touche, cette information risque d'être perdue. Pour éviter ce cas, le clavier va envoyer une interruption au système pour le prévenir qu'une nouvelle information est disponible.
</p>

<p>
Sous Linux, les interruptions matérielles sont appelées IRQ, pour requêtes d'interruption. Il existe deux types d'IRQ : les courtes et les longues. Une IRQ courte est une IRQ qui doit être traitée en très peu de temps, pendant lequel aucune autre interruption ne pourra être prise en compte. Une IRQ longue peut au contraire durer plus longtemps et peut être interrompue par d'autres interruptions d'un matériel différent (mais pas du même matériel). Dans chaque cas où la situation le permet, il est préférable d'utiliser les IRQ longues.
</p>

<p>
Quand le processeur reçoit une interruption, il arrête ce qu'il fait (à moins qu'il ne soit déjà occupé par une interruption plus importante, dans quel cas il s'occupe de l'interruption la plus importante), sauvegarde certains paramètres sur la pile d'exécution, et appelle le gestionnaire d'interruption. Ce qui signifie que tout n'est pas permis dans le gestionnaire d'interruption. C'est pourquoi le gestionnaire d'interruption se contente de faire ce qui est urgent, en général il s'agit de lire ou d'écrire dans les registres du matériel, avant d'ordonnancer la gestion de cette nouvelle information afin de s'en occuper plus tard (c'est ce qu'on appelle le "bottom half", ou la partie immergée). Finalement, le gestionnaire d'interruption rend la main à la tâche qui a été interrompue par l'interruption. Le noyau garantit ensuite d'appeler la partie immergée de l'interruption dès que possible &#x2013; et à ce moment, le noyau aura tous les droits.
</p>

<p>
Le moyen de procéder de la sorte est d'appeler <b>request_irq()</b> afin que votre gestionnaire d'interruption soit appelé quand l'IRQ associée est reçut.
</p>

<p>
Dans la pratique, la gestion des IRQ est un peu plus complexe. La plupart des périphériques sont conçus de telle sorte que deux gestionnaires devront être appelés en cascade. Ainsi, toutes les IRQs d'un gestionnaire d'interruption B seront reconduites vers une certaine IRQ d'un autre gestionnaire d'interruption A. Bien sûr, ça nécessite que le noyau cherche quelle était l'IRQ qui était vraiment lancée par le matériel. D'autres architectures matérielles proposent d'autres mécanismes d'interruptions, appelés "fast IRQ" (FIQ) pour requête d'interruption rapide. Comme ils sont relatifs à certaines architectures, ils doivent être codés en assembleur. C'est la raison pour laquelle ils sont d'une certaine manière à l'écart du noyau. Ils peuvent être conçus de la même manière que les autres IRQs mais dans ce cas ils ne seraient pas plus rapides que les requêtes interruptions "normales". Les noyaux conçus pour les systèmes multi-processeurs (les noyaux SMP, pour Symmetric MultiProcessor) ont encore plus de problèmes à régler. Dans ces noyaux, au moment où une interruption est levée, il faut non seulement trouver quelle IRQs est levée, mais il faut aussi prendre en compte à quel processeur elle était destinée. Cela dépasse le cadre de ce cours, mais les personnes qui souhaitent en savoir plus devraient faire des recherches sur les "Advanced Programmable Interrupt Controller".
</p>

<p>
La fonction <b>request_irq()</b> qui permet d'activer une fonction qui va gérer l'interruption reçoit un numéro de requête d'interruption, une fonction, des drapeaux, un nom pour le fichier <i>proc</i> de l'interruption et un paramètre à passer au gestionnaire d'interruption. Il n'y a qu'un certain nombre de requêtes d'interruption, et ce nombre dépend du matériel. Les drapeaux qui sont passés peuvent inclure SA_SHIRQ, qui indique que vous êtes en train de partager la requête d'interruption en cours avec un autre gestionnaire d'interruption (en général parce que plusieurs périphériques matériels partagent la même requête d'interruption), ou SA_INTERRUPT, qui indique que vous traitez une interruption courte. Cette fonction ne se terminera avec succès que s'il n'existe pas déjà un gestionnaire pour cette interuption, ou si les deux gestionnaires ont conscience de partager une même interruption.
</p>
</div>
</div>

<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">Détection de pression de bouton</h3>
<div class="outline-text-3" id="text-15-2">
<p>
Les ordinateurs monocartes les plus populaires, comme les Raspberry Pis ou les Beagleboard disposent de plusieurs broches GPIO (traduites littéralement par Entrée/Sortie pour un Usage Général). Vous pouvez attacher un bouton poussoir à ces broches. Vous aurez ensuite deux manière différentes de savoir si un utilisateur appuie sur l'un des boutons. Soit en créant une tâche qui va gaspiller du temps de processeur et de l'énergie en regardant périodiquement si le bouton est appuyé, ou faire en sorte que l'appui déclenche une interruption, qui sera gérée par le processeur en appelant la fonction de gestion d'interruption associée.
</p>

<p>
Voilà un exemple de code pour Raspberry PI, où des boutons sont connectés aux broches 17 et 18 et une LED est connectée à la broche 4. Vous pouvez bien sûr changer ces numéros pour qu'ils correspondent à votre machine.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> *  intrpt.c - G&#232;re les GPIOs avec les interruptions</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Copyright (C) 2017 par Bob Mottram</span>
<span class="org-comment"> *  Bas&#233; sur l'exemple sur Raspberry Py de Stehan Wendler(devnull@kaltpost.de)</span>
<span class="org-comment"> *  de:</span>
<span class="org-comment"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Appuyez sur un boutton pour allumer une LED,</span>
<span class="org-comment"> *  et sur un autre pour l'&#233;teindre</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/gpio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">button_irqs</span>[] = { -1, -1 };

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;finit les GPIOs pour les LEDs.              *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span class="org-string">"LED 1"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;finit les GPIOs pour les boutons.           *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">buttons</span>[] = {
        { 17, GPIOF_IN, <span class="org-string">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span class="org-string">"LED 1 OFF BUTTON"</span> }
};

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction d'interruption qui sera appel&#233;e quand un bouton sera press&#233;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">irqreturn_t</span> <span class="org-function-name">button_isr</span>(<span class="org-type">int</span> <span class="org-variable-name">irq</span>, <span class="org-type">void</span> *<span class="org-variable-name">data</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Premier bouton </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (irq == button_irqs[0] &amp;&amp; <span class="org-negation-char">!</span>gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Second bouton </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">else</span> <span class="org-keyword">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span class="org-keyword">return</span> IRQ_HANDLED;
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Les registres correspondant aux broches associ&#233;es aux LEDs </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Les registres correspondant aux broches associ&#233;es aux bouttons </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail1</span>;
    }

    pr_info(<span class="org-string">"Current button1 value: %d\n"</span>,
           gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
           button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button1"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
           button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button2"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail3</span>;
    }

    <span class="org-keyword">return</span> 0;

<span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoie ce qui a d&#233;j&#224; &#233;t&#233; fait en cas d'&#233;chec </span><span class="org-comment-delimiter">*/</span>
<span class="org-constant">fail3</span>:
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);

<span class="org-constant">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span class="org-constant">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">return</span> ret;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lib&#232;re les interruptions </span><span class="org-comment-delimiter">*/</span>
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);
    free_irq(button_irqs[1], <span class="org-constant">NULL</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Eteint les LEDs </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Suppression </span><span class="org-comment-delimiter">*/</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Handle some GPIO interrupts"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">Partie immergée d'une interruption</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Supposez maintenant que vous devez faire beaucoup de choses au sein de votre gestionnaire d'interruption. La manière la plus simple de procéder ainsi sans désactiver les interruptions pour un long délai est de combiner ce gestionnaire avec le mécanisme de tasklet. Ainsi, le gros de travail est déporté vers l'ordonnanceur.
</p>

<p>
L'exemple plus bas modifie l'exemple précédent pour lancer une tâche additionnelle quand une interruption est levée.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * bottomhalf.c - Gestion d'interruption utilisant la partie immerg&#233;e</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Copyright (C) 2017 par Bob Mottram</span>
<span class="org-comment"> *  Bas&#233; sur l'exemple pour rasp de Stefan Wendler (devnull@kaltpost.de)</span>
<span class="org-comment"> *  disponible ici :</span>
<span class="org-comment"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span class="org-comment"> *</span>
<span class="org-comment"> *  Appuyez sur un bouton pour allumer une LED,</span>
<span class="org-comment"> *  et sur un autre pour l'&#233;teindre</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/gpio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/delay.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/interrupt.h&gt;</span>

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">button_irqs</span>[] = { -1, -1 };

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;finit les GPIOs pour les LEDs.              *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span class="org-string">"LED 1"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">D&#233;finit les GPIOs pour les boutons.           *</span>
<span class="org-comment"> * Changez ces valeurs en fonction de votre rasp </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">gpio</span> <span class="org-variable-name">buttons</span>[] = {
        { 17, GPIOF_IN, <span class="org-string">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span class="org-string">"LED 1 OFF BUTTON"</span> }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">Tasklet qui contient du code long &#224; s'ex&#233;cuter </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">bottomhalf_tasklet_fn</span>(<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">data</span>)
{
    pr_info(<span class="org-string">"Bottom half tasklet starts\n"</span>);
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous pouvez ins&#233;rer du code lourd &#224; ex&#233;cuter </span><span class="org-comment-delimiter">*/</span>
    mdelay(500);
    pr_info(<span class="org-string">"Bottom half tasklet ends\n"</span>);
}

<span class="org-function-name">DECLARE_TASKLET</span>(buttontask, bottomhalf_tasklet_fn, 0L);

<span class="org-comment-delimiter">/*</span>
<span class="org-comment"> * Fonction d'interruption : D&#233;clench&#233;e quand un bouton est appuy&#233;</span>
<span class="org-comment"> </span><span class="org-comment-delimiter">*/</span>
<span class="org-keyword">static</span> <span class="org-type">irqreturn_t</span> <span class="org-function-name">button_isr</span>(<span class="org-type">int</span> <span class="org-variable-name">irq</span>, <span class="org-type">void</span> *<span class="org-variable-name">data</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Ici vous pouvez ins&#233;rer du code rapide &#224; ex&#233;cuter </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (irq == button_irqs[0] &amp;&amp; <span class="org-negation-char">!</span>gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span class="org-keyword">else</span> <span class="org-keyword">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Chargez maintenant le reste    *</span>
<span class="org-comment">     * (la partie la plus &#233;nergivore) *</span>
<span class="org-comment">     * de la t&#226;che &#224; ex&#233;cuter         </span><span class="org-comment-delimiter">*/</span>
    tasklet_schedule(&amp;buttontask);

    <span class="org-keyword">return</span> IRQ_HANDLED;
}

<span class="org-type">int</span> <span class="org-function-name">init_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Enregistrement des broches li&#233;es aux LEDs </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Enregistrement des broches li&#233;es aux boutons </span><span class="org-comment-delimiter">*/</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail1</span>;
    }

    pr_info(<span class="org-string">"Current button1 value: %d\n"</span>,
           gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
           button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button1"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span class="org-keyword">if</span> (ret &lt; 0) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span class="org-string">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
           button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span class="org-string">"gpiomod#button2"</span>, <span class="org-constant">NULL</span>);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to request IRQ: %d\n"</span>, ret);
        <span class="org-keyword">goto</span> <span class="org-constant">fail3</span>;
    }

    <span class="org-keyword">return</span> 0;

<span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoyage de ce qui a &#233;t&#233; ex&#233;cut&#233;, en cas d'&#233;chec </span><span class="org-comment-delimiter">*/</span>
<span class="org-constant">fail3</span>:
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);

<span class="org-constant">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span class="org-constant">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span class="org-keyword">return</span> ret;
}

<span class="org-type">void</span> <span class="org-function-name">cleanup_module</span>()
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;

    pr_info(<span class="org-string">"%s\n"</span>, __func__);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Lib&#233;ration des interruptions </span><span class="org-comment-delimiter">*/</span>
    free_irq(button_irqs[0], <span class="org-constant">NULL</span>);
    free_irq(button_irqs[1], <span class="org-constant">NULL</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Extinction des LEDs </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Suppression </span><span class="org-comment-delimiter">*/</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Interrupt with top and bottom half"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Cryptage</h2>
<div class="outline-text-2" id="text-16">
<p>
À l'aube de l'internet, le monde était bienveillant&#x2026; mais tout ne s'est pas passé comme prévu. Quand la première version de ce guide a été écrite, le monde de l'informatique était bien plus innocent et tout le monde se fichait du cryptage - en tout cas c'était le cas des développeurs noyau. C'est n'est plus le cas de nos jours. Pour gérer le cryptage, le noyau a sa propre API qui fournit des méthodes de cryptage, de décryptage, et votre fonction de hachage préférée.
</p>
</div>

<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1">Fonction de hachage</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Le hachage d'une information et sa vérification sont des opérations communes. Voilà en exemple pour hacher une donnée avec l'algorithme sha256 au sein d'un module noyau :
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;crypto/internal/hash.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SHA256_LENGTH</span> (256/8)

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">show_hash_result</span>(<span class="org-type">char</span> * <span class="org-variable-name">plaintext</span>, <span class="org-type">char</span> * <span class="org-variable-name">hash_sha256</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-type">char</span> <span class="org-variable-name">str</span>[SHA256_LENGTH*2 + 1];

    pr_info(<span class="org-string">"sha256 test for string: \"%s\"\n"</span>, plaintext);
    <span class="org-keyword">for</span> (i = 0; i &lt; SHA256_LENGTH ; i++)
        sprintf(&amp;str[i*2],<span class="org-string">"%02x"</span>, (<span class="org-type">unsigned</span> <span class="org-type">char</span>)hash_sha256[i]);
    str[i*2] = 0;
    pr_info(<span class="org-string">"%s\n"</span>, str);
}

<span class="org-type">int</span> <span class="org-function-name">cryptosha256_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">char</span> * <span class="org-variable-name">plaintext</span> = <span class="org-string">"This is a test"</span>;
    <span class="org-type">char</span> <span class="org-variable-name">hash_sha256</span>[SHA256_LENGTH];
    <span class="org-keyword">struct</span> <span class="org-type">crypto_shash</span> *<span class="org-variable-name">sha256</span>;
    <span class="org-keyword">struct</span> <span class="org-type">shash_desc</span> *<span class="org-variable-name">shash</span>;

    sha256 = crypto_alloc_shash(<span class="org-string">"sha256"</span>, 0, 0);
    <span class="org-keyword">if</span> (IS_ERR(sha256))
        <span class="org-keyword">return</span> -1;

    shash =
        kmalloc(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">shash_desc</span>) + crypto_shash_descsize(sha256),
                GFP_KERNEL);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>shash)
        <span class="org-keyword">return</span> -ENOMEM;

    shash-&gt;tfm = sha256;
    shash-&gt;flags = 0;

    <span class="org-keyword">if</span> (crypto_shash_init(shash))
        <span class="org-keyword">return</span> -1;

    <span class="org-keyword">if</span> (crypto_shash_update(shash, plaintext, strlen(plaintext)))
        <span class="org-keyword">return</span> -1;

    <span class="org-keyword">if</span> (crypto_shash_final(shash, hash_sha256))
        <span class="org-keyword">return</span> -1;

    kfree(shash);
    crypto_free_shash(sha256);

    show_hash_result(plaintext, hash_sha256);

    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cryptosha256_exit</span>(<span class="org-type">void</span>)
{
}

<span class="org-function-name">module_init</span>(cryptosha256_init);
<span class="org-function-name">module_exit</span>(cryptosha256_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"sha256 hash test"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>

<p>
Pour créer et installer le module :
</p>

<div class="org-src-container">

<pre class="src src-sh">make
sudo insmod cryptosha256.ko
dmesg
</pre>
</div>

<p>
Vous devriez vous apercevoir que la chaîne de caractère a été hachée.
</p>

<p>
Finalement, enlevez le module :
</p>

<div class="org-src-container">

<pre class="src src-sh">sudo rmmod cryptosha256
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2">Cryptage par clé symétrique</h3>
<div class="outline-text-3" id="text-16-2">
<p>
Voici un exemple de cryptage de clé symétrique d'une chaîne de caractères en utilisant l'algorithme AES et une clé secrète associée.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;crypto/internal/skcipher.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/crypto.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">SYMMETRIC_KEY_LENGTH</span> 32
<span class="org-preprocessor">#define</span> <span class="org-variable-name">CIPHER_BLOCK_SIZE</span>    16

<span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> {
    <span class="org-keyword">struct</span> <span class="org-type">completion</span> <span class="org-variable-name">completion</span>;
    <span class="org-type">int</span> <span class="org-variable-name">err</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> {
    <span class="org-keyword">struct</span> <span class="org-type">scatterlist</span> <span class="org-variable-name">sg</span>;
    <span class="org-keyword">struct</span> <span class="org-type">crypto_skcipher</span> * <span class="org-variable-name">tfm</span>;
    <span class="org-keyword">struct</span> <span class="org-type">skcipher_request</span> * <span class="org-variable-name">req</span>;
    <span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> <span class="org-variable-name">result</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">scratchpad</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">ciphertext</span>;
    <span class="org-type">char</span> * <span class="org-variable-name">ivdata</span>;
};

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> <span class="org-variable-name">sk</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test_skcipher_finish</span>(<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>)
{
    <span class="org-keyword">if</span> (sk-&gt;tfm)
        crypto_free_skcipher(sk-&gt;tfm);
    <span class="org-keyword">if</span> (sk-&gt;req)
        skcipher_request_free(sk-&gt;req);
    <span class="org-keyword">if</span> (sk-&gt;ivdata)
        kfree(sk-&gt;ivdata);
    <span class="org-keyword">if</span> (sk-&gt;scratchpad)
        kfree(sk-&gt;scratchpad);
    <span class="org-keyword">if</span> (sk-&gt;ciphertext)
        kfree(sk-&gt;ciphertext);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">test_skcipher_result</span>(<span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>, <span class="org-type">int</span> <span class="org-variable-name">rc</span>)
{
    <span class="org-keyword">switch</span> (rc) {
    <span class="org-keyword">case</span> 0:
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> -EINPROGRESS:
    <span class="org-keyword">case</span> -EBUSY:
        rc = wait_for_completion_interruptible(
            &amp;sk-&gt;result.completion);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>rc &amp;&amp; <span class="org-negation-char">!</span>sk-&gt;result.err) {
            reinit_completion(&amp;sk-&gt;result.completion);
            <span class="org-keyword">break</span>;
        }
    <span class="org-keyword">default</span>:
        pr_info(<span class="org-string">"skcipher encrypt returned with %d result %d\n"</span>,
            rc, sk-&gt;result.err);
        <span class="org-keyword">break</span>;
    }

    init_completion(&amp;sk-&gt;result.completion);

    <span class="org-keyword">return</span> rc;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">test_skcipher_callback</span>(<span class="org-keyword">struct</span> <span class="org-type">crypto_async_request</span> *<span class="org-variable-name">req</span>, <span class="org-type">int</span> <span class="org-variable-name">error</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">tcrypt_result</span> *<span class="org-variable-name">result</span> = req-&gt;data;
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    <span class="org-keyword">if</span> (error == -EINPROGRESS)
        <span class="org-keyword">return</span>;

    result-&gt;err = error;
    complete(&amp;result-&gt;completion);
    pr_info(<span class="org-string">"Encryption finished successfully\n"</span>);
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">test_skcipher_encrypt</span>(<span class="org-type">char</span> * <span class="org-variable-name">plaintext</span>, <span class="org-type">char</span> * <span class="org-variable-name">password</span>,
                                 <span class="org-keyword">struct</span> <span class="org-type">skcipher_def</span> * <span class="org-variable-name">sk</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span> = -EFAULT;
    <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">key</span>[SYMMETRIC_KEY_LENGTH];

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;tfm) {
        sk-&gt;tfm = crypto_alloc_skcipher(<span class="org-string">"cbc-aes-aesni"</span>, 0, 0);
        <span class="org-keyword">if</span> (IS_ERR(sk-&gt;tfm)) {
            pr_info(<span class="org-string">"could not allocate skcipher handle\n"</span>);
            <span class="org-keyword">return</span> PTR_ERR(sk-&gt;tfm);
        }
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;req) {
        sk-&gt;req = skcipher_request_alloc(sk-&gt;tfm, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;req) {
            pr_info(<span class="org-string">"could not allocate skcipher request\n"</span>);
            ret = -ENOMEM;
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
    }

    skcipher_request_set_callback(sk-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
                                  test_skcipher_callback,
                                  &amp;sk-&gt;result);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Nettoyez la cl&#233;s </span><span class="org-comment-delimiter">*/</span>
    memset((<span class="org-type">void</span>*)key,<span class="org-string">'\0'</span>,SYMMETRIC_KEY_LENGTH);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Utilisez le meilleur mot de passe du monde </span><span class="org-comment-delimiter">*/</span>
    sprintf((<span class="org-type">char</span>*)key,<span class="org-string">"%s"</span>,password);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Cryptage AES 256 par cl&#233;s sym&#233;triques </span><span class="org-comment-delimiter">*/</span>
    <span class="org-keyword">if</span> (crypto_skcipher_setkey(sk-&gt;tfm, key, SYMMETRIC_KEY_LENGTH)) {
        pr_info(<span class="org-string">"key could not be set\n"</span>);
        ret = -EAGAIN;
        <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
    }
    pr_info(<span class="org-string">"Symmetric key: %s\n"</span>, key);
    pr_info(<span class="org-string">"Plaintext: %s\n"</span>, plaintext);

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;ivdata) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Voyez https://fr.wikipedia.org/wiki/Vecteur_d%27initialisation </span><span class="org-comment-delimiter">*/</span>
        sk-&gt;ivdata = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;ivdata) {
            pr_info(<span class="org-string">"could not allocate ivdata\n"</span>);
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
        get_random_bytes(sk-&gt;ivdata, CIPHER_BLOCK_SIZE);
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;scratchpad) {
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Le texte que vous souhaitez crypter </span><span class="org-comment-delimiter">*/</span>
        sk-&gt;scratchpad = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>sk-&gt;scratchpad) {
            pr_info(<span class="org-string">"could not allocate scratchpad\n"</span>);
            <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
        }
    }
    sprintf((<span class="org-type">char</span>*)sk-&gt;scratchpad,<span class="org-string">"%s"</span>,plaintext);

    sg_init_one(&amp;sk-&gt;sg, sk-&gt;scratchpad, CIPHER_BLOCK_SIZE);
    skcipher_request_set_crypt(sk-&gt;req, &amp;sk-&gt;sg, &amp;sk-&gt;sg,
                               CIPHER_BLOCK_SIZE, sk-&gt;ivdata);
    init_completion(&amp;sk-&gt;result.completion);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Cryptage </span><span class="org-comment-delimiter">*/</span>
    ret = crypto_skcipher_encrypt(sk-&gt;req);
    ret = test_skcipher_result(sk, ret);
    <span class="org-keyword">if</span> (ret)
        <span class="org-keyword">goto</span> <span class="org-constant">out</span>;

    pr_info(<span class="org-string">"Encryption request successful\n"</span>);

<span class="org-constant">out</span>:
    <span class="org-keyword">return</span> ret;
}

<span class="org-type">int</span> <span class="org-function-name">cryptoapi_init</span>(<span class="org-type">void</span>)
{
    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le meilleur mot de passe du monde </span><span class="org-comment-delimiter">*/</span>
    <span class="org-type">char</span> * <span class="org-variable-name">password</span> = <span class="org-string">"password123"</span>;

    sk.tfm = <span class="org-constant">NULL</span>;
    sk.req = <span class="org-constant">NULL</span>;
    sk.scratchpad = <span class="org-constant">NULL</span>;
    sk.ciphertext = <span class="org-constant">NULL</span>;
    sk.ivdata = <span class="org-constant">NULL</span>;

    test_skcipher_encrypt(<span class="org-string">"Testing"</span>, password, &amp;sk);
    <span class="org-keyword">return</span> 0;
}

<span class="org-type">void</span> <span class="org-function-name">cryptoapi_exit</span>(<span class="org-type">void</span>)
{
    test_skcipher_finish(&amp;sk);
}

<span class="org-function-name">module_init</span>(cryptoapi_init);
<span class="org-function-name">module_exit</span>(cryptoapi_exit);

MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Symmetric key encryption example"</span>);
MODULE_LICENSE(<span class="org-string">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">Standardisation des interfaces : Le modèle de périphérique</h2>
<div class="outline-text-2" id="text-17">
<p>
Jusqu'ici, on a vu plusieurs sortes de modules qui faisaient toutes sortes de choses, mais leurs interfaces avec le reste du noyau étaient limitées. L'idée est venue, pour imposer une interface standardisée (afin qu'il existe une manière normalisée de démarrer, suspendre et reprendre un périphérique), de créer un modèle de périphérique. C'est ce qui a été ajouté au sein du noyau. L'exemple suivant le montre, et vous pouvez utiliser ce modèle pour ajouter vos propres fonctions de périphérique telle qu'une fonction d'arrêt, de redémarrage, ou autre.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/kernel.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/module.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;linux/platform_device.h&gt;</span>

<span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> {
    <span class="org-type">char</span> *<span class="org-variable-name">greeting</span>;
    <span class="org-type">int</span>   <span class="org-variable-name">number</span>;
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_probe</span>(<span class="org-keyword">struct</span> <span class="org-type">platform_device</span> *<span class="org-variable-name">dev</span>)
{
    <span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> *<span class="org-variable-name">pd</span> = (<span class="org-keyword">struct</span> <span class="org-type">devicemodel_data</span> *)(dev-&gt;dev.platform_data);

    pr_info(<span class="org-string">"devicemodel probe\n"</span>);
    pr_info(<span class="org-string">"devicemodel greeting: %s; %d\n"</span>, pd-&gt;greeting, pd-&gt;number);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code d'initialisation de votre p&#233;riph&#233;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_remove</span>(<span class="org-keyword">struct</span> <span class="org-type">platform_device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example removed\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de suppression de votre p&#233;riph&#233;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_suspend</span>(<span class="org-keyword">struct</span> <span class="org-type">device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example suspend\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de mise en veille de votre p&#233;riph&#233;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_resume</span>(<span class="org-keyword">struct</span> <span class="org-type">device</span> *<span class="org-variable-name">dev</span>)
{
    pr_info(<span class="org-string">"devicemodel example resume\n"</span>);

    <span class="org-comment-delimiter">/* </span><span class="org-comment">Le code de reprise en activit&#233; de votre p&#233;riph&#233;rique </span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">dev_pm_ops</span> <span class="org-variable-name">devicemodel_pm_ops</span> =
{
    .suspend = devicemodel_suspend,
    .resume = devicemodel_resume,
    .poweroff = devicemodel_suspend,
    .freeze = devicemodel_suspend,
    .thaw = devicemodel_resume,
    .restore = devicemodel_resume
};

<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">platform_driver</span> <span class="org-variable-name">devicemodel_driver</span> = {
    .driver     = {
        .name   = <span class="org-string">"devicemodel_example"</span>,
        .owner  = THIS_MODULE,
        .pm     = &amp;devicemodel_pm_ops,
    },
    .probe      = devicemodel_probe,
    .remove     = devicemodel_remove,
};

<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">devicemodel_init</span>(<span class="org-type">void</span>)
{
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;

    pr_info(<span class="org-string">"devicemodel init\n"</span>);

    ret = platform_driver_register(&amp;devicemodel_driver);

    <span class="org-keyword">if</span> (ret) {
        pr_err(<span class="org-string">"Unable to register driver\n"</span>);
        <span class="org-keyword">return</span> ret;
    }

    <span class="org-keyword">return</span> 0;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">devicemodel_exit</span>(<span class="org-type">void</span>)
{
    pr_info(<span class="org-string">"devicemodel exit\n"</span>);
    platform_driver_unregister(&amp;devicemodel_driver);
}

MODULE_LICENSE(<span class="org-string">"GPL"</span>);
MODULE_AUTHOR(<span class="org-string">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span class="org-string">"Linux Device Model example"</span>);

<span class="org-function-name">module_init</span>(devicemodel_init);
<span class="org-function-name">module_exit</span>(devicemodel_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">Optimisation</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">Conditions likely et unlikely</h3>
<div class="outline-text-3" id="text-18-1">
<p>
Vous souhaitez parfois que votre code tourne de la manière la plus rapide possible, spécialement si ce dernier concerne la gestion d'une interruption, ou tout autre chose qui peut prendre du temps là ou vous souhaitez l'éviter. Si votre code contient des conditions booléennes, et si vous savez que ces conditions auront presque toujours la même valeur (que ce soit vraie <i>true</i> ou fausse <i>false</i>), alors vous pouvez optimiser votre code en utilisant les macros <i>likely</i> (pour une condition qui sera souvent vraie) ou <i>unlikely</i> (pour une condition qui sera souvent fausse).
</p>

<p>
Par exemple, l'allocation de mémoire va statistiquement le plus souvent  réussir.
</p>

<div class="org-src-container">

<pre class="src src-C">bvl = bvec_alloc(gfp_mask, nr_iovecs, &amp;idx);
<span class="org-keyword">if</span> (unlikely(<span class="org-negation-char">!</span>bvl)) {
  mempool_free(bio, bio_pool);
  bio = <span class="org-constant">NULL</span>;
  <span class="org-keyword">goto</span> <span class="org-constant">out</span>;
}
</pre>
</div>

<p>
Quand la macro <i>unlikely</i> est utilisée, alors le compilateur modifie les instructions qui y sont liées de sorte qu'il évite un saut au sein du code coûteux en ressource, saut qui ne sera effectué que si la condition est vraie. Ceci évite de vider le pipeline de votre processeur, et ça vous évitera donc de nombreux cycles durant lesquels votre processeur sera bloqué. L'exact opposé arrive si vous utilisez la macro <i>likely</i>.
</p>

<p>
Attention cependant. Cette manoeuvre doit être utilisée dans les conditions dont vous êtes presque toujours sur du résultat. C'est une mauvaise idée de trop l'utiliser sur les conditions de vérification d'erreurs et donc d'en tirer des conclusions hâtives sur votre code. Il ne faudrait pas confondre prédiction et espoir, puisque vous prévoyez rarement quand les erreurs vont arriver.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">Pièges récurrents</h2>
<div class="outline-text-2" id="text-19">
<p>
La messe n'est pas dite. Avant de vous renvoyer dans le monde écrire des modules noyau, vous devez être prévenu de certaines choses. Si je ne vous ai pas assez prévenu et qu'une chose mauvaise vous arrive, merci de signaler le problème, et je vous rembourserai le montant que j'ai touché pour votre copie papier de ce guide.
</p>
</div>

<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">Utilisation de bibliothèques standards.</h3>
<div class="outline-text-3" id="text-19-1">
<p>
Vous ne pouvez pas les utiliser, et si vous le faites vous êtes passible du bûcher. Ces bibliothèques sont réservées au code utilisateur et vous n'avez le droit de n'utiliser que des fonctions noyau, qui sont les fonctions dont vous pouvez apercevoir les symboles dans le fichier /proc/kallsyms.
</p>
</div>
</div>

<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">Désactiver les interruptions</h3>
<div class="outline-text-3" id="text-19-2">
<p>
Vous devrez parfois désactiver toutes les interruptions pour une très courte période, et ça ne pose pas de problème, mais si vous ne les réactivez pas ensuite, votre système sera embourbé et vous serez contraint de l'éteindre à la manière d'un barbare.
</p>
</div>
</div>

<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">Ne vous jetez pas dans la gueule du loup</h3>
<div class="outline-text-3" id="text-19-3">
<p>
Je n'ai probablement pas besoin de vous prévenir pour ça, mais je vais quand même le faire, juste au cas où&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">Que faire ensuite ?</h2>
<div class="outline-text-2" id="text-20">
<p>
J'aurais facilement pu rajouter plusieurs chapitres à ce livre. Il y a tant à dire ! J'aurais pu ajouter un chapitre sur l'ajout de nouveau systèmes de fichiers, ou l'ajout d'un nouveau protocole de communication réseau (comme si vous en aurez un jour besoin &#x2013; vous risquez de chercher longtemps pour trouver un protocole réseau qui n'est pas encore géré par Linux). J'aurais pu ajouter des explications sur les mécanismes du noyau qu'on a pas traités, tel que le démarrage du système, ou l'interface disque/système.
</p>

<p>
J'ai pourtant choisi de ne pas le faire. Mon but en écrivant ce livre était de fournir au lecteur une première initiation aux mystères de la programmation de module noyau pour Linux, et à ce but d'enseigner les techniques élémentaires de développement noyau. Mais pour les lecteurs qui restent sur leur faim et qui sont intéressés pour en apprendre davantage, je conseille <a href="https://kernelnewbies.org">kernelnewbies.org</a> et le répertoire <i>Documentation</i> au sein du code source du noyau, qui n'est pas toujours très clair, mais qui est un excellent point de départ pour en apprendre plus. De plus, comme l'a dit Linus Torvalds, la meilleure manière d'en apprendre plus sur le noyau reste de lire le code source.
</p>

<p>
Si vous êtes intéressé par plus d'exemples de modules noyau, alors je vous conseille de chercher du contenu de sites comme Github, Bitbucket ou Gitlab, dont les contenus sont très bien référencés (mais vous pouvez tomber sur tout et n'importe quoi, comme de vieilles versions de ce guide qui ne compileront plus sur des versions à jour du noyau). Vous trouverez également des exemples très instructifs sur l'utilisation de modules pour attaquer, compromettre un système, ou encore en tirer des données normalement privées. La meilleure manière de savoir défendre un système, c'est en connaissant ses points faibles, c'est pourquoi je vous conseille la lecture de tels dépots.
</p>

<p>
J'espère vraiment vous avoir aidé dans votre quête pour devenir un meilleur développeur, ou au moins pour vous amuser ou en apprendre plus sur cette technologie. Si vous souhaitez écrire des modules utiles et intéressants pour le noyau, j'espère que vous le ferez sous une licence libre, afin que je puisse m'en servir ou m'en inspirer.
</p>

<p>
Si vous souhaitez contribuer à ce guide, reporter une chose erronée, ou si vous souhaitez ajouter des commentaires acerbes ou sardoniques, par exemple en rajoutant des remarques évoquant des singes ou d'autres animaux dans des situations inénarrables, déposez alors une disputation, ou mieux, proposez une pull request sur le dépôt git de ce projet : <a href="https://bitbucket.org/s_burel/lkmpg_fr">https://bitbucket.org/s_burel/lkmpg_fr</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

<style type="text/css">
.back-to-top {
    position: fixed;
    bottom: 2em;
    right: 0px;
    text-decoration: none;
    color: #000000;
    background-color: rgba(235, 235, 235, 0.80);
    font-size: 12px;
    padding: 1em;
    display: none;
}

.back-to-top:hover {
    background-color: rgba(135, 135, 135, 0.50);
}
</style>

<div class="back-to-top">
<a href="#top">Back to top</a> | <a href="mailto:bob@freedombone.net">E-mail me</a>
</div>
</div>
</body>
</html>
