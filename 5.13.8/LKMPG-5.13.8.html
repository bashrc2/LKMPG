<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-09-18 Sat 18:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram" />
<meta name="description" content="How to make kernel modules for Linux"
 />
<meta name="keywords" content="linux, kernel, kernel module, kernel programming" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org83933d0">1. Introduction</a>
<ul>
<li><a href="#orgebead59">1.1. Authorship</a></li>
<li><a href="#org6b1821b">1.2. Versioning and Notes</a></li>
<li><a href="#orgdb859bc">1.3. Acknowledgements</a></li>
<li><a href="#org0c67abf">1.4. What Is A Kernel Module?</a></li>
<li><a href="#org5aa27b9">1.5. Installing some Dependencies</a></li>
<li><a href="#org3530f17">1.6. What Modules are in my Kernel?</a></li>
<li><a href="#orgad55f31">1.7. Do I need to download and compile the kernel?</a></li>
<li><a href="#org6dc23be">1.8. Before We Begin</a></li>
</ul>
</li>
<li><a href="#orgcf0b74d">2. Headers</a></li>
<li><a href="#orgfac09fa">3. Examples</a></li>
<li><a href="#org639d916">4. Hello World</a>
<ul>
<li><a href="#orge403f21">4.1. The Simplest Module</a></li>
<li><a href="#orgb5c64ba">4.2. Hello and Goodbye</a></li>
<li><a href="#orge86693e">4.3. The __init and __exit Macros</a></li>
<li><a href="#orge7f00f1">4.4. Licensing and Module Documentation</a></li>
<li><a href="#orga00b9c2">4.5. Passing Command Line Arguments to a Module</a></li>
<li><a href="#org6aea941">4.6. Modules Spanning Multiple Files</a></li>
<li><a href="#orgbe81a0f">4.7. Building modules for a precompiled kernel</a></li>
</ul>
</li>
<li><a href="#org596558d">5. Preliminaries</a>
<ul>
<li><a href="#orgdadc451">5.1. How modules begin and end</a></li>
<li><a href="#org5534008">5.2. Functions available to modules</a></li>
<li><a href="#org9b47fc7">5.3. User Space vs Kernel Space</a></li>
<li><a href="#orgf38888e">5.4. Name Space</a></li>
<li><a href="#orgb030bcb">5.5. Code space</a></li>
<li><a href="#org02ae38d">5.6. Device Drivers</a></li>
</ul>
</li>
<li><a href="#org0c6dd8f">6. Character Device drivers</a>
<ul>
<li><a href="#org2930616">6.1. The proc_ops Structure</a></li>
<li><a href="#org142d06d">6.2. The file structure</a></li>
<li><a href="#org83701d0">6.3. Registering A Device</a></li>
<li><a href="#org939ea8c">6.4. Unregistering A Device</a></li>
<li><a href="#org4efdff0">6.5. chardev.c</a></li>
<li><a href="#org6e16aae">6.6. Writing Modules for Multiple Kernel Versions</a></li>
</ul>
</li>
<li><a href="#orge63ca91">7. The /proc File System</a>
<ul>
<li><a href="#orgf1b38e3">7.1. Read and Write a /proc File</a></li>
<li><a href="#orgcbef8b9">7.2. Manage /proc file with standard filesystem</a></li>
<li><a href="#orgb1a4ad9">7.3. Manage /proc file with seq_file</a></li>
</ul>
</li>
<li><a href="#orgf84041c">8. sysfs: Interacting with your module</a></li>
<li><a href="#orgdbcb863">9. Talking To Device Files</a></li>
<li><a href="#orgbaf5b73">10. System Calls</a></li>
<li><a href="#orgefed204">11. Blocking Processes and threads</a>
<ul>
<li><a href="#orgb37505f">11.1. Sleep</a></li>
<li><a href="#orgd6ca9a3">11.2. Completions</a></li>
</ul>
</li>
<li><a href="#org1780fc2">12. Avoiding Collisions and Deadlocks</a>
<ul>
<li><a href="#org76df076">12.1. Mutex</a></li>
<li><a href="#orgd021384">12.2. Spinlocks</a></li>
<li><a href="#org6d60a54">12.3. Read and write locks</a></li>
<li><a href="#org959f412">12.4. Atomic operations</a></li>
</ul>
</li>
<li><a href="#org34a817f">13. Replacing Print Macros</a>
<ul>
<li><a href="#org93a432e">13.1. Replacement</a></li>
<li><a href="#org2fc24ec">13.2. Flashing keyboard LEDs</a></li>
</ul>
</li>
<li><a href="#org3c9597e">14. Scheduling Tasks</a>
<ul>
<li><a href="#org6916b9c">14.1. Tasklets</a></li>
<li><a href="#org30b6234">14.2. Work queues</a></li>
</ul>
</li>
<li><a href="#org5e35776">15. Interrupt Handlers</a>
<ul>
<li><a href="#org38e4218">15.1. Interrupt Handlers</a></li>
<li><a href="#org88b20a4">15.2. Detecting button presses</a></li>
<li><a href="#org7b2314f">15.3. Bottom Half</a></li>
</ul>
</li>
<li><a href="#orge40a462">16. Crypto</a>
<ul>
<li><a href="#orgb197228">16.1. Hash functions</a></li>
<li><a href="#orgff20a6d">16.2. Symmetric key encryption</a></li>
</ul>
</li>
<li><a href="#org576908f">17. Standardising the interfaces: The Device Model</a></li>
<li><a href="#org10eb421">18. Optimisations</a>
<ul>
<li><a href="#org88cc3ac">18.1. Likely and Unlikely conditions</a></li>
</ul>
</li>
<li><a href="#org081a631">19. Common Pitfalls</a>
<ul>
<li><a href="#org53333e8">19.1. Using standard libraries</a></li>
<li><a href="#org9ffb1c0">19.2. Disabling interrupts</a></li>
<li><a href="#org86cb6f3">19.3. Sticking your head inside a large carnivore</a></li>
</ul>
</li>
<li><a href="#orge44db4c">20. Where To Go From Here?</a></li>
</ul>
</div>
</div>
<p>
[[#+TITLE: The Linux Kernel Module Programming Guide
</p>


<div id="outline-container-org83933d0" class="outline-2">
<h2 id="org83933d0"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
The Linux Kernel Module Programming Guide is a free book; you may reproduce and/or modify it under the terms of the Open Software License, version 3.0.
</p>

<p>
This book is distributed in the hope it will be useful, but without any warranty, without even the implied warranty of merchantability or fitness for a particular purpose.
</p>

<p>
The author encourages wide distribution of this book for personal or commercial use, provided the above copyright notice remains intact and the method adheres to the provisions of the Open Software License. In summary, you may copy and distribute this book free of charge or for a profit. No explicit permission is required from the author for reproduction of this book in any medium, physical or electronic.
</p>

<p>
Derivative works and translations of this document must be placed under the Open Software License, and the original copyright notice must remain intact. If you have contributed new material to this book, you must make the material and source code available for your revisions. Please make revisions and updates available directly to the document maintainer, Peter Jay Salzman &lt;p@dirac.org&gt;. This will allow for the merging of updates and provide consistent revisions to the Linux community.
</p>

<p>
If you publish or distribute this book commercially, donations, royalties, and/or printed copies are greatly appreciated by the author and the <a href="http://www.tldp.org">Linux Documentation Project</a> (LDP). Contributing in this way shows your support for free software and the LDP. If you have questions or comments, please contact the address above.
</p>
</div>

<div id="outline-container-orgebead59" class="outline-3">
<h3 id="orgebead59"><span class="section-number-3">1.1.</span> Authorship</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The Linux Kernel Module Programming Guide was originally written for the 2.2 kernels by Ori Pomerantz. Eventually, Ori no longer had time to maintain the document. After all, the Linux kernel is a fast moving target. Peter Jay Salzman took over maintenance and updated it for the 2.4 kernels. Eventually, Peter no longer had time to follow developments with the 2.6 kernel, so Michael Burian became a co-maintainer to update the document for the 2.6 kernels.  Bob Mottram updated the examples for 3.8 and later kernels, added the sysfs chapter and modified or updated other chapters.
</p>
</div>
</div>

<div id="outline-container-org6b1821b" class="outline-3">
<h3 id="org6b1821b"><span class="section-number-3">1.2.</span> Versioning and Notes</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The Linux kernel is a moving target. There has always been a question whether the LKMPG should remove deprecated information or keep it around for historical sake. Michael Burian and I decided to create a new branch of the LKMPG for each new stable kernel version. So version LKMPG 4.12.x will address Linux kernel 4.12.x and LKMPG 2.6.x will address Linux kernel 2.6. No attempt will be made to archive historical information; a person wishing this information should read the appropriately versioned LKMPG.
</p>

<p>
The source code and discussions should apply to most architectures, but I can't promise anything.
</p>
</div>
</div>

<div id="outline-container-orgdb859bc" class="outline-3">
<h3 id="orgdb859bc"><span class="section-number-3">1.3.</span> Acknowledgements</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The following people have contributed corrections or good suggestions: Ignacio Martin, David Porter, Daniele Paolo Scarpazza, Dimo Velev, Francois Audeon, Horst Schirmeier, Bob Mottram and Roman Lakeev.
</p>
</div>
</div>

<div id="outline-container-org0c67abf" class="outline-3">
<h3 id="org0c67abf"><span class="section-number-3">1.4.</span> What Is A Kernel Module?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
So, you want to write a kernel module. You know C, you've written a few normal programs to run as processes, and now you want to get to where the real action is, to where a single wild pointer can wipe out your file system and a core dump means a reboot.
</p>

<p>
What exactly is a kernel module? Modules are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system. Without modules, we would have to build monolithic kernels and add new functionality directly into the kernel image. Besides having larger kernels, this has the disadvantage of requiring us to rebuild and reboot the kernel every time we want new functionality.
</p>
</div>
</div>

<div id="outline-container-org5aa27b9" class="outline-3">
<h3 id="org5aa27b9"><span class="section-number-3">1.5.</span> Installing some Dependencies</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Linux distros provide the commands <i>modprobe</i>, <i>insmod</i> and <i>depmod</i> within a package. These can be installed as follows:
</p>

<p>
On Debian:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt-get install build-essential kmod
</pre>
</div>

<p>
On Parabola:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo pacman -S gcc kmod
</pre>
</div>
</div>
</div>

<div id="outline-container-org3530f17" class="outline-3">
<h3 id="org3530f17"><span class="section-number-3">1.6.</span> What Modules are in my Kernel?</h3>
<div class="outline-text-3" id="text-1-6">
<p>
To discover what modules are already loaded within your current kernel use the command <b>lsmod</b>.
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo lsmod
</pre>
</div>

<p>
Modules are stored within the file /proc/modules, so you can also see them with:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo cat /proc/modules
</pre>
</div>

<p>
This can be a long list, and you might prefer to search for something particular. To search for the <i>fat</i> module:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo lsmod | grep fat
</pre>
</div>
</div>
</div>

<div id="outline-container-orgad55f31" class="outline-3">
<h3 id="orgad55f31"><span class="section-number-3">1.7.</span> Do I need to download and compile the kernel?</h3>
<div class="outline-text-3" id="text-1-7">
<p>
For the purposes of following this guide you don't necessarily need to do that. However, it would be wise to run the examples within a test distro running on a virtual machine in order to avoid any possibility of messing up your system.
</p>
</div>
</div>
<div id="outline-container-org6dc23be" class="outline-3">
<h3 id="org6dc23be"><span class="section-number-3">1.8.</span> Before We Begin</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Before we delve into code, there are a few issues we need to cover. Everyone's system is different and everyone has their own groove. Getting your first "hello world" program to compile and load correctly can sometimes be a trick. Rest assured, after you get over the initial hurdle of doing it for the first time, it will be smooth sailing thereafter.
</p>
</div>

<ol class="org-ol">
<li><a id="org22046b2"></a>Modversioning<br />
<div class="outline-text-5" id="text-1-8-0-1">
<p>
A module compiled for one kernel won't load if you boot a different kernel unless you enable CONFIG_MODVERSIONS in the kernel. We won't go into module versioning until later in this guide. Until we cover modversions, the examples in the guide may not work if you're running a kernel with modversioning turned on. However, most stock Linux distro kernels come with it turned on. If you're having trouble loading the modules because of versioning errors, compile a kernel with modversioning turned off.
</p>
</div>
</li>

<li><a id="orgffc6bbf"></a>Using X<br />
<div class="outline-text-5" id="text-1-8-0-2">
<p>
It is highly recommended that you extract, compile and load all the examples this guide discusses. It's also highly recommended you do this from a console. You should not be working on this stuff in X.
</p>

<p>
Modules can't print to the screen like printf() can, but they can log information and warnings, which ends up being printed on your screen, but only on a console. If you insmod a module from an xterm, the information and warnings will be logged, but only to your systemd journal. You won't see it unless you look through your journalctl. To have immediate access to this information, do all your work from the console.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgcf0b74d" class="outline-2">
<h2 id="orgcf0b74d"><span class="section-number-2">2.</span> Headers</h2>
<div class="outline-text-2" id="text-2">
<p>
Before you can build anything you'll need to install the header files for your kernel. On Parabola GNU/Linux:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo pacman -S linux-libre-headers
</pre>
</div>

<p>
On Debian:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt-get update
apt-cache search linux-headers-$(<span style="color: #fa8072;">uname</span> -r)
</pre>
</div>

<p>
This will tell you what kernel header files are available. Then for example:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo apt-get install kmod linux-headers-5.13.8-1-amd64
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfac09fa" class="outline-2">
<h2 id="orgfac09fa"><span class="section-number-2">3.</span> Examples</h2>
<div class="outline-text-2" id="text-3">
<p>
All the examples from this document are available within the <i>examples</i> subdirectory. The directory is created by a script which pulls the source code out from the manual. To test that they compile:
</p>

<div class="org-src-container">
<pre class="src src-sh">./create_examples.sh
<span style="color: #f08080;">cd</span> examples
make
</pre>
</div>

<p>
If there are any compile errors then you might have a more recent kernel version or need to install the corresponding kernel header files.
</p>
</div>
</div>
<div id="outline-container-org639d916" class="outline-2">
<h2 id="org639d916"><span class="section-number-2">4.</span> Hello World</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge403f21" class="outline-3">
<h3 id="orge403f21"><span class="section-number-3">4.1.</span> The Simplest Module</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Most people learning programming start out with some sort of "<i>hello world</i>" example. I don't know what happens to people who break with this tradition, but I think it's safer not to find out. We'll start with a series of hello world programs that demonstrate the different aspects of the basics of writing a kernel module.
</p>

<p>
Here's the simplest module possible.
</p>

<p>
Make a test directory:
</p>

<div class="org-src-container">
<pre class="src src-sh">mkdir -p ~/develop/kernel/hello-1
<span style="color: #f08080;">cd</span> ~/develop/kernel/hello-1
</pre>
</div>

<p>
Paste this into you favourite editor and save it as <b>hello-1.c</b>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  hello-1.c - The simplest kernel module.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed by all modules</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for KERN_INFO</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Hello world 1.\n"</span>);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * A non 0 return means init_module failed; module can't be loaded.</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Goodbye world 1.\n"</span>);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
Now you'll need a Makefile. If you copy and paste this change the indentation to use tabs, not spaces.
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">obj-m</span> += hello-1.o

<span style="color: #daa520;">all</span>:
        make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) modules

<span style="color: #daa520;">clean</span>:
        make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) clean
</pre>
</div>

<p>
And finally just:
</p>

<div class="org-src-container">
<pre class="src src-sh">make
</pre>
</div>

<p>
If all goes smoothly you should then find that you have a compiled <b>hello-1.ko</b> module. You can find info on it with the command:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo modinfo hello-1.ko
</pre>
</div>

<p>
At this point the command:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
should return nothing. You can try loading your shiny new module with:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo insmod hello-1.ko
</pre>
</div>

<p>
The dash character will get converted to an underscore, so when you again try:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo lsmod | grep hello
</pre>
</div>

<p>
you should now see your loaded module. It can be removed again with:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo rmmod hello_1
</pre>
</div>

<p>
Notice that the dash was replaced by an underscore. To see what just happened in the logs:
</p>

<div class="org-src-container">
<pre class="src src-sh">journalctl --since <span style="color: #deb887;">"1 hour ago"</span> | grep kernel
</pre>
</div>

<p>
You now know the basics of creating, compiling, installing and removing modules. Now for more of a description of how this module works.
</p>

<p>
Kernel modules must have at least two functions: a "start" (initialization) function called <b>init_module()</b> which is called when the module is insmoded into the kernel, and an "end" (cleanup) function called <b>cleanup_module()</b> which is called just before it is rmmoded. Actually, things have changed starting with kernel 2.3.13. You can now use whatever name you like for the
start and end functions of a module, and you'll learn how to do this in Section 2.3. In fact, the new method is the preferred method. However, many people still use init_module() and cleanup_module() for their start and end functions.
</p>

<p>
Typically, init_module() either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The cleanup_module() function is supposed to undo whatever init_module() did, so the module can be unloaded safely.
</p>

<p>
Lastly, every kernel module needs to include linux/module.h. We needed to include <b>linux/kernel.h</b> only for the macro expansion for the pr_alert() log level, which you'll learn about in Section 2.1.1.
</p>
</div>

<ol class="org-ol">
<li><a id="org2a4c2a9"></a>A point about coding style<br />
<div class="outline-text-5" id="text-4-1-0-1">
<p>
Another thing which may not be immediately obvious to anyone getting started with kernel programming is that indentation within your code should be using <b>tabs</b> and <b>not spaces</b>. It's one of the coding conventions of the kernel. You may not like it, but you'll need to get used to it if you ever submit a patch upstream.
</p>
</div>
</li>
<li><a id="org690e074"></a>Introducing print macros<br />
<div class="outline-text-5" id="text-4-1-0-2">
<p>
In the beginning there was <b>printk</b>, usually followed by a priority such as KERN_INFO or KERN_DEBUG. More recently this can also be expressed in abbreviated form using a set of print macros, such as <b>pr_info</b> and <b>pr_debug</b>. This just saves some mindless keyboard bashing and looks a bit neater. They can be found within <b>linux/printk.h</b>. Take time to read through the available priority macros.
</p>
</div>
</li>

<li><a id="org11874a6"></a>About Compiling<br />
<div class="outline-text-5" id="text-4-1-0-3">
<p>
Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain. Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules is now fully integrated into the standard kernel build mechanism. To learn more on how to compile modules which are not part of the official kernel (such as all the examples you'll find in this guide), see file <b>linux/Documentation/kbuild/modules.txt</b>.
</p>

<p>
Additional details about Makefiles for kernel modules are available in <b>linux/Documentation/kbuild/makefiles.txt</b>. Be sure to read this and the related files before starting to hack Makefiles. It'll probably save you lots of work.
</p>

<blockquote>
<p>
Here's another exercise for the reader. See that comment above the return statement in init_module()? Change the return value to something negative, recompile and load the module again. What happens?
</p>
</blockquote>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb5c64ba" class="outline-3">
<h3 id="orgb5c64ba"><span class="section-number-3">4.2.</span> Hello and Goodbye</h3>
<div class="outline-text-3" id="text-4-2">
<p>
In early kernel versions you had to use the <b>init_module</b> and <b>cleanup_module</b> functions, as in the first hello world example, but these days you can name those anything you want by using the <b>module_init</b> and <b>module_exit</b> macros. These macros are defined in <b>linux/init.h</b>. The only requirement is that your init and cleanup functions must be defined before calling the those macros, otherwise you'll get compilation errors. Here's an example of this technique:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  hello-2.c - Demonstrating the module_init() and module_exit() macros.</span>
<span style="color: #7f7f7f;"> *  This is preferred over using init_module() and cleanup_module().</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed by all modules</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for KERN_INFO</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>         <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for the macros</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> hello_2_init(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Hello, world 2\n"</span>);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> hello_2_exit(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Goodbye, world 2\n"</span>);
}

<span style="color: #daa520;">module_init</span>(hello_2_init);
<span style="color: #daa520;">module_exit</span>(hello_2_exit);

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
So now we have two real kernel modules under our belt. Adding another module is as simple as this:
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">obj-m</span> += hello-1.o
<span style="color: #4eee94;">obj-m</span> += hello-2.o

<span style="color: #daa520;">all</span>:
    make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) modules

<span style="color: #daa520;">clean</span>:
    make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) clean
</pre>
</div>

<p>
Now have a look at linux/drivers/char/Makefile for a real world example. As you can see, some things get hardwired into the kernel (obj-y) but where are all those obj-m gone? Those familiar with shell scripts will easily be able to spot them. For those not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables that you have set in the linux/.config file, the last time when you said make menuconfig or something like that.
</p>
</div>
</div>

<div id="outline-container-orge86693e" class="outline-3">
<h3 id="orge86693e"><span class="section-number-3">4.3.</span> The __init and __exit Macros</h3>
<div class="outline-text-3" id="text-4-3">
<p>
This demonstrates a feature of kernel 2.2 and later. Notice the change in the definitions of the init and cleanup functions. The <b>__init</b> macro causes the init function to be discarded and its memory freed once the init function finishes for built-in drivers, but not loadable modules. If you think about when the init function is invoked, this makes perfect sense.
</p>

<p>
There is also an <b>__initdata</b> which works similarly to <b>__init</b> but for init variables rather than functions.
</p>

<p>
The <b>__exit</b> macro causes the omission of the function when the module is built into the kernel, and like __init, has no effect for loadable modules. Again, if you consider when the cleanup function runs, this makes complete sense; built-in drivers don't need a cleanup function, while loadable modules do.
</p>

<p>
These macros are defined in <b>linux/init.h</b> and serve to free up kernel memory. When you boot your kernel and see something like Freeing unused kernel memory: 236k freed, this is precisely what the kernel is freeing.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  hello-3.c - Illustrating the __init, __initdata and __exit macros.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed by all modules</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for KERN_INFO</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>         <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for the macros</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">hello3_data</span> __initdata = 3;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> hello_3_init(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Hello, world %d\n"</span>, hello3_data);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> hello_3_exit(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Goodbye, world 3\n"</span>);
}

<span style="color: #daa520;">module_init</span>(hello_3_init);
<span style="color: #daa520;">module_exit</span>(hello_3_exit);

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7f00f1" class="outline-3">
<h3 id="orge7f00f1"><span class="section-number-3">4.4.</span> Licensing and Module Documentation</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Honestly, who loads or even cares about proprietary modules? If you do then you might have seen something like this:
</p>

<div class="org-src-container">
<pre class="src src-txt"># insmod xxxxxx.o
Warning: loading xxxxxx.ko will taint the kernel: no license
  See http://www.tux.org/lkml/#export-tainted for information about tainted modules
Module xxxxxx loaded, with warnings
</pre>
</div>

<p>
You can use a few macros to indicate the license for your module. Some examples are "GPL", "GPL v2", "GPL and additional rights", "Dual BSD/GPL", "Dual MIT/GPL", "Dual MPL/GPL" and "Proprietary". They're defined within <b>linux/module.h</b>.
</p>

<p>
To reference what license you're using a macro is available called <b>MODULE_LICENSE</b>. This and a few other macros describing the module are illustrated in the below example.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  hello-4.c - Demonstrates module documentation.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed by all modules</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for KERN_INFO</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>         <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Needed for the macros</span><span style="color: #7f7f7f;"> */</span>

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"A sample driver"</span>);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> init_hello_4(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Hello, world 4\n"</span>);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> cleanup_hello_4(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Goodbye, world 4\n"</span>);
}

<span style="color: #daa520;">module_init</span>(init_hello_4);
<span style="color: #daa520;">module_exit</span>(cleanup_hello_4);
</pre>
</div>
</div>
</div>

<div id="outline-container-orga00b9c2" class="outline-3">
<h3 id="orga00b9c2"><span class="section-number-3">4.5.</span> Passing Command Line Arguments to a Module</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Modules can take command line arguments, but not with the argc/argv you might be used to.
</p>

<p>
To allow arguments to be passed to your module, declare the variables that will take the values of the command line arguments as global and then use the module_param() macro, (defined in linux/moduleparam.h) to set the mechanism up. At runtime, insmod will fill the variables with any command line arguments that are given, like ./insmod mymodule.ko myvariable=5. The variable declarations and macros should be placed at the beginning of the module for clarity. The example code should clear up my admittedly lousy explanation.
</p>

<p>
The module_param() macro takes 3 arguments: the name of the variable, its type and permissions for the corresponding file in sysfs. Integer types can be signed as usual or unsigned. If you'd like to use arrays of integers or strings see module_param_array() and module_param_string().
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myint</span> = 3;
<span style="color: #daa520;">module_param</span>(myint, <span style="color: #98f5ff;">int</span>, 0);
</pre>
</div>

<p>
Arrays are supported too, but things are a bit different now than they were in the olden days. To keep track of the number of parameters you need to pass a pointer to a count variable as third parameter. At your option, you could also ignore the count and pass NULL instead. We show both possibilities here:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myintarray</span>[2];
<span style="color: #daa520;">module_param_array</span>(myintarray, <span style="color: #98f5ff;">int</span>, <span style="color: #a2cd5a;">NULL</span>, 0); <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">not interested in count</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">myshortarray</span>[4];
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">count</span>;
<span style="color: #daa520;">module_param_array</span>(myshortarray, <span style="color: #98f5ff;">short</span>, &amp;count, 0); <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">put count into "count" variable</span><span style="color: #7f7f7f;"> */</span>
</pre>
</div>

<p>
A good use for this is to have the module variable's default values set, like an port or IO address. If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value. This will be made clear later on.
</p>

<p>
Lastly, there's a macro function, <b>MODULE_PARM_DESC()</b>, that is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  hello-5.c - Demonstrates command line argument passing to a module.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/moduleparam.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/stat.h&gt;</span>

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Peter Jay Salzman"</span>);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myshort</span> = 1;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myint</span> = 420;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mylong</span> = 9999;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">mystring</span> = <span style="color: #deb887;">"blah"</span>;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myintArray</span>[2] = { -1, -1 };
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">arr_argc</span> = 0;

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * module_param(foo, int, 0000)</span>
<span style="color: #7f7f7f;"> * The first param is the parameters name</span>
<span style="color: #7f7f7f;"> * The second param is it's data type</span>
<span style="color: #7f7f7f;"> * The final argument is the permissions bits,</span>
<span style="color: #7f7f7f;"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #daa520;">module_param</span>(myshort, <span style="color: #98f5ff;">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
<span style="color: #daa520;">MODULE_PARM_DESC</span>(myshort, <span style="color: #deb887;">"A short integer"</span>);
<span style="color: #daa520;">module_param</span>(myint, <span style="color: #98f5ff;">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
<span style="color: #daa520;">MODULE_PARM_DESC</span>(myint, <span style="color: #deb887;">"An integer"</span>);
<span style="color: #daa520;">module_param</span>(mylong, <span style="color: #98f5ff;">long</span>, S_IRUSR);
<span style="color: #daa520;">MODULE_PARM_DESC</span>(mylong, <span style="color: #deb887;">"A long integer"</span>);
<span style="color: #daa520;">module_param</span>(mystring, charp, 0000);
<span style="color: #daa520;">MODULE_PARM_DESC</span>(mystring, <span style="color: #deb887;">"A character string"</span>);

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * module_param_array(name, type, num, perm);</span>
<span style="color: #7f7f7f;"> * The first param is the parameter's (in this case the array's) name</span>
<span style="color: #7f7f7f;"> * The second param is the data type of the elements of the array</span>
<span style="color: #7f7f7f;"> * The third argument is a pointer to the variable that will store the number</span>
<span style="color: #7f7f7f;"> * of elements of the array initialized by the user at module loading time</span>
<span style="color: #7f7f7f;"> * The fourth argument is the permission bits</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #daa520;">module_param_array</span>(myintArray, <span style="color: #98f5ff;">int</span>, &amp;arr_argc, 0000);
<span style="color: #daa520;">MODULE_PARM_DESC</span>(myintArray, <span style="color: #deb887;">"An array of integers"</span>);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> hello_5_init(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    pr_info(<span style="color: #deb887;">"Hello, world 5\n=============\n"</span>);
    pr_info(<span style="color: #deb887;">"myshort is a short integer: %hd\n"</span>, myshort);
    pr_info(<span style="color: #deb887;">"myint is an integer: %d\n"</span>, myint);
    pr_info(<span style="color: #deb887;">"mylong is a long integer: %ld\n"</span>, mylong);
    pr_info(<span style="color: #deb887;">"mystring is a string: %s\n"</span>, mystring);

    <span style="color: #00bfff;">for</span> (i = 0; i &lt; (<span style="color: #00bfff;">sizeof</span> myintArray / <span style="color: #00bfff;">sizeof</span> (<span style="color: #98f5ff;">int</span>)); i++)
        pr_info(<span style="color: #deb887;">"myintArray[%d] = %d\n"</span>, i, myintArray[i]);

    pr_info(<span style="color: #deb887;">"got %d arguments for myintArray.\n"</span>, arr_argc);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> hello_5_exit(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Goodbye, world 5\n"</span>);
}

<span style="color: #daa520;">module_init</span>(hello_5_init);
<span style="color: #daa520;">module_exit</span>(hello_5_exit);
</pre>
</div>

<p>
I would recommend playing around with this code:
</p>

<div class="org-src-container">
<pre class="src src-txt"># sudo insmod hello-5.ko mystring="bebop" mybyte=255 myintArray=-1
mybyte is an 8 bit integer: 255
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: bebop
myintArray is -1 and 420

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mystring="supercalifragilisticexpialidocious" \
&gt; mybyte=256 myintArray=-1,-1
mybyte is an 8 bit integer: 0
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious
myintArray is -1 and -1

# rmmod hello-5
Goodbye, world 5

# sudo insmod hello-5.ko mylong=hello
hello-5.o: invalid argument syntax for mylong: 'h'
</pre>
</div>
</div>
</div>

<div id="outline-container-org6aea941" class="outline-3">
<h3 id="org6aea941"><span class="section-number-3">4.6.</span> Modules Spanning Multiple Files</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Sometimes it makes sense to divide a kernel module between several source files.
</p>

<p>
Here's an example of such a kernel module.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  start.c - Illustration of multi filed modules</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"Hello, world - this is the kernel speaking\n"</span>);
    <span style="color: #00bfff;">return</span> 0;
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
The next file:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  stop.c - Illustration of multi filed modules</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;">  */</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    pr_info(<span style="color: #deb887;">"Short is the life of a kernel module\n"</span>);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
And finally, the makefile:
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">obj-m</span> += hello-1.o
<span style="color: #4eee94;">obj-m</span> += hello-2.o
<span style="color: #4eee94;">obj-m</span> += hello-3.o
<span style="color: #4eee94;">obj-m</span> += hello-4.o
<span style="color: #4eee94;">obj-m</span> += hello-5.o
<span style="color: #4eee94;">obj-m</span> += startstop.o
<span style="color: #4eee94;">startstop-objs</span> := start.o stop.o

<span style="color: #daa520;">all</span>:
    make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) modules

<span style="color: #daa520;">clean</span>:
    make -C /lib/modules/$(<span style="color: #4eee94;">shell</span> uname -r)/build M=$(<span style="color: #4eee94;">PWD</span>) clean
</pre>
</div>

<p>
This is the complete makefile for all the examples we've seen so far. The first five lines are nothing special, but for the last example we'll need two lines. First we invent an object name for our combined module, second we tell make what object files are part of that module.
</p>
</div>
</div>

<div id="outline-container-orgbe81a0f" class="outline-3">
<h3 id="orgbe81a0f"><span class="section-number-3">4.7.</span> Building modules for a precompiled kernel</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Obviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as forced module unloading (<b>MODULE_FORCE_UNLOAD</b>): when this option is enabled, you can force the kernel to unload a module even when it believes it is unsafe, via a <b>sudo rmmod -f module</b> command. This option can save you a lot of time and a number of reboots during the development of a module. If you don't want to recompile your kernel then you should consider running the examples within a test distro on a virtual machine. If you mess anything up then you can easily reboot or restore the VM.
</p>

<p>
There are a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped with common Linux distros, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot. If you can't think of a case that will force you to use modules for a precompiled kernel you might want to skip this and treat the rest of this chapter as a big footnote.
</p>

<p>
Now, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel, in most cases you would obtain an error as follows:
</p>

<div class="org-src-container">
<pre class="src src-txt">insmod: error inserting 'poet_atkm.ko': -1 Invalid module format
</pre>
</div>

<p>
Less cryptical information are logged to the systemd journal:
</p>

<div class="org-src-container">
<pre class="src src-txt">Jun  4 22:07:54 localhost kernel: poet_atkm: version magic '2.6.5-1.358custom 686
REGPARM 4KSTACKS gcc-3.3' should be '2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3'
</pre>
</div>

<p>
In other words, your kernel refuses to accept your module because version strings (more precisely, version magics) do not match. Incidentally, version magics are stored in the module object in the form of a static string, starting with vermagic:. Version data are inserted in your module when it is linked against the <b>init/vermagic.o</b> file. To inspect version magics and other strings stored in a given module, issue the modinfo module.ko command:
</p>

<div class="org-src-container">
<pre class="src src-txt"># sudo modinfo hello-4.ko
license:        GPL
author:         Bob Mottram &lt;bob@libreserver.org&gt;
description:    A sample driver
vermagic:       5.13.8-1.358 amd64 REGPARM 4KSTACKS gcc-4.9.2
depends:
</pre>
</div>

<p>
To overcome this problem we could resort to the <b>&#x2013;force-vermagic</b> option, but this solution is potentially unsafe, and unquestionably inacceptable in production modules. Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built. How to do this, is the subject of the remainder of this chapter.
</p>

<p>
First of all, make sure that a kernel source tree is available, having exactly the same version as your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. Usually, this is available in your current <i>boot directory, under a name like config-2.6.x. You may just want to copy it to your kernel source tree: *cp /boot/config-`uname -r` /usr/src/linux-`uname -r`</i>.config*.
</p>

<p>
Let's focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module into the kernel. That slight difference, namely the custom string which appears in the module's version magic and not in the kernel's one, is due to a modification with respect to the original, in the makefile that some distros include. Then, examine your <b>/usr/src/linux/Makefile</b>, and make sure that the specified version information matches exactly the one used for your current kernel. For example, you makefile could start as follows:
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #4eee94;">VERSION</span> = 4
<span style="color: #4eee94;">PATCHLEVEL</span> = 7
<span style="color: #4eee94;">SUBLEVEL</span> = 4
<span style="color: #4eee94;">EXTRAVERSION</span> = -1.358custom
</pre>
</div>

<p>
In this case, you need to restore the value of symbol <b>EXTRAVERSION</b> to -1.358. We suggest to keep a backup copy of the makefile used to compile your kernel available in <b>/lib/modules/5.13.8-1.358/build</b>. A simple <b>cp /lib/modules/`uname-r`/build/Makefile /usr/src/linux-`uname -r`</b> should suffice. Additionally, if you already started a kernel build with the previous (wrong) Makefile, you should also rerun make, or directly modify symbol UTS_RELEASE in file <b>/usr/src/linux-5.13.8/include/linux/version.h</b> according to contents of file <b>/lib/modules/5.13.8/build/include/linux/version.h</b>, or overwrite the latter with the first.
</p>

<p>
Now, please run make to update configuration and version headers and objects:
</p>

<div class="org-src-container">
<pre class="src src-txt"># make
CHK     include/linux/version.h
UPD     include/linux/version.h
SYMLINK include/asm -&gt; include/asm-i386
SPLIT   include/linux/autoconf.h -&gt; include/config/*
HOSTCC  scripts/basic/fixdep
HOSTCC  scripts/basic/split-include
HOSTCC  scripts/basic/docproc
HOSTCC  scripts/conmakehash
HOSTCC  scripts/kallsyms
CC      scripts/empty.o
</pre>
</div>

<p>
If you do not desire to actually compile the kernel, you can interrupt the build process (CTRL-C) just after the SPLIT line, because at that time, the files you need will be are ready. Now you can turn back to the directory of your module and compile it: It will be built exactly according your current kernel settings, and it will load into it without any errors.
</p>
</div>
</div>
</div>

<div id="outline-container-org596558d" class="outline-2">
<h2 id="org596558d"><span class="section-number-2">5.</span> Preliminaries</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgdadc451" class="outline-3">
<h3 id="orgdadc451"><span class="section-number-3">5.1.</span> How modules begin and end</h3>
<div class="outline-text-3" id="text-5-1">
<p>
A program usually begins with a <b>main()</b> function, executes a bunch of instructions and terminates upon completion of those instructions. Kernel modules work a bit differently. A module always begin with either the init_module or the function you specify with module_init call. This is the entry function for modules; it tells the kernel what functionality the module provides and sets up the kernel to run the module's functions when they're needed. Once it does this, entry function returns and the module does nothing until the kernel wants to do something with the code that the module provides.
</p>

<p>
All modules end by calling either <b>cleanup_module</b> or the function you specify with the <b>module_exit</b> call. This is the exit function for modules; it undoes whatever entry function did. It unregisters the functionality that the entry function registered.
</p>

<p>
Every module must have an entry function and an exit function. Since there's more than one way to specify entry and exit functions, I'll try my best to use the terms `entry function' and `exit function', but if I slip and simply refer to them as init_module and cleanup_module, I think you'll know what I mean.
</p>
</div>
</div>

<div id="outline-container-org5534008" class="outline-3">
<h3 id="org5534008"><span class="section-number-3">5.2.</span> Functions available to modules</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Programmers use functions they don't define all the time. A prime example of this is <b>printf()</b>. You use these library functions which are provided by the standard C library, libc. The definitions for these functions don't actually enter your program until the linking stage, which insures that the code (for printf() for example) is available, and fixes the call instruction to point to that code.
</p>

<p>
Kernel modules are different here, too. In the hello world example, you might have noticed that we used a function, <b>pr_info()</b> but didn't include a standard I/O library. That's because modules are object files whose symbols get resolved upon insmod'ing. The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you're curious about what symbols have been exported by your kernel, take a look at <b>/proc/kallsyms</b>.
</p>

<p>
One point to keep in mind is the difference between library functions and system calls. Library functions are higher level, run completely in user space and provide a more convenient interface for the programmer to the functions that do the real work &#x2014; system calls. System calls run in kernel mode on the user's behalf and are provided by the kernel itself. The library function printf() may look like a very general printing function, but all it really does is format the data into strings and write the string data using the low-level system call write(), which then sends the data to standard output.
</p>

<p>
Would you like to see what system calls are made by printf()? It's easy! Compile the following program:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    printf(<span style="color: #deb887;">"hello"</span>);
    <span style="color: #00bfff;">return</span> 0;
}
</pre>
</div>

<p>
with <b>gcc -Wall -o hello hello.c</b>. Run the exectable with <b>strace ./hello</b>. Are you impressed? Every line you see corresponds to a system call. <a href="https://strace.io/">strace</a> is a handy program that gives you details about what system calls a program is making, including which call is made, what its arguments are and what it returns. It's an invaluable tool for figuring out things like what files a program is trying to access. Towards the end, you'll see a line which looks like write (1, "hello", 5hello). There it is. The face behind the printf() mask. You may not be familiar with write, since most people use library functions for file I/O (like fopen, fputs, fclose). If that's the case, try looking at man 2 write. The 2nd man section is devoted to system calls (like kill() and read()). The 3rd man section is devoted to library calls, which you would probably be more familiar with (like cosh() and random()).
</p>

<p>
You can even write modules to replace the kernel's system calls, which we'll do shortly. Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have the kernel write Tee hee, that tickles! everytime someone tries to delete a file on your system.
</p>
</div>
</div>

<div id="outline-container-org9b47fc7" class="outline-3">
<h3 id="org9b47fc7"><span class="section-number-3">5.3.</span> User Space vs Kernel Space</h3>
<div class="outline-text-3" id="text-5-3">
<p>
A kernel is all about access to resources, whether the resource in question happens to be a video card, a hard drive or even memory. Programs often compete for the same resource. As I just saved this document, updatedb started updating the locate database. My vim session and updatedb are both using the hard drive concurrently. The kernel needs to keep things orderly, and not give users access to resources whenever they feel like it. To this end, a CPU can run in different modes. Each mode gives a different level of freedom to do what you want on the system. The Intel 80386 architecture had 4 of these modes, which were called rings. Unix uses only two rings; the highest ring (ring 0, also known as `supervisor mode' where everything is allowed to happen) and the lowest ring, which is called `user mode'.
</p>

<p>
Recall the discussion about library functions vs system calls. Typically, you use a library function in user mode. The library function calls one or more system calls, and these system calls execute on the library function's behalf, but do so in supervisor mode since they are part of the kernel itself. Once the system call completes its task, it returns and execution gets transfered back to user mode.
</p>
</div>
</div>

<div id="outline-container-orgf38888e" class="outline-3">
<h3 id="orgf38888e"><span class="section-number-3">5.4.</span> Name Space</h3>
<div class="outline-text-3" id="text-5-4">
<p>
When you write a small C program, you use variables which are convenient and make sense to the reader. If, on the other hand, you're writing routines which will be part of a bigger problem, any global variables you have are part of a community of other peoples' global variables; some of the variable names can clash. When a program has lots of global variables which aren't meaningful enough to be distinguished, you get namespace pollution. In large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique variable names and symbols.
</p>

<p>
When writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely an issue. The best way to deal with this is to declare all your variables as static and to use a well-defined prefix for your symbols. By convention, all kernel prefixes are lowercase. If you don't want to declare everything as static, another option is to declare a symbol table and register it with a kernel. We'll get to this later.
</p>

<p>
The file <b>/proc/kallsyms</b> holds all the symbols that the kernel knows about and which are therefore accessible to your modules since they share the kernel's codespace.
</p>
</div>
</div>

<div id="outline-container-orgb030bcb" class="outline-3">
<h3 id="orgb030bcb"><span class="section-number-3">5.5.</span> Code space</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Memory management is a very complicated subject and the majority of O'Reilly's "<i>Understanding The Linux Kernel</i>" exclusively covers memory management! We're not setting out to be experts on memory managements, but we do need to know a couple of facts to even begin worrying about writing real modules.
</p>

<p>
If you haven't thought about what a segfault really means, you may be surprised to hear that pointers don't actually point to memory locations. Not real ones, anyway. When a process is created, the kernel sets aside a portion of real physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a computer scientist would know about. This memory begins with 0x00000000 and extends up to whatever it needs to be. Since the memory space for any two processes don't overlap, every process that can access a memory address, say 0xbffff978, would be accessing a different location in real physical memory! The processes would be accessing an index named 0xbffff978 which points to some kind of offset into the region of memory set aside for that particular process. For the most part, a process like our Hello, World program can't access the space of another process, although there are ways which we'll talk about later.
</p>

<p>
The kernel has its own space of memory as well. Since a module is code which can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel's codespace rather than having its own. Therefore, if your module segfaults, the kernel segfaults. And if you start writing over data because of an off-by-one error, then you're trampling on kernel data (or code). This is even worse than it sounds, so try your best to be careful.
</p>

<p>
By the way, I would like to point out that the above discussion is true for any operating system which uses a monolithic kernel. This isn't quite the same thing as <i>"building all your modules into the kernel"</i>, although the idea is the same. There are things called microkernels which have modules which get their own codespace. The GNU Hurd and the Magenta kernel of Google Fuchsia are two examples of a microkernel.
</p>
</div>
</div>

<div id="outline-container-org02ae38d" class="outline-3">
<h3 id="org02ae38d"><span class="section-number-3">5.6.</span> Device Drivers</h3>
<div class="outline-text-3" id="text-5-6">
<p>
One class of module is the device driver, which provides functionality for hardware like a serial port. On unix, each piece of hardware is represented by a file located in /dev named a device file which provides the means to communicate with the hardware. The device driver provides the communication on behalf of a user program. So the es1370.o sound card device driver might connect the /dev/sound device file to the Ensoniq IS1370 sound card. A userspace program like mp3blaster can use /dev/sound without ever knowing what kind of sound card is installed.
</p>
</div>

<ol class="org-ol">
<li><a id="org5b15d22"></a>Major and Minor Numbers<br />
<div class="outline-text-5" id="text-5-6-0-1">
<p>
Let's look at some device files. Here are device files which represent the first three partitions on the primary master IDE hard drive:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #7f7f7f;"># </span><span style="color: #7f7f7f;">ls -l /dev/hda[1-3]</span>
brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
</pre>
</div>

<p>
Notice the column of numbers separated by a comma? The first number is called the device's major number. The second number is the minor number. The major number tells you which driver is used to access the hardware. Each driver is assigned a unique major number; all device files with the same major number are controlled by the same driver. All the above major numbers are 3, because they're all controlled by the same driver.
</p>

<p>
The minor number is used by the driver to distinguish between the various hardware it controls. Returning to the example above, although all three devices are handled by the same driver they have unique minor numbers because the driver sees them as being different pieces of hardware.
</p>

<p>
Devices are divided into two types: character devices and block devices. The difference is that block devices have a buffer for requests, so they can choose the best order in which to respond to the requests. This is important in the case of storage devices, where it's faster to read or write sectors which are close to each other, rather than those which are further apart. Another difference is that block devices can only accept input and return output in blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few bytes as they like. Most devices in the world are character, because they don't need this type of buffering, and they don't operate with a fixed block size. You can tell whether a device file is for a block device or a character device by looking at the first character in the output of ls -l. If it's `b' then it's a block device, and if it's `c' then it's a character device. The devices you see above are block devices. Here are some character devices (the serial ports):
</p>

<div class="org-src-container">
<pre class="src src-sh">crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
</pre>
</div>

<p>
If you want to see which major numbers have been assigned, you can look at /usr/src/linux/Documentation/devices.txt.
</p>

<p>
When the system was installed, all of those device files were created by the mknod command. To create a new char device named `coffee' with major/minor number 12 and 2, simply do mknod /dev/coffee c 12 2. You don't have to put your device files into /dev, but it's done by convention. Linus put his device files in /dev, and so should you. However, when creating a device file for testing purposes, it's probably OK to place it in your working directory where you compile the kernel module. Just be sure to put it in the right place when you're done writing the device driver.
</p>

<p>
I would like to make a few last points which are implicit from the above discussion, but I'd like to make them explicit just in case. When a device file is accessed, the kernel uses the major number of the file to determine which driver should be used to handle the access. This means that the kernel doesn't really need to use or even know about the minor number. The driver itself is the only thing that cares about the minor number. It uses the minor number to distinguish between different pieces of hardware.
</p>

<p>
By the way, when I say <i>"hardware"</i>, I mean something a bit more abstract than a PCI card that you can hold in your hand. Look at these two device files:
</p>

<div class="org-src-container">
<pre class="src src-sh">% ls -l /dev/sda /dev/sdb
brw-rw---- 1 root disk 8,  0 Jan  3 09:02 /dev/sda
brw-rw---- 1 root disk 8, 16 Jan  3 09:02 /dev/sdb
</pre>
</div>

<p>
By now you can look at these two device files and know instantly that they are block devices and are handled by same driver (block major 8). Sometimes two device files with the same major but different minor number can actually represent the same piece of physical hardware. So just be aware that the word "hardware" in our discussion can mean something very abstract.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org0c6dd8f" class="outline-2">
<h2 id="org0c6dd8f"><span class="section-number-2">6.</span> Character Device drivers</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org2930616" class="outline-3">
<h3 id="org2930616"><span class="section-number-3">6.1.</span> The proc_ops Structure</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The proc_ops structure is defined in <b>/usr/include/linux/fs.h</b>, and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation.
</p>

<p>
For example, every character driver needs to define a function that reads from the device. The proc_ops structure holds the address of the module's function that performs that operation. Here is what the definition looks like for kernel 3.0:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">module</span> *<span style="color: #4eee94;">owner</span>;
    <span style="color: #98f5ff;">loff_t</span> (*<span style="color: #daa520;">llseek</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">loff_t</span>, <span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">read</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">__user</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">loff_t</span> *);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">write</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">__user</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">loff_t</span> *);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">aio_read</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kiocb</span> *, <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">iovec</span> *, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>, <span style="color: #98f5ff;">loff_t</span>);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">aio_write</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kiocb</span> *, <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">iovec</span> *, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>, <span style="color: #98f5ff;">loff_t</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">iterate</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">dir_context</span> *);
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">poll</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">poll_table_struct</span> *);
    <span style="color: #98f5ff;">long</span> (*<span style="color: #daa520;">unlocked_ioctl</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>);
    <span style="color: #98f5ff;">long</span> (*<span style="color: #daa520;">compat_ioctl</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">mmap</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">vm_area_struct</span> *);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">open</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">flush</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">fl_owner_t</span> <span style="color: #4eee94;">id</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">release</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">fsync</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">loff_t</span>, <span style="color: #98f5ff;">loff_t</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">datasync</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">aio_fsync</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kiocb</span> *, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">datasync</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">fasync</span>) (<span style="color: #98f5ff;">int</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">lock</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">int</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_lock</span> *);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">sendpage</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">page</span> *, <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">loff_t</span> *, <span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> (*<span style="color: #daa520;">get_unmapped_area</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">check_flags</span>)(<span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">flock</span>) (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">int</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_lock</span> *);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">splice_write</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">pipe_inode_info</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">loff_t</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">ssize_t</span> (*<span style="color: #daa520;">splice_read</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">loff_t</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">pipe_inode_info</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">setlease</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">long</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_lock</span> **);
    <span style="color: #98f5ff;">long</span> (*<span style="color: #daa520;">fallocate</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>, <span style="color: #98f5ff;">loff_t</span> <span style="color: #4eee94;">offset</span>,
              <span style="color: #98f5ff;">loff_t</span> <span style="color: #4eee94;">len</span>);
    <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">show_fdinfo</span>)(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_file</span> *<span style="color: #4eee94;">m</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">f</span>);
};
</pre>
</div>

<p>
Some operations are not implemented by a driver. For example, a driver that handles a video card won't need to read from a directory structure. The corresponding entries in the proc_ops structure should be set to NULL.
</p>

<p>
There is a gcc extension that makes assigning to this structure more convenient. You'll see it in modern drivers, and may catch you by surprise. This is what the new way of assigning to the structure looks like:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">fops</span> = {
        proc_read: device_read,
        proc_write: device_write,
        proc_open: device_open,
        proc_release: device_release
};
</pre>
</div>

<p>
However, there's also a C99 way of assigning to elements of a structure, and this is definitely preferred over using the GNU extension. The version of gcc the author used when writing this, 2.95, supports the new C99 syntax. You should use this syntax in case someone wants to port your driver. It will help with compatibility:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">fops</span> = {
        .proc_read = device_read,
        .proc_write = device_write,
        .proc_open = device_open,
        .proc_release = device_release
};
</pre>
</div>

<p>
The meaning is clear, and you should be aware that any member of the structure which you don't explicitly assign will be initialized to NULL by gcc.
</p>

<p>
An instance of struct proc_ops containing pointers to functions that are used to implement read, write, open, &#x2026; syscalls is commonly named fops.
</p>
</div>
</div>

<div id="outline-container-org142d06d" class="outline-3">
<h3 id="org142d06d"><span class="section-number-3">6.2.</span> The file structure</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Each device is represented in the kernel by a file structure, which is defined in <b>linux/fs.h</b>. Be aware that a file is a kernel level structure and never appears in a user space program. It's not the same thing as a <b>FILE</b>, which is defined by glibc and would never appear in a kernel space function. Also, its name is a bit misleading; it represents an abstract open `file', not a file on a disk, which is represented by a structure named inode.
</p>

<p>
An instance of struct file is commonly named filp. You'll also see it refered to as struct file file. Resist the temptation.
</p>

<p>
Go ahead and look at the definition of file. Most of the entries you see, like struct dentry aren't used by device drivers, and you can ignore them. This is because drivers don't fill file directly; they only use structures contained in file which are created elsewhere.
</p>
</div>
</div>

<div id="outline-container-org83701d0" class="outline-3">
<h3 id="org83701d0"><span class="section-number-3">6.3.</span> Registering A Device</h3>
<div class="outline-text-3" id="text-6-3">
<p>
As discussed earlier, char devices are accessed through device files, usually located in /dev. This is by convention. When writing a driver, it's OK to put the device file in your current directory. Just make sure you place it in /dev for a production driver. The major number tells you which driver handles which device file. The minor number is used only by the driver itself to differentiate which device it's operating on, just in case the driver handles more than one device.
</p>

<p>
Adding a driver to your system means registering it with the kernel. This is synonymous with assigning it a major number during the module's initialization. You do this by using the register_chrdev function, defined by linux/fs.h.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98f5ff;">int</span> <span style="color: #daa520;">register_chrdev</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">major</span>, <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> *<span style="color: #4eee94;">fops</span>);
</pre>
</div>

<p>
where unsigned int major is the major number you want to request, <i>const char *name</i> is the name of the device as it'll appear in <b>/proc/devices</b> and <i>struct proc_ops *fops</i> is a pointer to the proc_ops table for your driver. A negative return value means the registration failed. Note that we didn't pass the minor number to register_chrdev. That's because the kernel doesn't care about the minor number; only our driver uses it.
</p>

<p>
Now the question is, how do you get a major number without hijacking one that's already in use? The easiest way would be to look through Documentation /devices.txt and pick an unused one. That's a bad way of doing things because you'll never be sure if the number you picked will be assigned later. The answer is that you can ask the kernel to assign you a dynamic major number.
</p>

<p>
If you pass a major number of 0 to register_chrdev, the return value will be the dynamically allocated major number. The downside is that you can't make a device file in advance, since you don't know what the major number will be. There are a couple of ways to do this. First, the driver itself can print the newly assigned number and we can make the device file by hand. Second, the newly registered device will have an entry in <b>/proc/devices</b>, and we can either make the device file by hand or write a shell script to read the file in and make the device file. The third method is we can have our driver make the the device file using the <b>device_create</b> function after a successful registration and <b>device_destroy</b> during the call to cleanup_module.
</p>
</div>
</div>

<div id="outline-container-org939ea8c" class="outline-3">
<h3 id="org939ea8c"><span class="section-number-3">6.4.</span> Unregistering A Device</h3>
<div class="outline-text-3" id="text-6-4">
<p>
We can't allow the kernel module to be rmmod'ed whenever root feels like it. If the device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory location where the appropriate function (read/write) used to be. If we're lucky, no other code was loaded there, and we'll get an ugly error message. If we're unlucky, another kernel module was loaded into the same location, which means a jump into the middle of another function within the kernel. The results of this would be impossible to predict, but they can't be very positive.
</p>

<p>
Normally, when you don't want to allow something, you return an error code (a negative number) from the function which is supposed to do it. With cleanup_module that's impossible because it's a void function. However, there's a counter which keeps track of how many processes are using your module. You can see what it's value is by looking at the 3rd field of <b>/proc/modules</b>. If this number isn't zero, rmmod will fail. Note that you don't have to check the counter from within cleanup_module because the check will be performed for you by the system call sys_delete_module, defined in <b>linux/module.c</b>. You shouldn't use this counter directly, but there are functions defined in <b>linux/module.h</b> which let you increase, decrease and display this counter:
</p>

<ul class="org-ul">
<li>try_module_get(THIS_MODULE): Increment the use count.</li>
<li>module_put(THIS_MODULE): Decrement the use count.</li>
</ul>

<p>
It's important to keep the counter accurate; if you ever do lose track of the correct usage count, you'll never be able to unload the module; it's now reboot time, boys and girls. This is bound to happen to you sooner or later during a module's development.
</p>
</div>
</div>

<div id="outline-container-org4efdff0" class="outline-3">
<h3 id="org4efdff0"><span class="section-number-3">6.5.</span> chardev.c</h3>
<div class="outline-text-3" id="text-6-5">
<p>
The next code sample creates a char driver named chardev. You can cat its device file.
</p>

<div class="org-src-container">
<pre class="src src-bash">cat /proc/devices
</pre>
</div>

<p>
(or open the file with a program) and the driver will put the number of times the device file has been read from into the file. We don't support writing to the file (like <b>echo "hi" &gt; /dev/hello</b>), but catch these attempts and tell the user that the operation isn't supported. Don't worry if you don't see what we do with the data we read into the buffer; we don't do much with it. We simply read in the data and print a message acknowledging that we received it.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  chardev.c: Creates a read-only char device that says how many times</span>
<span style="color: #7f7f7f;"> *  you've read from the dev file</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/delay.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/device.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/irq.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/uaccess.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/irq.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/io.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/poll.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/cdev.h&gt;</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  Prototypes - this would normally go in a .h file</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *);
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_release</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *);
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">device_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">loff_t</span> *);
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">device_write</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *, <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">size_t</span>, <span style="color: #98f5ff;">loff_t</span> *);

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SUCCESS</span> 0
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DEVICE_NAME</span> <span style="color: #deb887;">"chardev"</span>   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Dev name as it appears in /proc/devices</span><span style="color: #7f7f7f;">   */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">BUF_LEN</span> 80              <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Max length of the message from the device</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Global variables are declared as static, so are global within the file.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">Major</span>;               <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Major number assigned to our device driver</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">Device_Open</span> = 0;     <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Is device open?</span>
<span style="color: #7f7f7f;">                                 * Used to prevent multiple access to device</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">msg</span>[BUF_LEN];       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The msg the device will give when asked</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">msg_Ptr</span>;

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">class</span> *<span style="color: #4eee94;">cls</span>;

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_operations</span> <span style="color: #4eee94;">chardev_fops</span> = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release
};

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function is called when the module is loaded</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>(<span style="color: #98f5ff;">void</span>)
{
    Major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);

    <span style="color: #00bfff;">if</span> (Major &lt; 0) {
        pr_alert(<span style="color: #deb887;">"Registering char device failed with %d\n"</span>, Major);
        <span style="color: #00bfff;">return</span> Major;
    }

    pr_info(<span style="color: #deb887;">"I was assigned major number %d.\n"</span>, Major);

    cls = class_create(THIS_MODULE, DEVICE_NAME);
    device_create(cls, <span style="color: #a2cd5a;">NULL</span>, MKDEV(Major, 0), <span style="color: #a2cd5a;">NULL</span>, DEVICE_NAME);

    pr_info(<span style="color: #deb887;">"Device created on /dev/%s\n"</span>, DEVICE_NAME);

    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function is called when the module is unloaded</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>(<span style="color: #98f5ff;">void</span>)
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Unregister the device</span>
<span style="color: #7f7f7f;">     */</span>
    unregister_chrdev(Major, DEVICE_NAME);
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Methods</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when a process tries to open the device file, like</span>
<span style="color: #7f7f7f;"> * "cat /dev/mycharfile"</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    <span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">counter</span> = 0;

    <span style="color: #00bfff;">if</span> (Device_Open)
        <span style="color: #00bfff;">return</span> -EBUSY;

    Device_Open++;
    sprintf(msg, <span style="color: #deb887;">"I already told you %d times Hello world!\n"</span>, counter++);
    msg_Ptr = msg;
    try_module_get(THIS_MODULE);

    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when a process closes the device file.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_release</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    Device_Open--;          <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're now ready for our next caller</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Decrement the usage count, or else once you opened the file, you'll</span>
<span style="color: #7f7f7f;">     * never get get rid of the module.</span>
<span style="color: #7f7f7f;">     */</span>
    module_put(THIS_MODULE);

    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when a process, which already opened the dev file, attempts to</span>
<span style="color: #7f7f7f;"> * read from it.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">device_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">filp</span>,   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">see include/linux/fs.h</span><span style="color: #7f7f7f;">   */</span>
                           <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buffer</span>,        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">buffer to fill with data</span><span style="color: #7f7f7f;"> */</span>
                           <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">length</span>,       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">length of the buffer</span><span style="color: #7f7f7f;">     */</span>
                           <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Number of bytes actually written to the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">bytes_read</span> = 0;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If we're at the end of the message,</span>
<span style="color: #7f7f7f;">     * return 0 signifying end of file</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (*msg_Ptr == 0)
        <span style="color: #00bfff;">return</span> 0;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Actually put the data into the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">while</span> (length &amp;&amp; *msg_Ptr) {

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * The buffer is in the user data segment, not the kernel</span>
<span style="color: #7f7f7f;">         * segment so "*" assignment won't work.  We have to use</span>
<span style="color: #7f7f7f;">         * put_user which copies data from the kernel data segment to</span>
<span style="color: #7f7f7f;">         * the user data segment.</span>
<span style="color: #7f7f7f;">         */</span>
        put_user(*(msg_Ptr++), buffer++);

        length--;
        bytes_read++;
    }

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Most read functions return the number of bytes put into the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> bytes_read;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when a process writes to dev file: echo "hi" &gt; /dev/hello</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">device_write</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">filp</span>,
                            <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buff</span>,
                            <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>,
                            <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">off</span>)
{
    pr_alert(<span style="color: #deb887;">"Sorry, this operation isn't supported.\n"</span>);
    <span style="color: #00bfff;">return</span> -EINVAL;
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org6e16aae" class="outline-3">
<h3 id="org6e16aae"><span class="section-number-3">6.6.</span> Writing Modules for Multiple Kernel Versions</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The system calls, which are the major interface the kernel shows to the processes, generally stay the same across versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is necessary for backward compatibility &#x2013; a new kernel version is not supposed to break regular processes. In most cases, the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change between versions.
</p>

<p>
The Linux kernel versions are divided between the stable versions (n.$&lt;\(even number\)&gt;$.m) and the development versions (n.$&lt;\(odd number\)&gt;$.m). The development versions include all the cool new ideas, including those which will be considered a mistake, or reimplemented, in the next version. As a result, you can't trust the interface to remain the same in those versions (which is why I don't bother to support them in this book, it's too much work and it would become dated too quickly). In the stable versions, on the other hand, we can expect the interface to remain the same regardless of the bug fix version (the m number).
</p>

<p>
There are differences between different kernel versions, and if you want to support multiple kernel versions, you'll find yourself having to code conditional compilation directives. The way to do this to compare the macro LINUX_VERSION_CODE to the macro KERNEL_VERSION. In version a.b.c of the kernel, the value of this macro would be \(2^{16}a+2^{8}b+c\).
</p>

<p>
While previous versions of this guide showed how you can write backward compatible code with such constructs in great detail, we decided to break with this tradition for the better. People interested in doing such might now use a LKMPG with a version matching to their kernel. We decided to version the LKMPG like the kernel, at least as far as major and minor number are concerned. We use the patchlevel for our own versioning so use LKMPG version 2.4.x for kernels 2.4.x, use LKMPG version 2.6.x for kernels 2.6.x and so on. Also make sure that you always use current, up to date versions of both, kernel and guide.
</p>

<p>
You might already have noticed that recent kernels look different. In case you haven't they look like 2.6.x.y now. The meaning of the first three items basically stays the same, but a subpatchlevel has been added and will indicate security fixes till the next stable patchlevel is out. So people can choose between a stable tree with security updates and use the latest kernel as developer tree. Search the kernel mailing list archives if you're interested in the full story.
</p>
</div>
</div>
</div>

<div id="outline-container-orge63ca91" class="outline-2">
<h2 id="orge63ca91"><span class="section-number-2">7.</span> The /proc File System</h2>
<div class="outline-text-2" id="text-7">
<p>
In Linux, there is an additional mechanism for the kernel and kernel modules to send information to processes &#x2014; the <b>/proc</b> file system. Originally designed to allow easy access to information about processes (hence the name), it is now used by every bit of the kernel which has something interesting to report, such as <b>/proc/modules</b> which provides the list of modules and <b>/proc/meminfo</b> which stats memory usage statistics.
</p>

<p>
The method to use the proc file system is very similar to the one used with device drivers &#x2014; a structure is created with all the information needed for the <b>/proc</b> file, including pointers to any handler functions (in our case there is only one, the one called when somebody attempts to read from the <b>/proc</b> file). Then, init_module registers the structure with the kernel and cleanup_module unregisters it.
</p>

<p>
Normal file systems are located on a disk, rather than just in memory (which is where <b>/proc</b> is), and in that case the inode number is a pointer to a disk location where the file's index-node (inode for short) is located. The inode contains information about the file, for example the file's permissions, together with a pointer to the disk location or locations where the file's data can be found.
</p>

<p>
Because we don't get called when the file is opened or closed, there's nowhere for us to put try_module_get and try_module_put in this module, and if the file is opened and then the module is removed, there's no way to avoid the consequences.
</p>

<p>
Here a simple example showing how to use a <b>/proc</b> file. This is the HelloWorld for the <b>/proc</b> filesystem. There are three parts: create the file <b><i>proc</i> helloworld</b> in the function init_module, return a value (and a buffer) when the file <b>/proc/helloworld</b> is read in the callback function <b>procfile_read</b>, and delete the file <b>/proc/helloworld</b> in the function cleanup_module.
</p>

<p>
The <b>/proc/helloworld</b> is created when the module is loaded with the function <b>proc_create</b>. The return value is a <b>struct proc_dir_entry</b> , and it will be used to configure the file <b>/proc/helloworld</b> (for example, the owner of this file). A null return value means that the creation has failed.
</p>

<p>
Each time, everytime the file <b>/proc/helloworld</b> is read, the function <b>procfile_read</b> is called. Two parameters of this function are very important: the buffer (the first parameter) and the offset (the third one). The content of the buffer will be returned to the application which read it (for example the cat command). The offset is the current position in the file. If the return value of the function isn't null, then this function is called again. So be careful with this function, if it never returns zero, the read function is called endlessly.
</p>

<div class="org-src-container">
<pre class="src src-txt"># cat /proc/helloworld
HelloWorld!
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> procfs1.c</span>
<span style="color: #7f7f7f;">*/</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/proc_fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">procfs_name</span> <span style="color: #deb887;">"helloworld"</span>

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_dir_entry</span> *<span style="color: #4eee94;">Our_Proc_File</span>;


<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">procfile_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">filePointer</span>,<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buffer</span>,
                      <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">buffer_length</span>, <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span>=0;
    <span style="color: #00bfff;">if</span>(strlen(buffer) ==0) {
        pr_info(<span style="color: #deb887;">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span style="color: #deb887;">"HelloWorld!\n"</span>,<span style="color: #00bfff;">sizeof</span>(<span style="color: #deb887;">"HelloWorld!\n"</span>));
        ret=<span style="color: #00bfff;">sizeof</span>(<span style="color: #deb887;">"HelloWorld!\n"</span>);
    }
    <span style="color: #00bfff;">return</span> ret;

}

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">proc_file_fops</span> = {
    .proc_read  = procfile_read,
};

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    Our_Proc_File = proc_create(procfs_name,0644,<span style="color: #a2cd5a;">NULL</span>,&amp;proc_file_fops);
    <span style="color: #00bfff;">if</span>(<span style="color: #a2cd5a;">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span style="color: #deb887;">"Error:Could not initialize /proc/%s\n"</span>,procfs_name);
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }

    pr_info(<span style="color: #deb887;">"/proc/%s created\n"</span>, procfs_name);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span style="color: #deb887;">"/proc/%s removed\n"</span>, procfs_name);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>

<div id="outline-container-orgf1b38e3" class="outline-3">
<h3 id="orgf1b38e3"><span class="section-number-3">7.1.</span> Read and Write a /proc File</h3>
<div class="outline-text-3" id="text-7-1">
<p>
We have seen a very simple example for a /proc file where we only read the file /proc/helloworld. It's also possible to write in a /proc file. It works the same way as read, a function is called when the /proc file is written. But there is a little difference with read, data comes from user, so you have to import data from user space to kernel space (with copy_from_user or get_user)
</p>

<p>
The reason for copy_from_user or get_user is that Linux memory (on Intel architecture, it may be different under some other processors) is segmented. This means that a pointer, by itself, does not reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to be able to use it. There is one memory segment for the kernel, and one for each of the processes.
</p>

<p>
The only memory segment accessible to a process is its own, so when writing regular programs to run as processes, there's no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the process segment. The put_user and get_user macros allow you to access that memory. These functions handle only one caracter, you can handle several caracters with copy_to_user and copy_from_user. As the buffer (in read or write function) is in kernel space, for write function you need to import data because it comes from user space, but not for the read function because data is already in kernel space.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> *  procfs2.c -  create a "file" in /proc</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/proc_fs.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Necessary because we use the proc fs</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for copy_from_user</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROCFS_MAX_SIZE</span>         1024
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROCFS_NAME</span>             <span style="color: #deb887;">"buffer1k"</span>

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This structure hold information about the /proc file</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_dir_entry</span> *<span style="color: #4eee94;">Our_Proc_File</span>;

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * The buffer used to store character for this module</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">procfs_buffer</span>[PROCFS_MAX_SIZE];

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * The size of the buffer</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">procfs_buffer_size</span> = 0;

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called then the /proc file is read</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">procfile_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">filePointer</span>,<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buffer</span>,
                      <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">buffer_length</span>, <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span>=0;
    <span style="color: #00bfff;">if</span>(strlen(buffer) ==0) {
        pr_info(<span style="color: #deb887;">"procfile read %s\n"</span>,filePointer-&gt;f_path.dentry-&gt;d_name.name);
        ret=copy_to_user(buffer,<span style="color: #deb887;">"HelloWorld!\n"</span>,<span style="color: #00bfff;">sizeof</span>(<span style="color: #deb887;">"HelloWorld!\n"</span>));
        ret=<span style="color: #00bfff;">sizeof</span>(<span style="color: #deb887;">"HelloWorld!\n"</span>);
    }
    <span style="color: #00bfff;">return</span> ret;
}


<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called with the /proc file is written</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">procfile_write</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>, <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buff</span>,
                              <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">off</span>)
{
    procfs_buffer_size = len;
    <span style="color: #00bfff;">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;

    <span style="color: #00bfff;">if</span> (copy_from_user(procfs_buffer, buff, procfs_buffer_size))
        <span style="color: #00bfff;">return</span> -EFAULT;

    procfs_buffer[procfs_buffer_size] = <span style="color: #deb887;">'\0'</span>;
    <span style="color: #00bfff;">return</span> procfs_buffer_size;
}

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">proc_file_fops</span> = {
    .proc_read  = procfile_read,
    .proc_write  = procfile_write,
};

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> *This function is called when the module is loaded</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_NAME,0644,<span style="color: #a2cd5a;">NULL</span>,&amp;proc_file_fops);
    <span style="color: #00bfff;">if</span>(<span style="color: #a2cd5a;">NULL</span>==Our_Proc_File) {
        proc_remove(Our_Proc_File);
        pr_alert(<span style="color: #deb887;">"Error:Could not initialize /proc/%s\n"</span>,PROCFS_NAME);
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }

    pr_info(<span style="color: #deb887;">"/proc/%s created\n"</span>, PROCFS_NAME);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> *This function is called when the module is unloaded</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    proc_remove(Our_Proc_File);
    pr_info(<span style="color: #deb887;">"/proc/%s removed\n"</span>, PROCFS_NAME);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcbef8b9" class="outline-3">
<h3 id="orgcbef8b9"><span class="section-number-3">7.2.</span> Manage /proc file with standard filesystem</h3>
<div class="outline-text-3" id="text-7-2">
<p>
We have seen how to read and write a /proc file with the /proc interface. But it's also possible to manage /proc file with inodes. The main concern is to use advanced functions, like permissions.
</p>

<p>
In Linux, there is a standard mechanism for file system registration. Since every file system has to have its own functions to handle inode and file operations, there is a special structure to hold pointers to all those functions, struct <b>inode_operations</b>, which includes a pointer to struct proc_ops.
</p>

<p>
The difference between file and inode operations is that file operations deal with the file itself whereas inode operations deal with ways of referencing the file, such as creating links to it.
</p>

<p>
In /proc, whenever we register a new file, we're allowed to specify which struct inode_operations will be used to access to it. This is the mechanism we use, a struct inode_operations which includes a pointer to a struct proc_ops which includes pointers to our procfs_read and procfs_write functions.
</p>

<p>
Another interesting point here is the module_permission function. This function is called whenever a process tries to do something with the /proc file, and it can decide whether to allow access or not. Right now it is only based on the operation and the uid of the current user (as available in current, a pointer to a structure which includes information on the currently running process), but it could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last input we received.
</p>

<p>
It's important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for output, whereas write functions are used for input. The reason for that is that read and write refer to the user's point of view &#x2014; if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something to the kernel, then the kernel receives it as input.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">    procfs3.c</span>
<span style="color: #7f7f7f;">*/</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/proc_fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/sched.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROCFS_MAX_SIZE</span>         2048
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROCFS_ENTRY_FILENAME</span>   <span style="color: #deb887;">"buffer2k"</span>

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_dir_entry</span> *<span style="color: #4eee94;">Our_Proc_File</span>;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">procfs_buffer</span>[PROCFS_MAX_SIZE];
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">procfs_buffer_size</span> = 0;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">procfs_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">filp</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buffer</span>,
                           <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">length</span>, <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">offset</span>)
{
    <span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">finished</span> = 0;
    <span style="color: #00bfff;">if</span>(finished)
    {
        pr_debug(<span style="color: #deb887;">"procfs_read: END\n"</span>);
        finished = 0;
        <span style="color: #00bfff;">return</span> 0;
    }
    finished = 1;
    <span style="color: #00bfff;">if</span>(copy_to_user(buffer, procfs_buffer, procfs_buffer_size))
        <span style="color: #00bfff;">return</span> -EFAULT;
    pr_debug(<span style="color: #deb887;">"procfs_read: read %lu bytes\n"</span>, procfs_buffer_size);
    <span style="color: #00bfff;">return</span> procfs_buffer_size;
}
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">procfs_write</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>,  <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buffer</span>,
                            <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">off</span>)
{
    <span style="color: #00bfff;">if</span>(len&gt;PROCFS_MAX_SIZE)
        procfs_buffer_size = PROCFS_MAX_SIZE;
    <span style="color: #00bfff;">else</span>
        procfs_buffer_size = len;
    <span style="color: #00bfff;">if</span>(copy_from_user(procfs_buffer, buffer, procfs_buffer_size))
        <span style="color: #00bfff;">return</span> -EFAULT;
    pr_debug(<span style="color: #deb887;">"procfs_write: write %lu bytes\n"</span>, procfs_buffer_size);
    <span style="color: #00bfff;">return</span> procfs_buffer_size;
}
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">procfs_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    try_module_get(THIS_MODULE);
    <span style="color: #00bfff;">return</span> 0;
}
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">procfs_close</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    module_put(THIS_MODULE);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">File_Ops_4_Our_Proc_File</span> = {
    .proc_read       = procfs_read,
    .proc_write      = procfs_write,
    .proc_open       = procfs_open,
    .proc_release    = procfs_close,
};

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    Our_Proc_File = proc_create(PROCFS_ENTRY_FILENAME, 0644, <span style="color: #a2cd5a;">NULL</span>,&amp;File_Ops_4_Our_Proc_File);
    <span style="color: #00bfff;">if</span>(Our_Proc_File == <span style="color: #a2cd5a;">NULL</span>)
    {
        remove_proc_entry(PROCFS_ENTRY_FILENAME, <span style="color: #a2cd5a;">NULL</span>);
        pr_debug(<span style="color: #deb887;">"Error: Could not initialize /proc/%s\n"</span>, PROCFS_ENTRY_FILENAME);
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_debug(<span style="color: #deb887;">"/proc/%s created\n"</span>, PROCFS_ENTRY_FILENAME);
    <span style="color: #00bfff;">return</span> 0;
}
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span style="color: #a2cd5a;">NULL</span>);
    pr_debug(<span style="color: #deb887;">"/proc/%s removed\n"</span>, PROCFS_ENTRY_FILENAME);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming that procfs is on it's way out, consider using sysfs instead. Second, if you really can't get enough, there's a highly recommendable bonus level for procfs below linux/Documentation/DocBook/ . Use make help in your toplevel kernel directory for instructions about how to convert it into your favourite format. Example: make htmldocs . Consider using this mechanism, in case you want to document something kernel related yourself.
</p>
</div>
</div>

<div id="outline-container-orgb1a4ad9" class="outline-3">
<h3 id="orgb1a4ad9"><span class="section-number-3">7.3.</span> Manage /proc file with seq_file</h3>
<div class="outline-text-3" id="text-7-3">
<p>
As we have seen, writing a /proc file may be quite "complex". So to help
people writting /proc file, there is an API named seq_file that helps
formating a /proc file for output. It's based on sequence, which is composed of 3 functions: start(), next(), and stop(). The seq_file API starts a sequence when a user read the /proc file.
</p>

<p>
A sequence begins with the call of the function start(). If the return is a
non NULL value, the function next() is called. This function is an iterator, the goal is to go thought all the data. Each time next() is called, the function show() is also called. It writes data values in the buffer read by the user. The function next() is called until it returns NULL. The sequence ends when next() returns NULL, then the function stop() is called.
</p>

<p>
BE CARREFUL: when a sequence is finished, another one starts. That means that at the end of function stop(), the function start() is called again. This loop finishes when the function start() returns NULL. You can see a scheme of this in the figure "How seq_file works".
</p>


<div id="org3b3b189" class="figure">
<p><img src="img/seq_file.png" alt="seq_file.png" width="50%" height="10%" align="center" />
</p>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
Seq_file provides basic functions for proc_ops, as seq_read, seq_lseek, and some others. But nothing to write in the /proc file. Of course, you can still use the same way as in the previous example.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> *  procfs4.c -  create a "file" in /proc</span>
<span style="color: #ffe4b5;"> *      This program uses the seq_file library to manage the /proc file.</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/proc_fs.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Necessary because we use proc fs</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/seq_file.h&gt;</span>     <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for seq_file</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROC_NAME</span>       <span style="color: #deb887;">"iter"</span>

MODULE_AUTHOR(<span style="color: #deb887;">"Philippe Reynes"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called at the beginning of a sequence.</span>
<span style="color: #ffe4b5;"> * ie, when:</span>
<span style="color: #ffe4b5;"> *      - the /proc file is read (first time)</span>
<span style="color: #ffe4b5;"> *      - after the function stop (end of sequence)</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> *<span style="color: #daa520;">my_seq_start</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_file</span> *<span style="color: #4eee94;">s</span>, <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">pos</span>)
{
    <span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">counter</span> = 0;

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">beginning a new sequence ?</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> ( *pos == 0 ) {
        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">yes =&gt; return a non null value to begin the sequence</span><span style="color: #7f7f7f;"> */</span>
        <span style="color: #00bfff;">return</span> &amp;counter;
    }
    <span style="color: #00bfff;">else</span> {
        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">no =&gt; it's the end of the sequence, return end to stop reading</span><span style="color: #7f7f7f;"> */</span>
        *pos = 0;
        <span style="color: #00bfff;">return</span> <span style="color: #a2cd5a;">NULL</span>;
    }
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called after the beginning of a sequence.</span>
<span style="color: #ffe4b5;"> * It's called untill the return is NULL (this ends the sequence).</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> *<span style="color: #daa520;">my_seq_next</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_file</span> *<span style="color: #4eee94;">s</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">v</span>, <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">pos</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *<span style="color: #4eee94;">tmp_v</span> = (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *)v;
    (*tmp_v)++;
    (*pos)++;
    <span style="color: #00bfff;">return</span> <span style="color: #a2cd5a;">NULL</span>;
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called at the end of a sequence</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">my_seq_stop</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_file</span> *<span style="color: #4eee94;">s</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">v</span>)
{
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">nothing to do, we use a static value in start()</span><span style="color: #7f7f7f;"> */</span>
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called for each "step" of a sequence</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">my_seq_show</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_file</span> *<span style="color: #4eee94;">s</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">v</span>)
{
    <span style="color: #98f5ff;">loff_t</span> *<span style="color: #4eee94;">spos</span> = (<span style="color: #98f5ff;">loff_t</span> *) v;

    seq_printf(s, <span style="color: #deb887;">"%Ld\n"</span>, *spos);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This structure gather "function" to manage the sequence</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">seq_operations</span> <span style="color: #4eee94;">my_seq_ops</span> = {
        .start = my_seq_start,
        .next  = my_seq_next,
        .stop  = my_seq_stop,
        .show  = my_seq_show
};

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called when the /proc file is open.</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">my_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    <span style="color: #00bfff;">return</span> seq_open(file, &amp;my_seq_ops);
};

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This structure gather "function" that manage the /proc file</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">my_file_ops</span> = {
    .proc_open    = my_open,
    .proc_read    = seq_read,
    .proc_lseek  = seq_lseek,
    .proc_release = seq_release
};


<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called when the module is loaded</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_dir_entry</span> *<span style="color: #4eee94;">entry</span>;

    entry = proc_create(PROC_NAME, 0, <span style="color: #a2cd5a;">NULL</span>, &amp;my_file_ops);
    <span style="color: #00bfff;">if</span>(entry == <span style="color: #a2cd5a;">NULL</span>)
    {
        remove_proc_entry(PROC_NAME, <span style="color: #a2cd5a;">NULL</span>);
        pr_debug(<span style="color: #deb887;">"Error: Could not initialize /proc/%s\n"</span>, PROC_NAME);
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #ffe4b5;">/**</span>
<span style="color: #ffe4b5;"> * This function is called when the module is unloaded.</span>
<span style="color: #ffe4b5;"> *</span>
<span style="color: #ffe4b5;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>(<span style="color: #98f5ff;">void</span>)
{
    remove_proc_entry(PROC_NAME, <span style="color: #a2cd5a;">NULL</span>);
    pr_debug(<span style="color: #deb887;">"/proc/%s removed\n"</span>, PROC_NAME);
}
</pre>
</div>

<p>
If you want more information, you can read this web page:
</p>

<ul class="org-ul">
<li><a href="http://lwn.net/Articles/22355/">http://lwn.net/Articles/22355/</a></li>

<li><a href="http://www.kernelnewbies.org/documents/seq_file_howto.txt">http://www.kernelnewbies.org/documents/seq_file_howto.txt</a></li>
</ul>


<p>
You can also read the code of fs/seq_file.c in the linux kernel.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf84041c" class="outline-2">
<h2 id="orgf84041c"><span class="section-number-2">8.</span> sysfs: Interacting with your module</h2>
<div class="outline-text-2" id="text-8">
<p>
<i>sysfs</i> allows you to interact with the running kernel from userspace by reading or setting variables inside of modules. This can be useful for debugging purposes, or just as an interface for applications or scripts. You can find sysfs directories and files under the <i>sys</i> directory on your system.
</p>

<div class="org-src-container">
<pre class="src src-bash">ls -l /sys
</pre>
</div>

<p>
An example of a hello world module which includes the creation of a variable accessible via sysfs is given below.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * hello-sysfs.c sysfs example</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kobject.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/sysfs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/string.h&gt;</span>

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobject</span> *<span style="color: #4eee94;">mymodule</span>;

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">the variable you want to be able to change</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">myvariable</span> = 0;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">myvariable_show</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobject</span> *<span style="color: #4eee94;">kobj</span>,
                               <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobj_attribute</span> *<span style="color: #4eee94;">attr</span>,
                               <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>)
{
    <span style="color: #00bfff;">return</span> sprintf(buf, <span style="color: #deb887;">"%d\n"</span>, myvariable);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">myvariable_store</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobject</span> *<span style="color: #4eee94;">kobj</span>,
                                <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobj_attribute</span> *<span style="color: #4eee94;">attr</span>,
                                <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">count</span>)
{
    sscanf(buf, <span style="color: #deb887;">"%du"</span>, &amp;myvariable);
    <span style="color: #00bfff;">return</span> count;
}


<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">kobj_attribute</span> <span style="color: #4eee94;">myvariable_attribute</span> =
    __ATTR(myvariable, 0660, myvariable_show,
           (<span style="color: #98f5ff;">void</span>*)myvariable_store);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> mymodule_init (<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">error</span> = 0;

    pr_info(<span style="color: #deb887;">"mymodule: initialised\n"</span>);

    mymodule =
        kobject_create_and_add(<span style="color: #deb887;">"mymodule"</span>, kernel_kobj);
    <span style="color: #00bfff;">if</span> (!mymodule)
        <span style="color: #00bfff;">return</span> -ENOMEM;

    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr);
    <span style="color: #00bfff;">if</span> (error) {
        pr_info(<span style="color: #deb887;">"failed to create the myvariable file "</span> \
                <span style="color: #deb887;">"in /sys/kernel/mymodule\n"</span>);
    }

    <span style="color: #00bfff;">return</span> error;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> mymodule_exit (<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"mymodule: Exit success\n"</span>);
    kobject_put(mymodule);
}

<span style="color: #daa520;">module_init</span>(mymodule_init);
<span style="color: #daa520;">module_exit</span>(mymodule_exit);
</pre>
</div>

<p>
Make and install the module:
</p>

<div class="org-src-container">
<pre class="src src-sh">make
sudo insmod hello-sysfs.ko
</pre>
</div>

<p>
Check that it exists:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo lsmod | grep hello_sysfs
</pre>
</div>

<p>
What is the current value of <i>myvariable</i> ?
</p>

<div class="org-src-container">
<pre class="src src-sh">cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Set the value of <i>myvariable</i> and check that it changed.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #f08080;">echo</span> <span style="color: #deb887;">"32"</span> &gt; /sys/kernel/mymodule/myvariable
cat /sys/kernel/mymodule/myvariable
</pre>
</div>

<p>
Finally, remove the test module:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo rmmod hello_sysfs
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdbcb863" class="outline-2">
<h2 id="orgdbcb863"><span class="section-number-2">9.</span> Talking To Device Files</h2>
<div class="outline-text-2" id="text-9">
<p>
Device files are supposed to represent physical devices. Most physical devices are used for output as well as input, so there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this is implemented by device_write.
</p>

<p>
This is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is still implemented from the CPU's perspective as a serial port connected to a modem, so you don't have to tax your imagination too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data to be sent through the phone line) and read things from the modem (either responses for commands or the data received through the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for example to send the rate at which data is sent and received.
</p>

<p>
The answer in Unix is to use a special function called <b>ioctl</b> (short for Input Output ConTroL). Every device can have its own ioctl commands, which can be read ioctl's (to send information from a process to the kernel), write ioctl's (to return information to a process), both or neither. Notice here the roles of read and write are reversed again, so in ioctl's read is to send information to the kernel and write is to receive information from the kernel.
</p>

<p>
The ioctl function is called with three parameters: the file descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to use it to pass anything. You won't be able to pass a structure this way, but you will be able to pass a pointer to the structure.
</p>

<p>
The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter. This ioctl number is usually created by a macro call (_IO, _IOR, _IOW or _IOWR &#x2014; depending on the type) in a header file. This header file should then be included both by the programs which will use ioctl (so they can generate the appropriate ioctl's) and by the kernel module (so it can understand it). In the example below, the header file is chardev.h and the program which uses it is ioctl.c.
</p>

<p>
If you want to use ioctls in your own kernel modules, it is best to receive an official ioctl assignment, so if you accidentally get somebody else's ioctls, or if they get yours, you'll know something is wrong. For more information, consult the kernel source tree at Documentation/ioctl-number.txt.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  chardev2.c - Create an input/output character device</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/delay.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/device.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/irq.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/uaccess.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/irq.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/io.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/poll.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/cdev.h&gt;</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"chardev.h"</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SUCCESS</span> 0
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DEVICE_NAME</span> <span style="color: #deb887;">"char_dev"</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">BUF_LEN</span> 80

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Is the device open right now? Used to prevent</span>
<span style="color: #7f7f7f;"> * concurent access into the same device</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">Device_Open</span> = 0;

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The message the device will give when asked</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">Message</span>[BUF_LEN];

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * How far did the process reading the message get?</span>
<span style="color: #7f7f7f;"> * Useful if the message is larger than the size of the</span>
<span style="color: #7f7f7f;"> * buffer we get to fill in device_read.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">Message_Ptr</span>;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">Major</span>;               <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Major number assigned to our device driver</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">class</span> *<span style="color: #4eee94;">cls</span>;

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This is called whenever a process attempts to open the device file</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
<span style="color: #ffd700;">#ifdef</span> DEBUG
        pr_info(<span style="color: #deb887;">"device_open(%p)\n"</span>, file);
<span style="color: #ffd700;">#endif</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * We don't want to talk to two processes at the same time</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (Device_Open)
        <span style="color: #00bfff;">return</span> -EBUSY;

    Device_Open++;
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Initialize the message</span>
<span style="color: #7f7f7f;">     */</span>
    Message_Ptr = Message;
    try_module_get(THIS_MODULE);
    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">device_release</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
<span style="color: #ffd700;">#ifdef</span> DEBUG
    pr_info(<span style="color: #deb887;">"device_release(%p,%p)\n"</span>, inode, file);
<span style="color: #ffd700;">#endif</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * We're now ready for our next caller</span>
<span style="color: #7f7f7f;">     */</span>
    Device_Open--;

    module_put(THIS_MODULE);
    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function is called whenever a process which has already opened the</span>
<span style="color: #7f7f7f;"> * device file attempts to read from it.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">device_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>,   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">see include/linux/fs.h</span><span style="color: #7f7f7f;">   */</span>
                           <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">__user</span> * buffer,        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">buffer to be</span>
<span style="color: #7f7f7f;">                                                         * filled with data</span><span style="color: #7f7f7f;"> */</span>
                           <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">length</span>,       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">length of the buffer</span><span style="color: #7f7f7f;">     */</span>
                           <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Number of bytes actually written to the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">bytes_read</span> = 0;

<span style="color: #ffd700;">#ifdef</span> DEBUG
    pr_info(<span style="color: #deb887;">"device_read(%p,%p,%d)\n"</span>, file, buffer, length);
<span style="color: #ffd700;">#endif</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If we're at the end of the message, return 0</span>
<span style="color: #7f7f7f;">     * (which signifies end of file)</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (*Message_Ptr == 0)
        <span style="color: #00bfff;">return</span> 0;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Actually put the data into the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">while</span> (length &amp;&amp; *Message_Ptr) {

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Because the buffer is in the user data segment,</span>
<span style="color: #7f7f7f;">     * not the kernel data segment, assignment wouldn't</span>
<span style="color: #7f7f7f;">     * work. Instead, we have to use put_user which</span>
<span style="color: #7f7f7f;">     * copies data from the kernel data segment to the</span>
<span style="color: #7f7f7f;">     * user data segment.</span>
<span style="color: #7f7f7f;">     */</span>
     put_user(*(Message_Ptr++), buffer++);
     length--;
     bytes_read++;
}

<span style="color: #ffd700;">#ifdef</span> DEBUG
    pr_info(<span style="color: #deb887;">"Read %d bytes, %d left\n"</span>, bytes_read, length);
<span style="color: #ffd700;">#endif</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Read functions are supposed to return the number</span>
<span style="color: #7f7f7f;">     * of bytes actually inserted into the buffer</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> bytes_read;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function is called when somebody tries to</span>
<span style="color: #7f7f7f;"> * write into our device file.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span>
<span style="color: #daa520;">device_write</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>,
             <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">__user</span> * buffer, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">length</span>, <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

<span style="color: #ffd700;">#ifdef</span> DEBUG
    pr_info(<span style="color: #deb887;">"device_write(%p,%s,%d)"</span>, file, buffer, length);
<span style="color: #ffd700;">#endif</span>

    <span style="color: #00bfff;">for</span> (i = 0; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++)
        get_user(Message[i], buffer + i);

    Message_Ptr = Message;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Again, return the number of input characters used</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> i;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function is called whenever a process tries to do an ioctl on our</span>
<span style="color: #7f7f7f;"> * device file. We get two extra parameters (additional to the inode and file</span>
<span style="color: #7f7f7f;"> * structures, which all device functions get): the number of the ioctl called</span>
<span style="color: #7f7f7f;"> * and the parameter given to the ioctl function.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * If the ioctl is write or read/write (meaning output is returned to the</span>
<span style="color: #7f7f7f;"> * calling process), the ioctl call returns the output of this function.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">long</span> <span style="color: #daa520;">device_ioctl</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>,             <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">ditto</span><span style="color: #7f7f7f;"> */</span>
                  <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ioctl_num</span>,        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">number and param for ioctl</span><span style="color: #7f7f7f;"> */</span>
                  <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">ioctl_param</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">temp</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">ch</span>;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Switch according to the ioctl called</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">switch</span> (ioctl_num) {
    <span style="color: #00bfff;">case</span> IOCTL_SET_MSG:
        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * Receive a pointer to a message (in user space) and set that</span>
<span style="color: #7f7f7f;">         * to be the device's message.  Get the parameter given to</span>
<span style="color: #7f7f7f;">         * ioctl by the process.</span>
<span style="color: #7f7f7f;">         */</span>
        temp = (<span style="color: #98f5ff;">char</span> *)ioctl_param;

         <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">          * Find the length of the message</span>
<span style="color: #7f7f7f;">          */</span>
         get_user(ch, temp);
         <span style="color: #00bfff;">for</span> (i = 0; ch &amp;&amp; i &lt; BUF_LEN; i++, temp++)
             get_user(ch, temp);

         device_write(file, (<span style="color: #98f5ff;">char</span> *)ioctl_param, i, 0);
         <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">case</span> IOCTL_GET_MSG:
        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * Give the current message to the calling process -</span>
<span style="color: #7f7f7f;">         * the parameter we got is a pointer, fill it.</span>
<span style="color: #7f7f7f;">         */</span>
        i = device_read(file, (<span style="color: #98f5ff;">char</span> *)ioctl_param, 99, 0);

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * Put a zero at the end of the buffer, so it will be</span>
<span style="color: #7f7f7f;">         * properly terminated</span>
<span style="color: #7f7f7f;">         */</span>
        put_user(<span style="color: #deb887;">'\0'</span>, (<span style="color: #98f5ff;">char</span> *)ioctl_param + i);
        <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">case</span> IOCTL_GET_NTH_BYTE:
        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * This ioctl is both input (ioctl_param) and</span>
<span style="color: #7f7f7f;">         * output (the return value of this function)</span>
<span style="color: #7f7f7f;">         */</span>
        <span style="color: #00bfff;">return</span> Message[ioctl_param];
        <span style="color: #00bfff;">break</span>;
    }

    <span style="color: #00bfff;">return</span> SUCCESS;
}

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Module Declarations</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This structure will hold the functions to be called</span>
<span style="color: #7f7f7f;"> * when a process does something to the device we</span>
<span style="color: #7f7f7f;"> * created. Since a pointer to this structure is kept in</span>
<span style="color: #7f7f7f;"> * the devices table, it can't be local to</span>
<span style="color: #7f7f7f;"> * init_module. NULL is for unimplemented functions.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_operations</span> <span style="color: #4eee94;">Fops</span> = {
        .read = device_read,
        .write = device_write,
        .unlocked_ioctl = device_ioctl,
        .open = device_open,
        .release = device_release,      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">a.k.a. close</span><span style="color: #7f7f7f;"> */</span>
};

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Initialize the module - Register the character device</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret_val</span>;
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Register the character device (atleast try)</span>
<span style="color: #7f7f7f;">     */</span>
    ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;Fops);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Negative values signify an error</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (ret_val &lt; 0) {
        pr_alert(<span style="color: #deb887;">"%s failed with %d\n"</span>,
                 <span style="color: #deb887;">"Sorry, registering the character device "</span>, ret_val);
        <span style="color: #00bfff;">return</span> ret_val;
    }

    Major = ret_val;

    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);
    device_create(cls, <span style="color: #a2cd5a;">NULL</span>, MKDEV(Major, MAJOR_NUM), <span style="color: #a2cd5a;">NULL</span>, DEVICE_FILE_NAME);

    pr_info(<span style="color: #deb887;">"Device created on /dev/%s\n"</span>, DEVICE_FILE_NAME);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Cleanup - unregister the appropriate file from /proc</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    device_destroy(cls, MKDEV(Major, 0));
    class_destroy(cls);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Unregister the device</span>
<span style="color: #7f7f7f;">     */</span>
    unregister_chrdev(Major, DEVICE_NAME);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  chardev2.h - the header file with the ioctl definitions.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  The declarations here have to be in a header file, because</span>
<span style="color: #7f7f7f;"> *  they need to be known both to the kernel module</span>
<span style="color: #7f7f7f;"> *  (in chardev.c) and the process calling ioctl (ioctl.c)</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#if</span><span style="color: #ffd700;">n</span><span style="color: #ffd700;">def</span> CHARDEV_H
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">CHARDEV_H</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/ioctl.h&gt;</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The major device number. We can't rely on dynamic</span>
<span style="color: #7f7f7f;"> * registration any more, because ioctls need to know</span>
<span style="color: #7f7f7f;"> * it.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">MAJOR_NUM</span> 100

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Set the message of the device driver</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_SET_MSG</span> _IOW(MAJOR_NUM, 0, <span style="color: #98f5ff;">char</span> *)
<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * _IOW means that we're creating an ioctl command</span>
<span style="color: #7f7f7f;"> * number for passing information from a user process</span>
<span style="color: #7f7f7f;"> * to the kernel module.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * The first arguments, MAJOR_NUM, is the major device</span>
<span style="color: #7f7f7f;"> * number we're using.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * The second argument is the number of the command</span>
<span style="color: #7f7f7f;"> * (there could be several with different meanings).</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * The third argument is the type we want to get from</span>
<span style="color: #7f7f7f;"> * the process to the kernel.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Get the message of the device driver</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_GET_MSG</span> _IOR(MAJOR_NUM, 1, <span style="color: #98f5ff;">char</span> *)
<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This IOCTL is used for output, to get the message</span>
<span style="color: #7f7f7f;"> * of the device driver. However, we still need the</span>
<span style="color: #7f7f7f;"> * buffer to place the message in to be input,</span>
<span style="color: #7f7f7f;"> * as it is allocated by the process.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Get the n'th byte of the message</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_GET_NTH_BYTE</span> _IOWR(MAJOR_NUM, 2, <span style="color: #98f5ff;">int</span>)
<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The IOCTL is used for both input and output. It</span>
<span style="color: #7f7f7f;"> * receives from the user a number, n, and returns</span>
<span style="color: #7f7f7f;"> * Message[n].</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The name of the device file</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DEVICE_FILE_NAME</span> <span style="color: #deb887;">"char_dev"</span>

<span style="color: #ffd700;">#endif</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/ioctl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/fs.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/cdev.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/slab.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">ioctl_arg</span> {
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">reg</span>;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>;
};

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Documentation/ioctl/ioctl-number.txt</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOC_MAGIC</span> <span style="color: #deb887;">'\x66'</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_VALSET</span>      _IOW(IOC_MAGIC, 0, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">ioctl_arg</span>)
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_VALGET</span>      _IOR(IOC_MAGIC, 1, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">ioctl_arg</span>)
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_VALGET_NUM</span>  _IOR(IOC_MAGIC, 2, <span style="color: #98f5ff;">int</span>)
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_VALSET_NUM</span>  _IOW(IOC_MAGIC, 3, <span style="color: #98f5ff;">int</span>)

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">IOCTL_VAL_MAXNR</span> 3
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DRIVER_NAME</span> <span style="color: #deb887;">"ioctltest"</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">test_ioctl_major</span> = 0;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">num_of_dev</span> = 1;
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">cdev</span> <span style="color: #4eee94;">test_ioctl_cdev</span>;
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ioctl_num</span> = 0;

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">test_ioctl_data</span> {
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">val</span>;
    <span style="color: #98f5ff;">rwlock_t</span> <span style="color: #4eee94;">lock</span>;
};

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">long</span> <span style="color: #daa520;">test_ioctl_ioctl</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span>* <span style="color: #4eee94;">filp</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">arg</span>) {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">test_ioctl_data</span>* <span style="color: #4eee94;">ioctl_data</span> = filp-&gt;private_data;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">retval</span> = 0;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">val</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">ioctl_arg</span> <span style="color: #4eee94;">data</span>;
    memset(&amp;data, 0, <span style="color: #00bfff;">sizeof</span>(data));

    <span style="color: #00bfff;">switch</span> (cmd) {
    <span style="color: #00bfff;">case</span> IOCTL_VALSET:

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">        if (!capable(CAP_SYS_ADMIN)) {</span>
<span style="color: #7f7f7f;">         retval = -EPERM;</span>
<span style="color: #7f7f7f;">         goto done;</span>
<span style="color: #7f7f7f;">        }</span>
<span style="color: #7f7f7f;">        if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {</span>
<span style="color: #7f7f7f;">         retval = -EFAULT;</span>
<span style="color: #7f7f7f;">         goto done;</span>
<span style="color: #7f7f7f;">        }</span>
<span style="color: #7f7f7f;">        */</span>
        <span style="color: #00bfff;">if</span> (copy_from_user(&amp;data, (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__user</span>*)arg, <span style="color: #00bfff;">sizeof</span>(data))) {
            retval = -EFAULT;
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">done</span>;
        }

        pr_alert(<span style="color: #deb887;">"IOCTL set val:%x .\n"</span>, data.val);
        write_lock(&amp;ioctl_data-&gt;lock);
        ioctl_data-&gt;val = data.val;
        write_unlock(&amp;ioctl_data-&gt;lock);
        <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">case</span> IOCTL_VALGET:
        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">        if (!access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd))) {</span>
<span style="color: #7f7f7f;">                                     retval = -EFAULT;</span>
<span style="color: #7f7f7f;">                                     goto done;</span>
<span style="color: #7f7f7f;">                             }</span>
<span style="color: #7f7f7f;">        */</span>
        read_lock(&amp;ioctl_data-&gt;lock);
        val = ioctl_data-&gt;val;
        read_unlock(&amp;ioctl_data-&gt;lock);
        data.val = val;

        <span style="color: #00bfff;">if</span> (copy_to_user((<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__user</span>*)arg, &amp;data, <span style="color: #00bfff;">sizeof</span>(data))) {
            retval = -EFAULT;
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">done</span>;
        }

        <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">case</span> IOCTL_VALGET_NUM:
        retval = __put_user(ioctl_num, (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__user</span>*)arg);
        <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">case</span> IOCTL_VALSET_NUM:
        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">        if (!capable(CAP_SYS_ADMIN))</span>
<span style="color: #7f7f7f;">         return -EPERM;</span>
<span style="color: #7f7f7f;">        */</span>
        ioctl_num = arg;
        <span style="color: #00bfff;">break</span>;

    <span style="color: #00bfff;">default</span>:
        retval = -ENOTTY;
    }

<span style="color: #a2cd5a;">done</span>:
    <span style="color: #00bfff;">return</span> retval;
}

<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">test_ioctl_read</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span>* <span style="color: #4eee94;">filp</span>, <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">__user</span>* buf, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">count</span>, <span style="color: #98f5ff;">loff_t</span>* <span style="color: #4eee94;">f_pos</span>) {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">test_ioctl_data</span>* <span style="color: #4eee94;">ioctl_data</span> = filp-&gt;private_data;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">val</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">retval</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0;
    read_lock(&amp;ioctl_data-&gt;lock);
    val = ioctl_data-&gt;val;
    read_unlock(&amp;ioctl_data-&gt;lock);

    <span style="color: #00bfff;">for</span> (; i &lt; count ; i++) {
        <span style="color: #00bfff;">if</span> (copy_to_user(&amp;buf[i], &amp;val, 1)) {
            retval = -EFAULT;
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
        }
    }

    retval = count;
<span style="color: #a2cd5a;">out</span>:
    <span style="color: #00bfff;">return</span> retval;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">test_ioctl_close</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span>* <span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span>* <span style="color: #4eee94;">filp</span>) {
    pr_alert(<span style="color: #deb887;">"%s call.\n"</span>, __func__);

    <span style="color: #00bfff;">if</span> (filp-&gt;private_data) {
        kfree(filp-&gt;private_data);
        filp-&gt;private_data = <span style="color: #a2cd5a;">NULL</span>;
    }

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">test_ioctl_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span>* <span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span>* <span style="color: #4eee94;">filp</span>) {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">test_ioctl_data</span>* <span style="color: #4eee94;">ioctl_data</span>;
    pr_alert(<span style="color: #deb887;">"%s call.\n"</span>, __func__);
    ioctl_data = kmalloc(<span style="color: #00bfff;">sizeof</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">test_ioctl_data</span>), GFP_KERNEL);

    <span style="color: #00bfff;">if</span> (ioctl_data == <span style="color: #a2cd5a;">NULL</span>) {
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }

    rwlock_init(&amp;ioctl_data-&gt;lock);
    ioctl_data-&gt;val = 0xFF;
    filp-&gt;private_data = ioctl_data;
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file_operations</span> <span style="color: #4eee94;">fops</span> = {
    .owner = THIS_MODULE,
    .open = test_ioctl_open,
    .release = test_ioctl_close,
    .read = test_ioctl_read,
    .unlocked_ioctl = test_ioctl_ioctl,
};

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">ioctl_init</span>(<span style="color: #98f5ff;">void</span>) {
    <span style="color: #98f5ff;">dev_t</span> <span style="color: #4eee94;">dev</span> = MKDEV(test_ioctl_major, 0);
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">alloc_ret</span> = 0;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cdev_ret</span> = 0;
    alloc_ret = alloc_chrdev_region(&amp;dev, 0, num_of_dev, DRIVER_NAME);

    <span style="color: #00bfff;">if</span> (alloc_ret) {
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">error</span>;
    }

    test_ioctl_major = MAJOR(dev);
    cdev_init(&amp;test_ioctl_cdev, &amp;fops);
    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev);

    <span style="color: #00bfff;">if</span> (cdev_ret) {
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">error</span>;
    }

    pr_alert(<span style="color: #deb887;">"%s driver(major: %d) installed.\n"</span>, DRIVER_NAME, test_ioctl_major);
    <span style="color: #00bfff;">return</span> 0;
<span style="color: #a2cd5a;">error</span>:

    <span style="color: #00bfff;">if</span> (cdev_ret == 0) {
        cdev_del(&amp;test_ioctl_cdev);
    }

    <span style="color: #00bfff;">if</span> (alloc_ret == 0) {
        unregister_chrdev_region(dev, num_of_dev);
    }

    <span style="color: #00bfff;">return</span> -1;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">ioctl_exit</span>(<span style="color: #98f5ff;">void</span>) {
    <span style="color: #98f5ff;">dev_t</span> <span style="color: #4eee94;">dev</span> = MKDEV(test_ioctl_major, 0);
    cdev_del(&amp;test_ioctl_cdev);
    unregister_chrdev_region(dev, num_of_dev);
    pr_alert(<span style="color: #deb887;">"%s driver removed.\n"</span>, DRIVER_NAME);
}

<span style="color: #daa520;">module_init</span>(ioctl_init);
<span style="color: #daa520;">module_exit</span>(ioctl_exit);

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Wang Chen Shu"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"This is test_ioctl module"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbaf5b73" class="outline-2">
<h2 id="orgbaf5b73"><span class="section-number-2">10.</span> System Calls</h2>
<div class="outline-text-2" id="text-10">
<p>
So far, the only thing we've done was to use well defined kernel mechanisms to register <b>/proc</b> files and device handlers. This is fine if you want to do something the kernel programmers thought you'd want, such as write a device driver. But what if you want to do something unusual, to change the behaviour of the system in some way? Then, you're mostly on your own.
</p>

<p>
If you're not being sensible and using a virtual machine then this is where kernel programming can become hazardous. While writing the example below, I killed the <b>open()</b> system call. This meant I couldn't open any files, I couldn't run any programs, and I couldn't shutdown the system. I had to restart the virtual machine. No important files got anihilated, but if I was doing this on some live mission critical system then that could have been a possible outcome. To ensure you don't lose any files, even within a test environment, please run <b>sync</b> right before you do the <b>insmod</b> and the <b>rmmod</b>.
</p>

<p>
Forget about <b>/proc</b> files, forget about device files. They're just minor details. Minutiae in the vast expanse of the universe. The real process to kernel communication mechanism, the one used by all processes, is <i>system calls</i>. When a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory), this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it. By the way, if you want to see which system calls a program uses, run <b>strace &lt;arguments&gt;</b>.
</p>

<p>
In general, a process is not supposed to be able to access the kernel. It can't access kernel memory and it can't call kernel functions. The hardware of the CPU enforces this (that's the reason why it's called `protected mode' or 'page protection').
</p>

<p>
System calls are an exception to this general rule. What happens is that the process fills the registers with the appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course, that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt 0x80. The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the operating system kernel &#x2014; and therefore you're allowed to do whatever you want.
</p>

<p>
The location in the kernel a process can jump to is called system_call. The procedure at that location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table of system calls (sys_call_table) to see the address of the kernel function to call. Then it calls the function, and after it returns, does a few system checks and then return back to the process (or to a different process, if the process time ran out). If you want to read this code, it's at the source file arch/$&lt;\(architecture\)&gt;$/kernel/entry.S, after the line ENTRY(system_call).
</p>

<p>
So, if we want to change the way a certain system call works, what we need to do is to write our own function to implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at sys_call_table to point to our function. Because we might be removed later and we don't want to leave the system in an unstable state, it's important for cleanup_module to restore the table to its original state.
</p>

<p>
The source code here is an example of such a kernel module. We want to "spy" on a certain user, and to <b>pr_info()</b> a message whenever that user opens a file. Towards this end, we replace the system call to open a file with our own function, called <b>our_sys_open</b>. This function checks the uid (user's id) of the current process, and if it's equal to the uid we spy on, it calls pr_info() to display the name of the file to be opened. Then, either way, it calls the original open() function with the same parameters, to actually open the file.
</p>

<p>
The <b>init_module</b> function replaces the appropriate location in <b>sys_call_table</b> and keeps the original pointer in a variable. The cleanup_module function uses that variable to restore everything back to normal. This approach is dangerous, because of the possibility of two kernel modules changing the same system call. Imagine we have two kernel modules, A and B. A's open system call will be A_open and B's will be B_open. Now, when A is inserted into the kernel, the system call is replaced with A_open, which will call the original sys_open when it's done. Next, B is inserted into the kernel, which replaces the system call with B_open, which will call what it thinks is the original system call, A_open, when it's done.
</p>

<p>
Now, if B is removed first, everything will be well &#x2014; it will simply restore the system call to A_open, which calls the original. However, if A is removed and then B is removed, the system will crash. A's removal will restore the system call to the original, sys_open, cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks is the original, <b>A_open</b>, which is no longer in memory. At first glance, it appears we could solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all (so that B won't change the system call when it's removed), but that will cause an even worse problem. When A is removed, it sees that the system call was changed to <b>B_open</b> so that it is no longer pointing to <b>A_open</b>, so it won't restore it to <b>sys_open</b> before it is removed from memory. Unfortunately, <b>B_open</b> will still try to call <b>A_open</b> which is no longer there, so that even without removing B the system would crash.
</p>

<p>
Note that all the related problems make syscall stealing unfeasiable for production use. In order to keep people from doing potential harmful things <b>sys_call_table</b> is no longer exported. This means, if you want to do something more than a mere dry run of this example, you will have to patch your current kernel in order to have sys_call_table exported. In the example directory you will find a README and the patch. As you can imagine, such modifications are not to be taken lightly. Do not try this on valueable systems (ie systems that you do not own - or cannot restore easily). You'll need to get the complete sourcecode of this guide as a tarball in order to get the patch and the README. Depending on your kernel version, you might even need to hand apply the patch. Still here? Well, so is this chapter. If Wyle E. Coyote was a kernel hacker, this would be the first thing he'd try. ;)
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  syscall.c</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  System call "stealing" sample.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Disables page protection at a processor level by</span>
<span style="color: #7f7f7f;"> *  changing the 16th bit in the cr0 register (could be Intel specific)</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Based on example by Peter Jay Salzman and</span>
<span style="color: #7f7f7f;"> *  https://bbs.archlinux.org/viewtopic.php?id=139406</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/fdtable.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/delay.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;asm/paravirt.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/moduleparam.h&gt;</span>  <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">which will have params</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/unistd.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The list of system calls</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * For the current (process) structure, we need</span>
<span style="color: #7f7f7f;"> * this to know who the current user is.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/sched.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>

<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> **<span style="color: #4eee94;">sys_call_table</span>;
<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">original_cr0</span>;

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * UID we want to spy on - will be filled from the</span>
<span style="color: #7f7f7f;"> * command line</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">uid</span>;
<span style="color: #daa520;">module_param</span>(uid, <span style="color: #98f5ff;">int</span>, 0644);

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * A pointer to the original system call. The reason</span>
<span style="color: #7f7f7f;"> * we keep this, rather than call the original function</span>
<span style="color: #7f7f7f;"> * (sys_open), is because somebody else might have</span>
<span style="color: #7f7f7f;"> * replaced the system call before us. Note that this</span>
<span style="color: #7f7f7f;"> * is not 100% safe, because if another module</span>
<span style="color: #7f7f7f;"> * replaced sys_open before us, then when we're inserted</span>
<span style="color: #7f7f7f;"> * we'll call the function in that module - and it</span>
<span style="color: #7f7f7f;"> * might be removed before we are.</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * Another reason for this is that we can't get sys_open.</span>
<span style="color: #7f7f7f;"> * It's a static variable, so it is not exported.</span>
<span style="color: #7f7f7f;"> */</span>
asmlinkage <span style="color: #98f5ff;">int</span> (*<span style="color: #daa520;">original_call</span>) (<span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">int</span>);

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The function we'll replace sys_open (the function</span>
<span style="color: #7f7f7f;"> * called when you call the open system call) with. To</span>
<span style="color: #7f7f7f;"> * find the exact prototype, with the number and type</span>
<span style="color: #7f7f7f;"> * of arguments, we find the original function first</span>
<span style="color: #7f7f7f;"> * (it's at fs/open.c).</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * In theory, this means that we're tied to the</span>
<span style="color: #7f7f7f;"> * current version of the kernel. In practice, the</span>
<span style="color: #7f7f7f;"> * system calls almost never change (it would wreck havoc</span>
<span style="color: #7f7f7f;"> * and require programs to be recompiled, since the system</span>
<span style="color: #7f7f7f;"> * calls are the interface between the kernel and the</span>
<span style="color: #7f7f7f;"> * processes).</span>
<span style="color: #7f7f7f;"> */</span>
asmlinkage <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">our_sys_open</span>(<span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">filename</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flags</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">ch</span>;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Report the file, if relevant</span>
<span style="color: #7f7f7f;">     */</span>
    pr_info(<span style="color: #deb887;">"Opened file by %d: "</span>, uid);
    <span style="color: #00bfff;">do</span> {
        get_user(ch, filename + i);
        i++;
        pr_info(<span style="color: #deb887;">"%c"</span>, ch);
    } <span style="color: #00bfff;">while</span> (ch != 0);
    pr_info(<span style="color: #deb887;">"\n"</span>);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Call the original sys_open - otherwise, we lose</span>
<span style="color: #7f7f7f;">     * the ability to open files</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> original_call(filename, flags, mode);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> **<span style="color: #daa520;">aquire_sys_call_table</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">offset</span> = PAGE_OFFSET;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> **<span style="color: #4eee94;">sct</span>;

    <span style="color: #00bfff;">while</span> (offset &lt; ULLONG_MAX) {
        sct = (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> **)offset;

        <span style="color: #00bfff;">if</span> (sct[__NR_close] == (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *) close_fd)
            <span style="color: #00bfff;">return</span> sct;

        offset += <span style="color: #00bfff;">sizeof</span>(<span style="color: #98f5ff;">void</span> *);
    }

    <span style="color: #00bfff;">return</span> <span style="color: #a2cd5a;">NULL</span>;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> syscall_start(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff;">if</span>(!(sys_call_table = aquire_sys_call_table()))
        <span style="color: #00bfff;">return</span> -1;

    original_cr0 = read_cr0();

    write_cr0(original_cr0 &amp; ~0x00010000);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">keep track of the original open function</span><span style="color: #7f7f7f;"> */</span>
    original_call = (<span style="color: #98f5ff;">void</span>*)sys_call_table[__NR_open];

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">use our open function instead</span><span style="color: #7f7f7f;"> */</span>
    sys_call_table[__NR_open] = (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *)our_sys_open;

    write_cr0(original_cr0);

    pr_info(<span style="color: #deb887;">"Spying on UID:%d\n"</span>, uid);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> syscall_end(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff;">if</span>(!sys_call_table) {
        <span style="color: #00bfff;">return</span>;
    }

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Return the system call back to normal</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (sys_call_table[__NR_open] != (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *)our_sys_open) {
        pr_alert(<span style="color: #deb887;">"Somebody else also played with the "</span>);
        pr_alert(<span style="color: #deb887;">"open system call\n"</span>);
        pr_alert(<span style="color: #deb887;">"The system may be left in "</span>);
        pr_alert(<span style="color: #deb887;">"an unstable state.\n"</span>);
    }

    write_cr0(original_cr0 &amp; ~0x00010000);
    sys_call_table[__NR_open] = (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *)original_call;
    write_cr0(original_cr0);

    msleep(2000);
}

<span style="color: #daa520;">module_init</span>(syscall_start);
<span style="color: #daa520;">module_exit</span>(syscall_end);

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgefed204" class="outline-2">
<h2 id="orgefed204"><span class="section-number-2">11.</span> Blocking Processes and threads</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgb37505f" class="outline-3">
<h3 id="orgb37505f"><span class="section-number-3">11.1.</span> Sleep</h3>
<div class="outline-text-3" id="text-11-1">
<p>
What do you do when somebody asks you for something you can't do right away? If you're a human being and you're bothered by a human being, the only thing you can say is: "<i>Not right now, I'm busy. Go away!</i>". But if you're a kernel module and you're bothered by a process, you have another possibility. You can put the process to sleep until you can service it. After all, processes are being put to sleep by the kernel and woken up all the time (that's the way multiple processes appear to run on the same time on a single CPU).
</p>

<p>
This kernel module is an example of this. The file (called <b>/proc/sleep</b>) can only be opened by a single process at a time. If the file is already open, the kernel module calls wait_event_interruptible. The easiest way to keep a file open is to open it with:
</p>

<div class="org-src-container">
<pre class="src src-bash">tail -f
</pre>
</div>

<p>
This function changes the status of the task (a task is the kernel data structure which holds information about a process and the system call it's in, if any) to <b>TASK_INTERRUPTIBLE</b>, which means that the task will not run until it is woken up somehow, and adds it to WaitQ, the queue of tasks waiting to access the file. Then, the function calls the scheduler to context switch to a different process, one which has some use for the CPU.
</p>

<p>
When a process is done with the file, it closes it, and module_close is called. That function wakes up all the processes in the queue (there's no mechanism to only wake up one of them). It then returns and the process which just closed the file can continue to run. In time, the scheduler decides that that process has had enough and gives control of the CPU to another process. Eventually, one of the processes which was in the queue will be given control of the CPU by the scheduler. It starts at the point right after the call to <b>module_interruptible_sleep_on</b>.
</p>

<p>
This means that the process is still in kernel mode - as far as the process is concerned, it issued the open system call and the system call hasn't returned yet. The process doesn't know somebody else used the CPU for most of the time between the moment it issued the call and the moment it returned.
</p>

<p>
It can then proceed to set a global variable to tell all the other processes that the file is still open and go on with its life. When the other processes get a piece of the CPU, they'll see that global variable and go back to sleep.
</p>

<p>
So we'll use tail -f to keep the file open in the background, while trying to access it with another process (again in the background, so that we need not switch to a different vt). As soon as the first background process is killed with kill %1 , the second is woken up, is able to access the file and finally terminates.
</p>

<p>
To make our life more interesting, <b>module_close</b> doesn't have a monopoly on waking up the processes which wait to access the file. A signal, such as <i>Ctrl +c</i> (<b>SIGINT</b>) can also wake up a process. This is because we used <b>module_interruptible_sleep_on</b>. We could have used <b>module_sleep_on</b> instead, but that would have resulted in extremely angry users whose <i>Ctrl+c</i>'s are ignored.
</p>

<p>
In that case, we want to return with <b>-EINTR</b> immediately. This is important so users can, for example, kill the process before it receives the file.
</p>

<p>
There is one more point to remember. Some times processes don't want to sleep, they want either to get what they want immediately, or to be told it cannot be done. Such processes use the <b>O_NONBLOCK</b> flag when opening the file. The kernel is supposed to respond by returning with the error code <b>-EAGAIN</b> from operations which would otherwise block, such as opening the file in this example. The program cat_noblock, available in the source directory for this chapter, can be used to open a file with <b>O_NONBLOCK</b>.
</p>

<div class="org-src-container">
<pre class="src src-sh">hostname:~/lkmpg-examples/09-BlockingProcesses# insmod sleep.ko
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses# tail -f /proc/sleep &amp;
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
tail: /proc/sleep: file truncated
[1] 6540
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Open would block
hostname:~/lkmpg-examples/09-BlockingProcesses# kill %1
[1]+  Terminated              tail -f /proc/sleep
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses#
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  sleep.c - create a /proc file, and if several processes try to open it at</span>
<span style="color: #7f7f7f;"> *  the same time, put all but one to sleep</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">We're doing kernel work</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Specifically, a module</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/proc_fs.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Necessary because we use proc fs</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/sched.h&gt;</span>        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For putting processes to sleep and</span>
<span style="color: #7f7f7f;">                                   waking them up</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/uaccess.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for get_user and put_user</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * The module's file functions</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Here we keep the last message received, to prove that we can process our</span>
<span style="color: #7f7f7f;"> * input</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">MESSAGE_LENGTH</span> 80
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">char</span> Message[MESSAGE_LENGTH];

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_dir_entry</span> *<span style="color: #4eee94;">Our_Proc_File</span>;
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PROC_ENTRY_FILENAME</span> <span style="color: #deb887;">"sleep"</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Since we use the file operations struct, we can't use the special proc</span>
<span style="color: #7f7f7f;"> * output provisions - we have to use a standard read function, which is this</span>
<span style="color: #7f7f7f;"> * function</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">module_output</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>, <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">see include/linux/fs.h</span><span style="color: #7f7f7f;">   */</span>
                             <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The buffer to put data to</span>
<span style="color: #7f7f7f;">                                           (in the user segment)</span><span style="color: #7f7f7f;">    */</span>
                             <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>,        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The length of the buffer</span><span style="color: #7f7f7f;"> */</span>
                             <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">finished</span> = 0;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">message</span>[MESSAGE_LENGTH + 30];

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Return 0 to signify end of file - that we have nothing</span>
<span style="color: #7f7f7f;">     * more to say at this point.</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (finished) {
        finished = 0;
        <span style="color: #00bfff;">return</span> 0;
    }

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If you don't understand this by now, you're hopeless as a kernel</span>
<span style="color: #7f7f7f;">     * programmer.</span>
<span style="color: #7f7f7f;">     */</span>
    sprintf(message, <span style="color: #deb887;">"Last input:%s\n"</span>, Message);
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; len &amp;&amp; message[i]; i++)
        put_user(message[i], buf + i);

    finished = 1;
    <span style="color: #00bfff;">return</span> i;               <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Return the number of bytes "read"</span><span style="color: #7f7f7f;"> */</span>
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * This function receives input from the user when the user writes to the /proc</span>
<span style="color: #7f7f7f;"> * file.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520;">module_input</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>,  <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The file itself</span><span style="color: #7f7f7f;"> */</span>
                            <span style="color: #00bfff;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>,    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The buffer with input</span><span style="color: #7f7f7f;"> */</span>
                            <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">length</span>,      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The buffer's length</span><span style="color: #7f7f7f;"> */</span>
                            <span style="color: #98f5ff;">loff_t</span> * <span style="color: #4eee94;">offset</span>)    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">offset to file - ignore</span><span style="color: #7f7f7f;"> */</span>
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Put the input into Message, where module_output will later be</span>
<span style="color: #7f7f7f;">     * able to use it</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; MESSAGE_LENGTH - 1 &amp;&amp; i &lt; length; i++)
        get_user(Message[i], buf + i);
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * we want a standard, zero terminated string</span>
<span style="color: #7f7f7f;">     */</span>
    Message[i] = <span style="color: #deb887;">'\0'</span>;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * We need to return the number of input characters used</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">return</span> i;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * 1 if the file is currently open by somebody</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">Already_Open</span> = 0;

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Queue of processes who want our file</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #daa520;">DECLARE_WAIT_QUEUE_HEAD</span>(WaitQ);
<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when the /proc file is opened</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">module_open</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If the file's flags include O_NONBLOCK, it means the process doesn't</span>
<span style="color: #7f7f7f;">     * want to wait for the file.  In this case, if the file is already</span>
<span style="color: #7f7f7f;">     * open, we should fail with -EAGAIN, meaning "you'll have to try</span>
<span style="color: #7f7f7f;">     * again", instead of blocking a process which would rather stay awake.</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; Already_Open)
        <span style="color: #00bfff;">return</span> -EAGAIN;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * This is the correct place for try_module_get(THIS_MODULE) because</span>
<span style="color: #7f7f7f;">     * if a process is in the loop, which is within the kernel module,</span>
<span style="color: #7f7f7f;">     * the kernel module must not be removed.</span>
<span style="color: #7f7f7f;">     */</span>
    try_module_get(THIS_MODULE);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If the file is already open, wait until it isn't</span>
<span style="color: #7f7f7f;">     */</span>

    <span style="color: #00bfff;">while</span> (Already_Open) {
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">is_sig</span> = 0;

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * This function puts the current process, including any system</span>
<span style="color: #7f7f7f;">         * calls, such as us, to sleep.  Execution will be resumed right</span>
<span style="color: #7f7f7f;">         * after the function call, either because somebody called</span>
<span style="color: #7f7f7f;">         * wake_up(&amp;WaitQ) (only module_close does that, when the file</span>
<span style="color: #7f7f7f;">         * is closed) or when a signal, such as Ctrl-C, is sent</span>
<span style="color: #7f7f7f;">         * to the process</span>
<span style="color: #7f7f7f;">         */</span>
        wait_event_interruptible(WaitQ, !Already_Open);

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * If we woke up because we got a signal we're not blocking,</span>
<span style="color: #7f7f7f;">         * return -EINTR (fail the system call).  This allows processes</span>
<span style="color: #7f7f7f;">         * to be killed or stopped.</span>
<span style="color: #7f7f7f;">         */</span>

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * Emmanuel Papirakis:</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * This is a little update to work with 2.2.*.  Signals now are contained in</span>
<span style="color: #7f7f7f;">         * two words (64 bits) and are stored in a structure that contains an array of</span>
<span style="color: #7f7f7f;">         * two unsigned longs.  We now have to make 2 checks in our if.</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * Ori Pomerantz:</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * Nobody promised me they'll never use more than 64 bits, or that this book</span>
<span style="color: #7f7f7f;">         * won't be used for a version of Linux with a word size of 16 bits.  This code</span>
<span style="color: #7f7f7f;">         * would work in any case.</span>
<span style="color: #7f7f7f;">         */</span>
        <span style="color: #00bfff;">for</span> (i = 0; i &lt; _NSIG_WORDS &amp;&amp; !is_sig; i++)
            is_sig =
                current-&gt;pending.signal.sig[i] &amp; ~current-&gt;
                blocked.sig[i];

        <span style="color: #00bfff;">if</span> (is_sig) {
            <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">             * It's important to put module_put(THIS_MODULE) here,</span>
<span style="color: #7f7f7f;">             * because for processes where the open is interrupted</span>
<span style="color: #7f7f7f;">             * there will never be a corresponding close. If we</span>
<span style="color: #7f7f7f;">             * don't decrement the usage count here, we will be</span>
<span style="color: #7f7f7f;">             * left with a positive usage count which we'll have no</span>
<span style="color: #7f7f7f;">             * way to bring down to zero, giving us an immortal</span>
<span style="color: #7f7f7f;">             * module, which can only be killed by rebooting</span>
<span style="color: #7f7f7f;">             * the machine.</span>
<span style="color: #7f7f7f;">             */</span>
            module_put(THIS_MODULE);
            <span style="color: #00bfff;">return</span> -EINTR;
        }
    }

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If we got here, Already_Open must be zero</span>
<span style="color: #7f7f7f;">     */</span>

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Open the file</span>
<span style="color: #7f7f7f;">     */</span>
    Already_Open = 1;
    <span style="color: #00bfff;">return</span> 0;               <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Allow the access</span><span style="color: #7f7f7f;"> */</span>
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Called when the /proc file is closed</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">module_close</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">inode</span> *<span style="color: #4eee94;">inode</span>, <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">file</span> *<span style="color: #4eee94;">file</span>)
{
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Set Already_Open to zero, so one of the processes in the WaitQ will</span>
<span style="color: #7f7f7f;">     * be able to set Already_Open back to one and to open the file. All</span>
<span style="color: #7f7f7f;">     * the other processes will be called when Already_Open is back to one,</span>
<span style="color: #7f7f7f;">     * so they'll go back to sleep.</span>
<span style="color: #7f7f7f;">     */</span>
    Already_Open = 0;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Wake up all the processes in WaitQ, so if anybody is waiting for the</span>
<span style="color: #7f7f7f;">     * file, they can have it.</span>
<span style="color: #7f7f7f;">     */</span>
    wake_up(&amp;WaitQ);

    module_put(THIS_MODULE);

    <span style="color: #00bfff;">return</span> 0;               <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">success</span><span style="color: #7f7f7f;"> */</span>
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Structures to register as the /proc file, with pointers to all the relevant</span>
<span style="color: #7f7f7f;"> * functions.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * File operations for our proc file. This is where we place pointers to all</span>
<span style="color: #7f7f7f;"> * the functions called when somebody tries to do something to our file. NULL</span>
<span style="color: #7f7f7f;"> * means we don't want to deal with something.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">proc_ops</span> <span style="color: #4eee94;">File_Ops_4_Our_Proc_File</span> = {
    .proc_read = module_output,  <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">"read" from the file</span><span style="color: #7f7f7f;"> */</span>
    .proc_write = module_input,  <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">"write" to the file</span><span style="color: #7f7f7f;"> */</span>
    .proc_open = module_open,    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">called when the /proc file is opened</span><span style="color: #7f7f7f;"> */</span>
    .proc_release = module_close,        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">called when it's closed</span><span style="color: #7f7f7f;"> */</span>
};

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Module initialization and cleanup</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Initialize the module - register the proc file</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    Our_Proc_File = proc_create(PROC_ENTRY_FILENAME, 0644, <span style="color: #a2cd5a;">NULL</span>, &amp;File_Ops_4_Our_Proc_File);
    <span style="color: #00bfff;">if</span>(Our_Proc_File == <span style="color: #a2cd5a;">NULL</span>)
    {
        remove_proc_entry(PROC_ENTRY_FILENAME, <span style="color: #a2cd5a;">NULL</span>);
        pr_debug(<span style="color: #deb887;">"Error: Could not initialize /proc/%s\n"</span>, PROC_ENTRY_FILENAME);
        <span style="color: #00bfff;">return</span> -ENOMEM;
    }
    proc_set_size(Our_Proc_File, 80);
    proc_set_user(Our_Proc_File,  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);

    pr_info(<span style="color: #deb887;">"/proc/test created\n"</span>);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Cleanup - unregister our file from /proc.  This could get dangerous if</span>
<span style="color: #7f7f7f;"> * there are still processes waiting in WaitQ, because they are inside our</span>
<span style="color: #7f7f7f;"> * open function, which will get unloaded. I'll explain how to avoid removal</span>
<span style="color: #7f7f7f;"> * of a kernel module in such a case in chapter 10.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    remove_proc_entry(PROC_ENTRY_FILENAME, <span style="color: #a2cd5a;">NULL</span>);
    pr_debug(<span style="color: #deb887;">"/proc/%s removed\n"</span>, PROC_ENTRY_FILENAME);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">cat_noblock.c - open a file and display its contents, but exit rather than</span>
<span style="color: #7f7f7f;"> * wait for input</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Copyright (C) 1998 by Ori Pomerantz</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">standard I/O</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for open</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for read</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for exit</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for errno</span><span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">MAX_BYTES</span> 1024*4


<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>    <span style="color: #4eee94;">fd</span>;  <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The file descriptor for the file to read</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">bytes</span>; <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The number of bytes read</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #98f5ff;">char</span>   <span style="color: #4eee94;">buffer</span>[MAX_BYTES]; <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The buffer for the bytes</span><span style="color: #7f7f7f;"> */</span>


    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Usage</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> (argc != 2) {
        printf(<span style="color: #deb887;">"Usage: %s &lt;filename&gt;\n"</span>, argv[0]);
        puts(<span style="color: #deb887;">"Reads the content of a file, but doesn't wait for input"</span>);
        exit(-1);
    }

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Open the file for reading in non blocking mode</span><span style="color: #7f7f7f;"> */</span>
    fd = open(argv[1], O_RDONLY | O_NONBLOCK);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">If open failed</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> (fd == -1) {
        <span style="color: #00bfff;">if</span> (errno = EAGAIN)
            puts(<span style="color: #deb887;">"Open would block"</span>);
        <span style="color: #00bfff;">else</span>
            puts(<span style="color: #deb887;">"Open failed"</span>);
        exit(-1);
    }

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Read the file and output its contents</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">do</span> {
        <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Read characters from the file</span><span style="color: #7f7f7f;"> */</span>
        bytes = read(fd, buffer, MAX_BYTES);

        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">If there's an error, report it and die</span><span style="color: #7f7f7f;"> */</span>
        <span style="color: #00bfff;">if</span> (bytes == -1) {
            <span style="color: #00bfff;">if</span> (errno = EAGAIN)
                puts(<span style="color: #deb887;">"Normally I'd block, but you told me not to"</span>);
            <span style="color: #00bfff;">else</span>
                puts(<span style="color: #deb887;">"Another read error"</span>);
            exit(-1);
        }

        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Print the characters</span><span style="color: #7f7f7f;"> */</span>
        <span style="color: #00bfff;">if</span> (bytes &gt; 0) {
            <span style="color: #00bfff;">for</span>(i=0; i&lt;bytes; i++)
                putchar(buffer[i]);
        }

        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">While there are no errors and the file isn't over</span><span style="color: #7f7f7f;"> */</span>
    } <span style="color: #00bfff;">while</span> (bytes &gt; 0);
    <span style="color: #00bfff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd6ca9a3" class="outline-3">
<h3 id="orgd6ca9a3"><span class="section-number-3">11.2.</span> Completions</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Sometimes one thing should happen before another within a module having multiple threads. Rather than using <b>/proc/sleep</b> commands the kernel has another way to do this which allows timeouts or interrupts to also happen.
</p>

<p>
In the following example two threads are started, but one needs to start before another.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kthread.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/completion.h&gt;</span>

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">completion</span> <span style="color: #4eee94;">crank_comp</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">completion</span> <span style="color: #4eee94;">flywheel_comp</span>;
} <span style="color: #4eee94;">machine</span>;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">machine_crank_thread</span>(<span style="color: #98f5ff;">void</span>* <span style="color: #4eee94;">arg</span>)
{
    pr_info(<span style="color: #deb887;">"Turn the crank\n"</span>);

    complete_all(&amp;machine.crank_comp);
    complete_and_exit(&amp;machine.crank_comp, 0);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">machine_flywheel_spinup_thread</span>(<span style="color: #98f5ff;">void</span>* <span style="color: #4eee94;">arg</span>)
{
    wait_for_completion(&amp;machine.crank_comp);

    pr_info(<span style="color: #deb887;">"Flywheel spins up\n"</span>);

    complete_all(&amp;machine.flywheel_comp);
    complete_and_exit(&amp;machine.flywheel_comp, 0);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">completions_init</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">task_struct</span>* <span style="color: #4eee94;">crank_thread</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">task_struct</span>* <span style="color: #4eee94;">flywheel_thread</span>;

    pr_info(<span style="color: #deb887;">"completions example\n"</span>);

    init_completion(&amp;machine.crank_comp);
    init_completion(&amp;machine.flywheel_comp);

    crank_thread =
        kthread_create(machine_crank_thread,
                       <span style="color: #a2cd5a;">NULL</span>, <span style="color: #deb887;">"KThread Crank"</span>);
    <span style="color: #00bfff;">if</span> (IS_ERR(crank_thread))
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">ERROR_THREAD_1</span>;

    flywheel_thread =
        kthread_create(machine_flywheel_spinup_thread,
                       <span style="color: #a2cd5a;">NULL</span>, <span style="color: #deb887;">"KThread Flywheel"</span>);
    <span style="color: #00bfff;">if</span> (IS_ERR(flywheel_thread))
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">ERROR_THREAD_2</span>;

    wake_up_process(flywheel_thread);
    wake_up_process(crank_thread);

    <span style="color: #00bfff;">return</span> 0;

<span style="color: #a2cd5a;">ERROR_THREAD_2</span>:
    kthread_stop(crank_thread);
<span style="color: #a2cd5a;">ERROR_THREAD_1</span>:

    <span style="color: #00bfff;">return</span> -1;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">completions_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    wait_for_completion(&amp;machine.crank_comp);
    wait_for_completion(&amp;machine.flywheel_comp);

    pr_info(<span style="color: #deb887;">"completions exit\n"</span>);
}

<span style="color: #daa520;">module_init</span>(completions_init);
<span style="color: #daa520;">module_exit</span>(completions_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Completions example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
The <i>machine</i> structure stores the completion states for the two threads. At the exit point of each thread the respective completion state is updated, and <i>wait_for_completion</i> is used by the flywheel thread to ensure that it doesn't begin prematurely.
</p>

<p>
So even though <i>flywheel_thread</i> is started first you should notice if you load this module and run <i>dmesg</i> that turning the crank always happens first because the flywheel thread waits for it to complete.
</p>

<p>
There are other variations upon the <i>wait_for_completion</i> function, which include timeouts or being interrupted, but this basic mechanism is enough for many common situations without adding a lot of complexity.
</p>
</div>
</div>
</div>

<div id="outline-container-org1780fc2" class="outline-2">
<h2 id="org1780fc2"><span class="section-number-2">12.</span> Avoiding Collisions and Deadlocks</h2>
<div class="outline-text-2" id="text-12">
<p>
If processes running on different CPUs or in different threads try to access the same memory then it's possible that strange things can happen or your system can lock up. To avoid this various types of mutual exclusion kernel functions are available. These indicate if a section of code is "locked" or "unlocked" so that simultaneous attempts to run it can't happen.
</p>
</div>
<div id="outline-container-org76df076" class="outline-3">
<h3 id="org76df076"><span class="section-number-3">12.1.</span> Mutex</h3>
<div class="outline-text-3" id="text-12-1">
<p>
You can use kernel mutexes (mutual exclusions) in much the same manner that you might deploy them in userland. This may be all that's needed to avoid collisions in most cases.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/mutex.h&gt;</span>

<span style="color: #daa520;">DEFINE_MUTEX</span>(mymutex);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">example_mutex_init</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span>;

    pr_info(<span style="color: #deb887;">"example_mutex init\n"</span>);

    ret = mutex_trylock(&amp;mymutex);
    <span style="color: #00bfff;">if</span> (ret != 0) {
        pr_info(<span style="color: #deb887;">"mutex is locked\n"</span>);

        <span style="color: #00bfff;">if</span> (mutex_is_locked(&amp;mymutex) == 0)
            pr_info(<span style="color: #deb887;">"The mutex failed to lock!\n"</span>);

        mutex_unlock(&amp;mymutex);
        pr_info(<span style="color: #deb887;">"mutex is unlocked\n"</span>);
    }
    <span style="color: #00bfff;">else</span>
        pr_info(<span style="color: #deb887;">"Failed to lock\n"</span>);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_mutex_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example_mutex exit\n"</span>);
}

<span style="color: #daa520;">module_init</span>(example_mutex_init);
<span style="color: #daa520;">module_exit</span>(example_mutex_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Mutex example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd021384" class="outline-3">
<h3 id="orgd021384"><span class="section-number-3">12.2.</span> Spinlocks</h3>
<div class="outline-text-3" id="text-12-2">
<p>
As the name suggests, spinlocks lock up the CPU that the code is running on, taking 100% of its resources. Because of this you should only use the spinlock mechanism around code which is likely to take no more than a few milliseconds to run and so won't noticably slow anything down from the user's point of view.
</p>

<p>
The example here is <i>"irq safe"</i> in that if interrupts happen during the lock then they won't be forgotten and will activate when the unlock happens, using the <i>flags</i> variable to retain their state.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/spinlock.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #daa520;">DEFINE_SPINLOCK</span>(sl_static);
<span style="color: #98f5ff;">spinlock_t</span> <span style="color: #4eee94;">sl_dynamic</span>;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_spinlock_static</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">flags</span>;

    spin_lock_irqsave(&amp;sl_static, flags);
    pr_info(<span style="color: #deb887;">"Locked static spinlock\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Do something or other safely.</span>
<span style="color: #7f7f7f;">       Because this uses 100% CPU time this</span>
<span style="color: #7f7f7f;">       code should take no more than a few</span>
<span style="color: #7f7f7f;">       milliseconds to run</span><span style="color: #7f7f7f;"> */</span>

    spin_unlock_irqrestore(&amp;sl_static, flags);
    pr_info(<span style="color: #deb887;">"Unlocked static spinlock\n"</span>);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_spinlock_dynamic</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">flags</span>;

    spin_lock_init(&amp;sl_dynamic);
    spin_lock_irqsave(&amp;sl_dynamic, flags);
    pr_info(<span style="color: #deb887;">"Locked dynamic spinlock\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Do something or other safely.</span>
<span style="color: #7f7f7f;">       Because this uses 100% CPU time this</span>
<span style="color: #7f7f7f;">       code should take no more than a few</span>
<span style="color: #7f7f7f;">       milliseconds to run</span><span style="color: #7f7f7f;"> */</span>

    spin_unlock_irqrestore(&amp;sl_dynamic, flags);
    pr_info(<span style="color: #deb887;">"Unlocked dynamic spinlock\n"</span>);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">example_spinlock_init</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example spinlock started\n"</span>);

    example_spinlock_static();
    example_spinlock_dynamic();

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_spinlock_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example spinlock exit\n"</span>);
}

<span style="color: #daa520;">module_init</span>(example_spinlock_init);
<span style="color: #daa520;">module_exit</span>(example_spinlock_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Spinlock example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d60a54" class="outline-3">
<h3 id="org6d60a54"><span class="section-number-3">12.3.</span> Read and write locks</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Read and write locks are specialised kinds of spinlocks so that you can exclusively read from something or write to something. Like the earlier spinlocks example the one below shows an "irq safe" situation in which if other functions were triggered from irqs which might also read and write to whatever you are concerned with then they wouldn't disrupt the logic. As before it's a good idea to keep anything done within the lock as short as possible so that it doesn't hang up the system and cause users to start revolting against the tyranny of your module.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #daa520;">DEFINE_RWLOCK</span>(myrwlock);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_read_lock</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">flags</span>;

    read_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span style="color: #deb887;">"Read Locked\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Read from something</span><span style="color: #7f7f7f;"> */</span>

    read_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span style="color: #deb887;">"Read Unlocked\n"</span>);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_write_lock</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">flags</span>;

    write_lock_irqsave(&amp;myrwlock, flags);
    pr_info(<span style="color: #deb887;">"Write Locked\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Write to something</span><span style="color: #7f7f7f;"> */</span>

    write_unlock_irqrestore(&amp;myrwlock, flags);
    pr_info(<span style="color: #deb887;">"Write Unlocked\n"</span>);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">example_rwlock_init</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example_rwlock started\n"</span>);

    example_read_lock();
    example_write_lock();

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_rwlock_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example_rwlock exit\n"</span>);
}

<span style="color: #daa520;">module_init</span>(example_rwlock_init);
<span style="color: #daa520;">module_exit</span>(example_rwlock_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Read/Write locks example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
Of course if you know for sure that there are no functions triggered by irqs which could possibly interfere with your logic then you can use the simpler  <i>read_lock(&amp;myrwlock)</i> and <i>read_unlock(&amp;myrwlock)</i> or the corresponding write functions.
</p>
</div>
</div>
<div id="outline-container-org959f412" class="outline-3">
<h3 id="org959f412"><span class="section-number-3">12.4.</span> Atomic operations</h3>
<div class="outline-text-3" id="text-12-4">
<p>
If you're doing simple arithmetic: adding, subtracting or bitwise operations then there's another way in the multi-CPU and multi-hyperthreaded world to stop other parts of the system from messing with your mojo. By using atomic operations you can be confident that your addition, subtraction or bit flip did actually happen and wasn't overwritten by some other shenanigans. An example is shown below.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">BYTE_TO_BINARY_PATTERN</span> <span style="color: #deb887;">"%c%c%c%c%c%c%c%c"</span>
<span style="color: #ffd700;">#define</span> <span style="color: #daa520;">BYTE_TO_BINARY</span>(<span style="color: #4eee94;">byte</span>)  \
  (byte &amp; 0x80 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x40 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x20 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x10 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x08 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x04 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x02 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>), \
  (byte &amp; 0x01 ? <span style="color: #deb887;">'1'</span> : <span style="color: #deb887;">'0'</span>)

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">atomic_add_subtract</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">atomic_t</span> <span style="color: #4eee94;">debbie</span>;
    <span style="color: #98f5ff;">atomic_t</span> <span style="color: #4eee94;">chris</span> = ATOMIC_INIT(50);

    atomic_set(&amp;debbie, 45);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">subtract one</span><span style="color: #7f7f7f;"> */</span>
    atomic_dec(&amp;debbie);

    atomic_add(7, &amp;debbie);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">add one</span><span style="color: #7f7f7f;"> */</span>
    atomic_inc(&amp;debbie);

    pr_info(<span style="color: #deb887;">"chris: %d, debbie: %d\n"</span>,
            atomic_read(&amp;chris), atomic_read(&amp;debbie));
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">atomic_bitwise</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">word</span> = 0;

    pr_info(<span style="color: #deb887;">"Bits 0: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    set_bit(3, &amp;word);
    set_bit(5, &amp;word);
    pr_info(<span style="color: #deb887;">"Bits 1: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    clear_bit(5, &amp;word);
    pr_info(<span style="color: #deb887;">"Bits 2: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    change_bit(3, &amp;word);

    pr_info(<span style="color: #deb887;">"Bits 3: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
    <span style="color: #00bfff;">if</span> (test_and_set_bit(3, &amp;word))
        pr_info(<span style="color: #deb887;">"wrong\n"</span>);
    pr_info(<span style="color: #deb887;">"Bits 4: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));

    word = 255;
    pr_info(<span style="color: #deb887;">"Bits 5: "</span>BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">example_atomic_init</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example_atomic started\n"</span>);

    atomic_add_subtract();
    atomic_bitwise();

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_atomic_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"example_atomic exit\n"</span>);
}

<span style="color: #daa520;">module_init</span>(example_atomic_init);
<span style="color: #daa520;">module_exit</span>(example_atomic_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Atomic operations example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org34a817f" class="outline-2">
<h2 id="org34a817f"><span class="section-number-2">13.</span> Replacing Print Macros</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-org93a432e" class="outline-3">
<h3 id="org93a432e"><span class="section-number-3">13.1.</span> Replacement</h3>
<div class="outline-text-3" id="text-13-1">
<p>
In Section 1.2.1.2, I said that X and kernel module programming don't mix. That's true for developing kernel modules, but in actual use, you want to be able to send messages to whichever tty the command to load the module came from.
</p>

<p>
"tty" is an abbreviation of <i>teletype</i>: originally a combination keyboard-printer used to communicate with a Unix system, and today an abstraction for the text stream used for a Unix program, whether it's a physical terminal, an xterm on an X display, a network connection used with ssh, etc.
</p>

<p>
The way this is done is by using current, a pointer to the currently running task, to get the current task's tty structure. Then, we look inside that tty structure to find a pointer to a string write function, which we use to write a string to the tty.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  print_string.c - Send output to the tty we're running on, regardless if it's</span>
<span style="color: #7f7f7f;"> *  through X11, telnet, etc.  We do this by printing the string to the tty</span>
<span style="color: #7f7f7f;"> *  associated with the current task.</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/sched.h&gt;</span>        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For current</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/tty.h&gt;</span>          <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For the tty declarations</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/version.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For LINUX_VERSION_CODE</span><span style="color: #7f7f7f;"> */</span>

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Peter Jay Salzman"</span>);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">print_string</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>)
{
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tty_struct</span> *<span style="color: #4eee94;">my_tty</span>;
    <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tty_operations</span> *<span style="color: #4eee94;">ttyops</span>;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * tty struct went into signal struct in 2.6.6</span>
<span style="color: #7f7f7f;">     */</span>
<span style="color: #ffd700;">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,5) )
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * The tty for the current task</span>
<span style="color: #7f7f7f;">     */</span>
    my_tty = current-&gt;tty;
<span style="color: #ffd700;">#else</span>
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * The tty for the current task, for 2.6.6+ kernels</span>
<span style="color: #7f7f7f;">     */</span>
    my_tty = get_current_tty();
<span style="color: #ffd700;">#endif</span>
    ttyops = my_tty-&gt;driver-&gt;ops;

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * If my_tty is NULL, the current task has no tty you can print to</span>
<span style="color: #7f7f7f;">     * (ie, if it's a daemon).  If so, there's nothing we can do.</span>
<span style="color: #7f7f7f;">     */</span>
    <span style="color: #00bfff;">if</span> (my_tty != <span style="color: #a2cd5a;">NULL</span>) {

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * my_tty-&gt;driver is a struct which holds the tty's functions,</span>
<span style="color: #7f7f7f;">         * one of which (write) is used to write strings to the tty.</span>
<span style="color: #7f7f7f;">         * It can be used to take a string either from the user's or</span>
<span style="color: #7f7f7f;">         * kernel's memory segment.</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * The function's 1st parameter is the tty to write to,</span>
<span style="color: #7f7f7f;">         * because the same function would normally be used for all</span>
<span style="color: #7f7f7f;">         * tty's of a certain type.  The 2nd parameter controls</span>
<span style="color: #7f7f7f;">         * whether the function receives a string from kernel</span>
<span style="color: #7f7f7f;">         * memory (false, 0) or from user memory (true, non zero).</span>
<span style="color: #7f7f7f;">         * BTW: this param has been removed in Kernels &gt; 2.6.9</span>
<span style="color: #7f7f7f;">         * The (2nd) 3rd parameter is a pointer to a string.</span>
<span style="color: #7f7f7f;">         * The (3rd) 4th parameter is the length of the string.</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * As you will see below, sometimes it's necessary to use</span>
<span style="color: #7f7f7f;">         * preprocessor stuff to create code that works for different</span>
<span style="color: #7f7f7f;">         * kernel versions. The (naive) approach we've taken here</span>
<span style="color: #7f7f7f;">         * does not scale well. The right way to deal with this</span>
<span style="color: #7f7f7f;">         * is described in section 2 of</span>
<span style="color: #7f7f7f;">         * linux/Documentation/SubmittingPatches</span>
<span style="color: #7f7f7f;">         */</span>
        (ttyops-&gt;write) (my_tty,      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The tty itself</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
                         0,   <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Don't take the string</span>
<span style="color: #7f7f7f;">                                 from user space</span><span style="color: #7f7f7f;">        */</span>
<span style="color: #ffd700;">#endif</span>
                         str, <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">String</span><span style="color: #7f7f7f;">                 */</span>
                         strlen(str));        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Length</span><span style="color: #7f7f7f;"> */</span>

        <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">         * ttys were originally hardware devices, which (usually)</span>
<span style="color: #7f7f7f;">         * strictly followed the ASCII standard.  In ASCII, to move to</span>
<span style="color: #7f7f7f;">         * a new line you need two characters, a carriage return and a</span>
<span style="color: #7f7f7f;">         * line feed.  On Unix, the ASCII line feed is used for both</span>
<span style="color: #7f7f7f;">         * purposes - so we can't just use \n, because it wouldn't have</span>
<span style="color: #7f7f7f;">         * a carriage return and the next line will start at the</span>
<span style="color: #7f7f7f;">         * column right after the line feed.</span>
<span style="color: #7f7f7f;">         *</span>
<span style="color: #7f7f7f;">         * This is why text files are different between Unix and</span>
<span style="color: #7f7f7f;">         * MS Windows.  In CP/M and derivatives, like MS-DOS and</span>
<span style="color: #7f7f7f;">         * MS Windows, the ASCII standard was strictly adhered to,</span>
<span style="color: #7f7f7f;">         * and therefore a newline requirs both a LF and a CR.</span>
<span style="color: #7f7f7f;">         */</span>

<span style="color: #ffd700;">#if</span> ( LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,9) )
        (ttyops-&gt;write) (my_tty, 0, <span style="color: #deb887;">"\015\012"</span>, 2);
<span style="color: #ffd700;">#else</span>
        (ttyops-&gt;write) (my_tty, <span style="color: #deb887;">"\015\012"</span>, 2);
<span style="color: #ffd700;">#endif</span>
    }
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> print_string_init(<span style="color: #98f5ff;">void</span>)
{
    print_string(<span style="color: #deb887;">"The module has been inserted.  Hello world!"</span>);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> print_string_exit(<span style="color: #98f5ff;">void</span>)
{
    print_string(<span style="color: #deb887;">"The module has been removed.  Farewell world!"</span>);
}

<span style="color: #daa520;">module_init</span>(print_string_init);
<span style="color: #daa520;">module_exit</span>(print_string_exit);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2fc24ec" class="outline-3">
<h3 id="org2fc24ec"><span class="section-number-3">13.2.</span> Flashing keyboard LEDs</h3>
<div class="outline-text-3" id="text-13-2">
<p>
In certain conditions, you may desire a simpler and more direct way to communicate to the external world. Flashing keyboard LEDs can be such a solution: It is an immediate way to attract attention or to display a status condition. Keyboard LEDs are present on every hardware, they are always visible, they do not need any setup, and their use is rather simple and non-intrusive, compared to writing to a tty or a file.
</p>

<p>
The following source code illustrates a minimal kernel module which, when loaded, starts blinking the keyboard LEDs until it is unloaded.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  kbleds.c - Blink keyboard leds until the module is unloaded.</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/vt_kern.h&gt;</span>      <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">for fg_console</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/tty.h&gt;</span>          <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For fg_console, MAX_NR_CONSOLES</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kd.h&gt;</span>           <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For KDSETLED</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/vt.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/console_struct.h&gt;</span>       <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">For vc_cons</span><span style="color: #7f7f7f;"> */</span>

MODULE_DESCRIPTION(<span style="color: #deb887;">"Example module illustrating the use of Keyboard LEDs."</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Daniele Paolo Scarpazza"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">timer_list</span> <span style="color: #4eee94;">my_timer</span>;
<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tty_driver</span> *<span style="color: #4eee94;">my_driver</span>;
<span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">kbledstatus</span> = 0;

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">BLINK_DELAY</span>   HZ/5
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">ALL_LEDS_ON</span>   0x07
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">RESTORE_LEDS</span>  0xFF

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * Function my_timer_func blinks the keyboard LEDs periodically by invoking</span>
<span style="color: #7f7f7f;"> * command KDSETLED of ioctl() on the keyboard driver. To learn more on virtual</span>
<span style="color: #7f7f7f;"> * terminal ioctl operations, please see file:</span>
<span style="color: #7f7f7f;"> *     /usr/src/linux/drivers/char/vt_ioctl.c, function vt_ioctl().</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> * The argument to KDSETLED is alternatively set to 7 (thus causing the led</span>
<span style="color: #7f7f7f;"> * mode to be set to LED_SHOW_IOCTL, and all the leds are lit) and to 0xFF</span>
<span style="color: #7f7f7f;"> * (any value above 7 switches back the led mode to LED_SHOW_FLAGS, thus</span>
<span style="color: #7f7f7f;"> * the LEDs reflect the actual keyboard status).  To learn more on this,</span>
<span style="color: #7f7f7f;"> * please see file:</span>
<span style="color: #7f7f7f;"> *     /usr/src/linux/drivers/char/keyboard.c, function setledstate().</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">my_timer_func</span>(<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">ptr</span>)
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *<span style="color: #4eee94;">pstatus</span> = (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> *)ptr;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tty_struct</span>* <span style="color: #4eee94;">t</span> = vc_cons[fg_console].d-&gt;port.tty;

    <span style="color: #00bfff;">if</span> (*pstatus == ALL_LEDS_ON)
        *pstatus = RESTORE_LEDS;
    <span style="color: #00bfff;">else</span>
        *pstatus = ALL_LEDS_ON;

    (my_driver-&gt;ops-&gt;ioctl) (t, KDSETLED, *pstatus);

    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">__init</span> kbleds_init(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

    pr_info(<span style="color: #deb887;">"kbleds: loading\n"</span>);
    pr_info(<span style="color: #deb887;">"kbleds: fgconsole is %x\n"</span>, fg_console);
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; MAX_NR_CONSOLES; i++) {
        <span style="color: #00bfff;">if</span> (!vc_cons[i].d)
            <span style="color: #00bfff;">break</span>;
        pr_info(<span style="color: #deb887;">"poet_atkm: console[%i/%i] #%i, tty %lx\n"</span>, i,
                MAX_NR_CONSOLES, vc_cons[i].d-&gt;vc_num,
                (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)vc_cons[i].d-&gt;port.tty);
    }
    pr_info(<span style="color: #deb887;">"kbleds: finished scanning consoles\n"</span>);

    my_driver = vc_cons[fg_console].d-&gt;port.tty-&gt;driver;
    pr_info(<span style="color: #deb887;">"kbleds: tty driver magic %x\n"</span>, my_driver-&gt;magic);

    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">     * Set up the LED blink timer the first time</span>
<span style="color: #7f7f7f;">     */</span>
    timer_setup(&amp;my_timer, (<span style="color: #98f5ff;">void</span>*)&amp;my_timer_func, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;kbledstatus);
    my_timer.expires = jiffies + BLINK_DELAY;
    add_timer(&amp;my_timer);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">__exit</span> kbleds_cleanup(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"kbleds: unloading...\n"</span>);
    del_timer(&amp;my_timer);
    (my_driver-&gt;ops-&gt;ioctl) (vc_cons[fg_console].d-&gt;port.tty,
                             KDSETLED, RESTORE_LEDS);
}

<span style="color: #daa520;">module_init</span>(kbleds_init);
<span style="color: #daa520;">module_exit</span>(kbleds_cleanup);
</pre>
</div>

<p>
If none of the examples in this chapter fit your debugging needs there might yet be some other tricks to try. Ever wondered what CONFIG_LL_DEBUG in make menuconfig is good for? If you activate that you get low level access to the serial port. While this might not sound very powerful by itself, you can patch <b>kernel/printk.c</b> or any other essential syscall to use printascii, thus makeing it possible to trace virtually everything what your code does over a serial line. If you find yourself porting the kernel to some new and former unsupported architecture this is usually amongst the first things that should be implemented. Logging over a netconsole might also be worth a try.
</p>

<p>
While you have seen lots of stuff that can be used to aid debugging here, there are some things to be aware of. Debugging is almost always intrusive. Adding debug code can change the situation enough to make the bug seem to dissappear. Thus you should try to keep debug code to a minimum and make sure it does not show up in production code.
</p>
</div>
</div>
</div>

<div id="outline-container-org3c9597e" class="outline-2">
<h2 id="org3c9597e"><span class="section-number-2">14.</span> Scheduling Tasks</h2>
<div class="outline-text-2" id="text-14">
<p>
There are two main ways of running tasks: tasklets and work queues. Tasklets are a quick and easy way of scheduling a single function to be run, for example when triggered from an interrupt, whereas work queues are more complicated but also better suited to running multiple things in a sequence.
</p>
</div>

<div id="outline-container-org6916b9c" class="outline-3">
<h3 id="org6916b9c"><span class="section-number-3">14.1.</span> Tasklets</h3>
<div class="outline-text-3" id="text-14-1">
<p>
Here's an example tasklet module. The <i>tasklet_fn</i> function runs for a few seconds and in the mean time execution of the <i>example_tasklet_init</i> function continues to the exit point.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/delay.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">tasklet_fn</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tasklet_struct</span> *<span style="color: #4eee94;">data</span>)
{
    pr_info(<span style="color: #deb887;">"Example tasklet starts\n"</span>);
    mdelay(5000);
    pr_info(<span style="color: #deb887;">"Example tasklet ends\n"</span>);
}

<span style="color: #daa520;">DECLARE_TASKLET</span>(mytask, tasklet_fn);

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">example_tasklet_init</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"tasklet example init\n"</span>);
    tasklet_schedule(&amp;mytask);
    mdelay(200);
    pr_info(<span style="color: #deb887;">"Example tasklet init continues...\n"</span>);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">example_tasklet_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"tasklet example exit\n"</span>);
    tasklet_kill(&amp;mytask);
}

<span style="color: #daa520;">module_init</span>(example_tasklet_init);
<span style="color: #daa520;">module_exit</span>(example_tasklet_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Tasklet example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
So with this example loaded <i>dmesg</i> should show:
</p>

<div class="org-src-container">
<pre class="src src-bash">tasklet example init
Example tasklet starts
Example tasklet init continues...
Example tasklet ends
</pre>
</div>
</div>
</div>
<div id="outline-container-org30b6234" class="outline-3">
<h3 id="org30b6234"><span class="section-number-3">14.2.</span> Work queues</h3>
<div class="outline-text-3" id="text-14-2">
<p>
To add a task to the scheduler we can use a workqueue. The kernel then uses the Completely Fair Scheduler (CFS) to execute work within the queue.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/init.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/workqueue.h&gt;</span>

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">workqueue_struct</span> *<span style="color: #4eee94;">queue</span>=<span style="color: #a2cd5a;">NULL</span>;
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">work_struct</span> <span style="color: #4eee94;">work</span>;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">work_handler</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">work_struct</span> *<span style="color: #4eee94;">data</span>)
{
    pr_info (<span style="color: #deb887;">"work handler function.\n"</span>);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    queue = alloc_workqueue(<span style="color: #deb887;">"HELLOWORLD"</span>, WQ_UNBOUND, 1);
    INIT_WORK(&amp;work, work_handler);
    schedule_work(&amp;work);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    destroy_workqueue(queue);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Workqueue example"</span>);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5e35776" class="outline-2">
<h2 id="org5e35776"><span class="section-number-2">15.</span> Interrupt Handlers</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-org38e4218" class="outline-3">
<h3 id="org38e4218"><span class="section-number-3">15.1.</span> Interrupt Handlers</h3>
<div class="outline-text-3" id="text-15-1">
<p>
Except for the last chapter, everything we did in the kernel so far we've done as a response to a process asking for it, either by dealing with a special file, sending an ioctl(), or issuing a system call. But the job of the kernel isn't just to respond to process requests. Another job, which is every bit as important, is to speak to the hardware connected to the machine.
</p>

<p>
There are two types of interaction between the CPU and the rest of the computer's hardware. The first type is when the CPU gives orders to the hardware, the other is when the hardware needs to tell the CPU something. The second, called interrupts, is much harder to implement because it has to be dealt with when convenient for the hardware, not the CPU. Hardware devices typically have a very small amount of RAM, and if you don't read their information when available, it is lost.
</p>

<p>
Under Linux, hardware interrupts are called IRQ's (Interrupt ReQuests). There are two types of IRQ's, short and long. A short IRQ is one which is expected to take a very short period of time, during which the rest of the machine will be blocked and no other interrupts will be handled. A long IRQ is one which can take longer, and during which other interrupts may occur (but not interrupts from the same device). If at all possible, it's better to declare an interrupt handler to be long.
</p>

<p>
When the CPU receives an interrupt, it stops whatever it's doing (unless it's processing a more important interrupt, in which case it will deal with this one only when the more important one is done), saves certain parameters on the stack and calls the interrupt handler. This means that certain things are not allowed in the interrupt handler itself, because the system is in an unknown state. The solution to this problem is for the interrupt handler to do what needs to be done immediately, usually read something from the hardware or send something to the hardware, and then schedule the handling of the new information at a later time (this is called the "bottom half") and return. The kernel is then guaranteed to call the bottom half as soon as possible &#x2013; and when it does, everything allowed in kernel modules will be allowed.
</p>

<p>
The way to implement this is to call <b>request_irq()</b> to get your interrupt handler called when the relevant IRQ is received.
</p>

<p>
In practice IRQ handling can be a bit more complex. Hardware is often designed in a way that chains two interrupt controllers, so that all the IRQs from interrupt controller B are cascaded to a certain IRQ from interrupt controller A. Of course that requires that the kernel finds out which IRQ it really was afterwards and that adds overhead. Other architectures offer some special, very low overhead, so called "fast IRQ" or FIQs. To take advantage of them requires handlers to be written in assembler, so they do not really fit into the kernel. They can be made to work similar to the others, but after that procedure, they're no longer any faster than "common" IRQs. SMP enabled kernels running on systems with more than one processor need to solve another truckload of problems. It's not enough to know if a certain IRQs has happend, it's also important for what CPU(s) it was for. People still interested in more details, might want to do a web search for "APIC" now ;)
</p>

<p>
This function receives the IRQ number, the name of the function, flags, a name for /proc/interrupts and a parameter to pass to the interrupt handler. Usually there is a certain number of IRQs available. How many IRQs there are is hardware-dependent. The flags can include SA_SHIRQ to indicate you're willing to share the IRQ with other interrupt handlers (usually because a number of hardware devices sit on the same IRQ) and SA_INTERRUPT to indicate this is a fast interrupt. This function will only succeed if there isn't already a handler on this IRQ, or if you're both willing to share.
</p>
</div>
</div>

<div id="outline-container-org88b20a4" class="outline-3">
<h3 id="org88b20a4"><span class="section-number-3">15.2.</span> Detecting button presses</h3>
<div class="outline-text-3" id="text-15-2">
<p>
Many popular single board computers, such as Raspberry Pis or Beagleboards, have a bunch of GPIO pins. Attaching buttons to those and then having a button press do something is a classic case in which you might need to use interrupts so that instead of having the CPU waste time and battery power polling for a change in input state it's better for the input to trigger the CPU to then run a particular handling function.
</p>

<p>
Here's an example where buttons are connected to GPIO numbers 17 and 18 and an LED is connected to GPIO 4. You can change those numbers to whatever is appropriate for your board.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> *  intrpt.c - Handling GPIO with interrupts</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Copyright (C) 2017 by Bob Mottram</span>
<span style="color: #7f7f7f;"> *  Based upon the Rpi example by Stefan Wendler (devnull@kaltpost.de)</span>
<span style="color: #7f7f7f;"> *  from:</span>
<span style="color: #7f7f7f;"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Press one button to turn on a LED and another to turn it off</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/gpio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">button_irqs</span>[] = { -1, -1 };

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Define GPIOs for LEDs.</span>
<span style="color: #7f7f7f;">   Change the numbers for the GPIO on your board.</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">gpio</span> <span style="color: #4eee94;">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span style="color: #deb887;">"LED 1"</span> }
};

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Define GPIOs for BUTTONS</span>
<span style="color: #7f7f7f;">   Change the numbers for the GPIO on your board.</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">gpio</span> <span style="color: #4eee94;">buttons</span>[] = {
        { 17, GPIOF_IN, <span style="color: #deb887;">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span style="color: #deb887;">"LED 1 OFF BUTTON"</span> }
};

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * interrupt function triggered when a button is pressed</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">irqreturn_t</span> <span style="color: #daa520;">button_isr</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">irq</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">data</span>)
{
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">first button</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> (irq == button_irqs[0] &amp;&amp; !gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">second button</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">else</span> <span style="color: #00bfff;">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span style="color: #00bfff;">return</span> IRQ_HANDLED;
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span> = 0;

    pr_info(<span style="color: #deb887;">"%s\n"</span>, __func__);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">register LED gpios</span><span style="color: #7f7f7f;"> */</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span style="color: #00bfff;">return</span> ret;
    }

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">register BUTTON gpios</span><span style="color: #7f7f7f;"> */</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail1</span>;
    }

    pr_info(<span style="color: #deb887;">"Current button1 value: %d\n"</span>,
            gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span style="color: #00bfff;">if</span> (ret &lt; 0) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span style="color: #deb887;">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
            button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span style="color: #deb887;">"gpiomod#button1"</span>, <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span style="color: #00bfff;">if</span> (ret &lt; 0) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span style="color: #deb887;">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
            button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span style="color: #deb887;">"gpiomod#button2"</span>, <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail3</span>;
    }

    <span style="color: #00bfff;">return</span> 0;

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">cleanup what has been setup so far</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #a2cd5a;">fail3</span>:
    free_irq(button_irqs[0], <span style="color: #a2cd5a;">NULL</span>);

<span style="color: #a2cd5a;">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span style="color: #a2cd5a;">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span style="color: #00bfff;">return</span> ret;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

    pr_info(<span style="color: #deb887;">"%s\n"</span>, __func__);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">free irqs</span><span style="color: #7f7f7f;"> */</span>
    free_irq(button_irqs[0], <span style="color: #a2cd5a;">NULL</span>);
    free_irq(button_irqs[1], <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">turn all LEDs off</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">unregister</span><span style="color: #7f7f7f;"> */</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Handle some GPIO interrupts"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b2314f" class="outline-3">
<h3 id="org7b2314f"><span class="section-number-3">15.3.</span> Bottom Half</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Suppose you want to do a bunch of stuff inside of an interrupt routine. A common way to do that without rendering the interrupt unavailable for a significant duration is to combine it with a tasklet. This pushes the bulk of the work off into the scheduler.
</p>

<p>
The example below modifies the previous example to also run an additional task when an interrupt is triggered.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * bottomhalf.c - Top and bottom half interrupt handling</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Copyright (C) 2017 by Bob Mottram</span>
<span style="color: #7f7f7f;"> *  Based upon the Rpi example by Stefan Wendler (devnull@kaltpost.de)</span>
<span style="color: #7f7f7f;"> *  from:</span>
<span style="color: #7f7f7f;"> *    https://github.com/wendlers/rpi-kmod-samples</span>
<span style="color: #7f7f7f;"> *</span>
<span style="color: #7f7f7f;"> *  Press one button to turn on a LED and another to turn it off</span>
<span style="color: #7f7f7f;"> */</span>

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/gpio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/delay.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">button_irqs</span>[] = { -1, -1 };

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Define GPIOs for LEDs.</span>
<span style="color: #7f7f7f;">   Change the numbers for the GPIO on your board.</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">gpio</span> <span style="color: #4eee94;">leds</span>[] = {
        {  4, GPIOF_OUT_INIT_LOW, <span style="color: #deb887;">"LED 1"</span> }
};

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Define GPIOs for BUTTONS</span>
<span style="color: #7f7f7f;">   Change the numbers for the GPIO on your board.</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">gpio</span> <span style="color: #4eee94;">buttons</span>[] = {
        { 17, GPIOF_IN, <span style="color: #deb887;">"LED 1 ON BUTTON"</span> },
        { 18, GPIOF_IN, <span style="color: #deb887;">"LED 1 OFF BUTTON"</span> }
};

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Tasklet containing some non-trivial amount of processing</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">bottomhalf_tasklet_fn</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tasklet_struct</span> *<span style="color: #4eee94;">data</span>)
{
    pr_info(<span style="color: #deb887;">"Bottom half tasklet starts\n"</span>);
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">do something which takes a while</span><span style="color: #7f7f7f;"> */</span>
    mdelay(500);
    pr_info(<span style="color: #deb887;">"Bottom half tasklet ends\n"</span>);
}

<span style="color: #daa520;">DECLARE_TASKLET</span>(buttontask, bottomhalf_tasklet_fn);

<span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;"> * interrupt function triggered when a button is pressed</span>
<span style="color: #7f7f7f;"> */</span>
<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">irqreturn_t</span> <span style="color: #daa520;">button_isr</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">irq</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">data</span>)
{
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Do something quickly right now</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> (irq == button_irqs[0] &amp;&amp; !gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 1);
    <span style="color: #00bfff;">else</span> <span style="color: #00bfff;">if</span>(irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))
            gpio_set_value(leds[0].gpio, 0);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Do the rest at leisure via the scheduler</span><span style="color: #7f7f7f;"> */</span>
    tasklet_schedule(&amp;buttontask);

    <span style="color: #00bfff;">return</span> IRQ_HANDLED;
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">init_module</span>()
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span> = 0;

    pr_info(<span style="color: #deb887;">"%s\n"</span>, __func__);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">register LED gpios</span><span style="color: #7f7f7f;"> */</span>
    ret = gpio_request_array(leds, ARRAY_SIZE(leds));

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request GPIOs for LEDs: %d\n"</span>, ret);
        <span style="color: #00bfff;">return</span> ret;
    }

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">register BUTTON gpios</span><span style="color: #7f7f7f;"> */</span>
    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request GPIOs for BUTTONs: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail1</span>;
    }

    pr_info(<span style="color: #deb887;">"Current button1 value: %d\n"</span>,
           gpio_get_value(buttons[0].gpio));

    ret = gpio_to_irq(buttons[0].gpio);

    <span style="color: #00bfff;">if</span> (ret &lt; 0) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }

    button_irqs[0] = ret;

    pr_info(<span style="color: #deb887;">"Successfully requested BUTTON1 IRQ # %d\n"</span>,
           button_irqs[0]);

    ret = request_irq(button_irqs[0], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span style="color: #deb887;">"gpiomod#button1"</span>, <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }


    ret = gpio_to_irq(buttons[1].gpio);

    <span style="color: #00bfff;">if</span> (ret &lt; 0) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail2</span>;
    }

    button_irqs[1] = ret;

    pr_info(<span style="color: #deb887;">"Successfully requested BUTTON2 IRQ # %d\n"</span>,
           button_irqs[1]);

    ret = request_irq(button_irqs[1], button_isr,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      <span style="color: #deb887;">"gpiomod#button2"</span>, <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to request IRQ: %d\n"</span>, ret);
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">fail3</span>;
    }

    <span style="color: #00bfff;">return</span> 0;

<span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">cleanup what has been setup so far</span><span style="color: #7f7f7f;"> */</span>
<span style="color: #a2cd5a;">fail3</span>:
    free_irq(button_irqs[0], <span style="color: #a2cd5a;">NULL</span>);

<span style="color: #a2cd5a;">fail2</span>:
    gpio_free_array(buttons, ARRAY_SIZE(leds));

<span style="color: #a2cd5a;">fail1</span>:
    gpio_free_array(leds, ARRAY_SIZE(leds));

    <span style="color: #00bfff;">return</span> ret;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cleanup_module</span>()
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;

    pr_info(<span style="color: #deb887;">"%s\n"</span>, __func__);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">free irqs</span><span style="color: #7f7f7f;"> */</span>
    free_irq(button_irqs[0], <span style="color: #a2cd5a;">NULL</span>);
    free_irq(button_irqs[1], <span style="color: #a2cd5a;">NULL</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">turn all LEDs off</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)
        gpio_set_value(leds[i].gpio, 0);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">unregister</span><span style="color: #7f7f7f;"> */</span>
    gpio_free_array(leds, ARRAY_SIZE(leds));
    gpio_free_array(buttons, ARRAY_SIZE(buttons));
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Interrupt with top and bottom half"</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge40a462" class="outline-2">
<h2 id="orge40a462"><span class="section-number-2">16.</span> Crypto</h2>
<div class="outline-text-2" id="text-16">
<p>
At the dawn of the internet everybody trusted everybody completely&#x2026;but that didn't work out so well. When this guide was originally written it was a more innocent era in which almost nobody actually gave a damn about crypto - least of all kernel developers. That's certainly no longer the case now. To handle crypto stuff the kernel has its own API enabling common methods of encryption, decryption and your favourite hash functions.
</p>
</div>

<div id="outline-container-orgb197228" class="outline-3">
<h3 id="orgb197228"><span class="section-number-3">16.1.</span> Hash functions</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Calculating and checking the hashes of things is a common operation. Here is a demonstration of how to calculate a sha256 hash within a kernel module.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;crypto/internal/hash.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SHA256_LENGTH</span> 32

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">show_hash_result</span>(<span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">plaintext</span>, <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">hash_sha256</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">str</span>[SHA256_LENGTH*2 + 1];

    pr_info(<span style="color: #deb887;">"sha256 test for string: \"%s\"\n"</span>, plaintext);
    <span style="color: #00bfff;">for</span> (i = 0; i &lt; SHA256_LENGTH ; i++)
        sprintf(&amp;str[i*2],<span style="color: #deb887;">"%02x"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">char</span>)hash_sha256[i]);
    str[i*2] = 0;
    pr_info(<span style="color: #deb887;">"%s\n"</span>, str);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">cryptosha256_init</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">plaintext</span> = <span style="color: #deb887;">"This is a test"</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">hash_sha256</span>[SHA256_LENGTH];
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">crypto_shash</span> *<span style="color: #4eee94;">sha256</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">shash_desc</span> *<span style="color: #4eee94;">shash</span>;

    sha256 = crypto_alloc_shash(<span style="color: #deb887;">"sha256"</span>, 0, 0);
    <span style="color: #00bfff;">if</span> (IS_ERR(sha256))
        <span style="color: #00bfff;">return</span> -1;

    shash =
        kmalloc(<span style="color: #00bfff;">sizeof</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">shash_desc</span>) + crypto_shash_descsize(sha256),
                GFP_KERNEL);
    <span style="color: #00bfff;">if</span> (!shash)
        <span style="color: #00bfff;">return</span> -ENOMEM;

    shash-&gt;tfm = sha256;

    <span style="color: #00bfff;">if</span> (crypto_shash_init(shash))
        <span style="color: #00bfff;">return</span> -1;

    <span style="color: #00bfff;">if</span> (crypto_shash_update(shash, plaintext, strlen(plaintext)))
        <span style="color: #00bfff;">return</span> -1;

    <span style="color: #00bfff;">if</span> (crypto_shash_final(shash, hash_sha256))
        <span style="color: #00bfff;">return</span> -1;

    kfree(shash);
    crypto_free_shash(sha256);

    show_hash_result(plaintext, hash_sha256);

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cryptosha256_exit</span>(<span style="color: #98f5ff;">void</span>)
{
}

<span style="color: #daa520;">module_init</span>(cryptosha256_init);
<span style="color: #daa520;">module_exit</span>(cryptosha256_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"sha256 hash test"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>

<p>
Make and install the module:
</p>

<div class="org-src-container">
<pre class="src src-sh">make
sudo insmod cryptosha256.ko
dmesg
</pre>
</div>

<p>
And you should see that the hash was calculated for the test string.
</p>

<p>
Finally, remove the test module:
</p>

<div class="org-src-container">
<pre class="src src-sh">sudo rmmod cryptosha256
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff20a6d" class="outline-3">
<h3 id="orgff20a6d"><span class="section-number-3">16.2.</span> Symmetric key encryption</h3>
<div class="outline-text-3" id="text-16-2">
<p>
Here is an example of symmetrically encrypting a string using the AES algorithm and a password.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;crypto/internal/skcipher.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/scatterlist.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/random.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/crypto.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SYMMETRIC_KEY_LENGTH</span> 32
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">CIPHER_BLOCK_SIZE</span>    16

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tcrypt_result</span> {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">completion</span> <span style="color: #4eee94;">completion</span>;
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">err</span>;
};

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_def</span> {
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">scatterlist</span> <span style="color: #4eee94;">sg</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">crypto_skcipher</span> * <span style="color: #4eee94;">tfm</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_request</span> * <span style="color: #4eee94;">req</span>;
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tcrypt_result</span> <span style="color: #4eee94;">result</span>;
    <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">scratchpad</span>;
    <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">ciphertext</span>;
    <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">ivdata</span>;
};

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_def</span> <span style="color: #4eee94;">sk</span>;

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">test_skcipher_finish</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_def</span> * <span style="color: #4eee94;">sk</span>)
{
    <span style="color: #00bfff;">if</span> (sk-&gt;tfm)
        crypto_free_skcipher(sk-&gt;tfm);
    <span style="color: #00bfff;">if</span> (sk-&gt;req)
        skcipher_request_free(sk-&gt;req);
    <span style="color: #00bfff;">if</span> (sk-&gt;ivdata)
        kfree(sk-&gt;ivdata);
    <span style="color: #00bfff;">if</span> (sk-&gt;scratchpad)
        kfree(sk-&gt;scratchpad);
    <span style="color: #00bfff;">if</span> (sk-&gt;ciphertext)
        kfree(sk-&gt;ciphertext);
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">test_skcipher_result</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_def</span> * <span style="color: #4eee94;">sk</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">rc</span>)
{
    <span style="color: #00bfff;">switch</span> (rc) {
    <span style="color: #00bfff;">case</span> 0:
        <span style="color: #00bfff;">break</span>;
    <span style="color: #00bfff;">case</span> -EINPROGRESS || -EBUSY:
        rc = wait_for_completion_interruptible(
            &amp;sk-&gt;result.completion);
        <span style="color: #00bfff;">if</span> (!rc &amp;&amp; !sk-&gt;result.err) {
            reinit_completion(&amp;sk-&gt;result.completion);
            <span style="color: #00bfff;">break</span>;
        }
        pr_info(<span style="color: #deb887;">"skcipher encrypt returned with %d result %d\n"</span>,
            rc, sk-&gt;result.err);
        <span style="color: #00bfff;">break</span>;
    <span style="color: #00bfff;">default</span>:
        pr_info(<span style="color: #deb887;">"skcipher encrypt returned with %d result %d\n"</span>,
            rc, sk-&gt;result.err);
        <span style="color: #00bfff;">break</span>;
    }

    init_completion(&amp;sk-&gt;result.completion);

    <span style="color: #00bfff;">return</span> rc;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">test_skcipher_callback</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">crypto_async_request</span> *<span style="color: #4eee94;">req</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">error</span>)
{
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">tcrypt_result</span> *<span style="color: #4eee94;">result</span> = req-&gt;data;
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">int ret;</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #00bfff;">if</span> (error == -EINPROGRESS)
        <span style="color: #00bfff;">return</span>;

    result-&gt;err = error;
    complete(&amp;result-&gt;completion);
    pr_info(<span style="color: #deb887;">"Encryption finished successfully\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">decrypt data</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #7f7f7f;">/*</span>
<span style="color: #7f7f7f;">    memset((void*)sk.scratchpad, '-', CIPHER_BLOCK_SIZE);</span>
<span style="color: #7f7f7f;">    ret = crypto_skcipher_decrypt(sk.req);</span>
<span style="color: #7f7f7f;">    ret = test_skcipher_result(&amp;sk, ret);</span>
<span style="color: #7f7f7f;">    if (ret)</span>
<span style="color: #7f7f7f;">        return;</span>

<span style="color: #7f7f7f;">    sg_copy_from_buffer(&amp;sk.sg, 1, sk.scratchpad, CIPHER_BLOCK_SIZE);</span>
<span style="color: #7f7f7f;">    sk.scratchpad[CIPHER_BLOCK_SIZE-1] = 0;</span>

<span style="color: #7f7f7f;">    pr_info("Decryption request successful\n");</span>
<span style="color: #7f7f7f;">    pr_info("Decrypted: %s\n", sk.scratchpad);</span>
<span style="color: #7f7f7f;">    */</span>
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">test_skcipher_encrypt</span>(<span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">plaintext</span>, <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">password</span>,
                                 <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">skcipher_def</span> * <span style="color: #4eee94;">sk</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span> = -EFAULT;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">key</span>[SYMMETRIC_KEY_LENGTH];

    <span style="color: #00bfff;">if</span> (!sk-&gt;tfm) {
        sk-&gt;tfm = crypto_alloc_skcipher(<span style="color: #deb887;">"cbc-aes-aesni"</span>, 0, 0);
        <span style="color: #00bfff;">if</span> (IS_ERR(sk-&gt;tfm)) {
            pr_info(<span style="color: #deb887;">"could not allocate skcipher handle\n"</span>);
            <span style="color: #00bfff;">return</span> PTR_ERR(sk-&gt;tfm);
        }
    }

    <span style="color: #00bfff;">if</span> (!sk-&gt;req) {
        sk-&gt;req = skcipher_request_alloc(sk-&gt;tfm, GFP_KERNEL);
        <span style="color: #00bfff;">if</span> (!sk-&gt;req) {
            pr_info(<span style="color: #deb887;">"could not allocate skcipher request\n"</span>);
            ret = -ENOMEM;
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
        }
    }

    skcipher_request_set_callback(sk-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
                                  test_skcipher_callback,
                                  &amp;sk-&gt;result);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">clear the key</span><span style="color: #7f7f7f;"> */</span>
    memset((<span style="color: #98f5ff;">void</span>*)key,<span style="color: #deb887;">'\0'</span>,SYMMETRIC_KEY_LENGTH);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Use the world's favourite password</span><span style="color: #7f7f7f;"> */</span>
    sprintf((<span style="color: #98f5ff;">char</span>*)key,<span style="color: #deb887;">"%s"</span>,password);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">AES 256 with given symmetric key</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #00bfff;">if</span> (crypto_skcipher_setkey(sk-&gt;tfm, key, SYMMETRIC_KEY_LENGTH)) {
        pr_info(<span style="color: #deb887;">"key could not be set\n"</span>);
        ret = -EAGAIN;
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
    }
    pr_info(<span style="color: #deb887;">"Symmetric key: %s\n"</span>, key);
    pr_info(<span style="color: #deb887;">"Plaintext: %s\n"</span>, plaintext);

    <span style="color: #00bfff;">if</span> (!sk-&gt;ivdata) {
        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">see https://en.wikipedia.org/wiki/Initialization_vector</span><span style="color: #7f7f7f;"> */</span>
        sk-&gt;ivdata = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span style="color: #00bfff;">if</span> (!sk-&gt;ivdata) {
            pr_info(<span style="color: #deb887;">"could not allocate ivdata\n"</span>);
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
        }
        get_random_bytes(sk-&gt;ivdata, CIPHER_BLOCK_SIZE);
    }

    <span style="color: #00bfff;">if</span> (!sk-&gt;scratchpad) {
        <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The text to be encrypted</span><span style="color: #7f7f7f;"> */</span>
        sk-&gt;scratchpad = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);
        <span style="color: #00bfff;">if</span> (!sk-&gt;scratchpad) {
            pr_info(<span style="color: #deb887;">"could not allocate scratchpad\n"</span>);
            <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
        }
    }
    sprintf((<span style="color: #98f5ff;">char</span>*)sk-&gt;scratchpad,<span style="color: #deb887;">"%s"</span>,plaintext);

    sg_init_one(&amp;sk-&gt;sg, sk-&gt;scratchpad, CIPHER_BLOCK_SIZE);
    skcipher_request_set_crypt(sk-&gt;req, &amp;sk-&gt;sg, &amp;sk-&gt;sg,
                               CIPHER_BLOCK_SIZE, sk-&gt;ivdata);
    init_completion(&amp;sk-&gt;result.completion);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">encrypt data</span><span style="color: #7f7f7f;"> */</span>
    ret = crypto_skcipher_encrypt(sk-&gt;req);
    ret = test_skcipher_result(sk, ret);
    <span style="color: #00bfff;">if</span> (ret)
        <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;

    pr_info(<span style="color: #deb887;">"Encryption request successful\n"</span>);

<span style="color: #a2cd5a;">out</span>:
    <span style="color: #00bfff;">return</span> ret;
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520;">cryptoapi_init</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">The world's favourite password</span><span style="color: #7f7f7f;"> */</span>
    <span style="color: #98f5ff;">char</span> * <span style="color: #4eee94;">password</span> = <span style="color: #deb887;">"password123"</span>;

    sk.tfm = <span style="color: #a2cd5a;">NULL</span>;
    sk.req = <span style="color: #a2cd5a;">NULL</span>;
    sk.scratchpad = <span style="color: #a2cd5a;">NULL</span>;
    sk.ciphertext = <span style="color: #a2cd5a;">NULL</span>;
    sk.ivdata = <span style="color: #a2cd5a;">NULL</span>;

    test_skcipher_encrypt(<span style="color: #deb887;">"Testing"</span>, password, &amp;sk);
    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520;">cryptoapi_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    test_skcipher_finish(&amp;sk);
}

<span style="color: #daa520;">module_init</span>(cryptoapi_init);
<span style="color: #daa520;">module_exit</span>(cryptoapi_exit);

MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Symmetric key encryption example"</span>);
MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org576908f" class="outline-2">
<h2 id="org576908f"><span class="section-number-2">17.</span> Standardising the interfaces: The Device Model</h2>
<div class="outline-text-2" id="text-17">
<p>
Up to this point we've seen all kinds of modules doing all kinds of things, but there was no consistency in their interfaces with the rest of the kernel. To impose some consistency such that there is at minimum a standardised way to start, suspend and resume a device a device model was added. An example is show below, and you can use this as a template to add your own suspend, resume or other interface functions.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/kernel.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/module.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;linux/platform_device.h&gt;</span>

<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">devicemodel_data</span> {
    <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">greeting</span>;
    <span style="color: #98f5ff;">int</span>   <span style="color: #4eee94;">number</span>;
};

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">devicemodel_probe</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">platform_device</span> *<span style="color: #4eee94;">dev</span>)
{
    <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">devicemodel_data</span> *<span style="color: #4eee94;">pd</span> = (<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">devicemodel_data</span> *)(dev-&gt;dev.platform_data);

    pr_info(<span style="color: #deb887;">"devicemodel probe\n"</span>);
    pr_info(<span style="color: #deb887;">"devicemodel greeting: %s; %d\n"</span>, pd-&gt;greeting, pd-&gt;number);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Your device initialisation code</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">devicemodel_remove</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">platform_device</span> *<span style="color: #4eee94;">dev</span>)
{
    pr_info(<span style="color: #deb887;">"devicemodel example removed\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Your device removal code</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">devicemodel_suspend</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">device</span> *<span style="color: #4eee94;">dev</span>)
{
    pr_info(<span style="color: #deb887;">"devicemodel example suspend\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Your device suspend code</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">devicemodel_resume</span>(<span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">device</span> *<span style="color: #4eee94;">dev</span>)
{
    pr_info(<span style="color: #deb887;">"devicemodel example resume\n"</span>);

    <span style="color: #7f7f7f;">/* </span><span style="color: #7f7f7f;">Your device resume code</span><span style="color: #7f7f7f;"> */</span>

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">const</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">dev_pm_ops</span> <span style="color: #4eee94;">devicemodel_pm_ops</span> =
{
    .suspend = devicemodel_suspend,
    .resume = devicemodel_resume,
    .poweroff = devicemodel_suspend,
    .freeze = devicemodel_suspend,
    .thaw = devicemodel_resume,
    .restore = devicemodel_resume
};

<span style="color: #00bfff;">static</span> <span style="color: #00bfff;">struct</span> <span style="color: #98f5ff;">platform_driver</span> <span style="color: #4eee94;">devicemodel_driver</span> = {
    .driver     = {
        .name   = <span style="color: #deb887;">"devicemodel_example"</span>,
        .owner  = THIS_MODULE,
        .pm     = &amp;devicemodel_pm_ops,
    },
    .probe      = devicemodel_probe,
    .remove     = devicemodel_remove,
};

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520;">devicemodel_init</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ret</span>;

    pr_info(<span style="color: #deb887;">"devicemodel init\n"</span>);

    ret = platform_driver_register(&amp;devicemodel_driver);

    <span style="color: #00bfff;">if</span> (ret) {
        pr_err(<span style="color: #deb887;">"Unable to register driver\n"</span>);
        <span style="color: #00bfff;">return</span> ret;
    }

    <span style="color: #00bfff;">return</span> 0;
}

<span style="color: #00bfff;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520;">devicemodel_exit</span>(<span style="color: #98f5ff;">void</span>)
{
    pr_info(<span style="color: #deb887;">"devicemodel exit\n"</span>);
    platform_driver_unregister(&amp;devicemodel_driver);
}

MODULE_LICENSE(<span style="color: #deb887;">"GPL"</span>);
MODULE_AUTHOR(<span style="color: #deb887;">"Bob Mottram"</span>);
MODULE_DESCRIPTION(<span style="color: #deb887;">"Linux Device Model example"</span>);

<span style="color: #daa520;">module_init</span>(devicemodel_init);
<span style="color: #daa520;">module_exit</span>(devicemodel_exit);
</pre>
</div>
</div>
</div>
<div id="outline-container-org10eb421" class="outline-2">
<h2 id="org10eb421"><span class="section-number-2">18.</span> Optimisations</h2>
<div class="outline-text-2" id="text-18">
</div>
<div id="outline-container-org88cc3ac" class="outline-3">
<h3 id="org88cc3ac"><span class="section-number-3">18.1.</span> Likely and Unlikely conditions</h3>
<div class="outline-text-3" id="text-18-1">
<p>
Sometimes you might want your code to run as quickly as possible, especially if it's handling an interrupt or doing something which might cause noticible latency. If your code contains boolean conditions and if you know that the conditions are almost always likely to evaluate as either <i>true</i> or <i>false</i>, then you can allow the compiler to optimise for this using the <i>likely</i> and <i>unlikely</i> macros.
</p>

<p>
For example, when allocating memory you're almost always expecting this to succeed.
</p>

<div class="org-src-container">
<pre class="src src-C">bvl = bvec_alloc(gfp_mask, nr_iovecs, &amp;idx);
<span style="color: #00bfff;">if</span> (unlikely(!bvl)) {
  mempool_free(bio, bio_pool);
  bio = <span style="color: #a2cd5a;">NULL</span>;
  <span style="color: #00bfff;">goto</span> <span style="color: #a2cd5a;">out</span>;
}
</pre>
</div>

<p>
When the <i>unlikely</i> macro is used the compiler alters its machine instruction output so that it continues along the false branch and only jumps if the condition is true. That avoids flushing the processor pipeline. The opposite happens if you use the <i>likely</i> macro.
</p>
</div>
</div>
</div>
<div id="outline-container-org081a631" class="outline-2">
<h2 id="org081a631"><span class="section-number-2">19.</span> Common Pitfalls</h2>
<div class="outline-text-2" id="text-19">
<p>
Before I send you on your way to go out into the world and write kernel modules, there are a few things I need to warn you about. If I fail to warn you and something bad happens, please report the problem to me for a full refund of the amount I was paid for your copy of the book.
</p>
</div>

<div id="outline-container-org53333e8" class="outline-3">
<h3 id="org53333e8"><span class="section-number-3">19.1.</span> Using standard libraries</h3>
<div class="outline-text-3" id="text-19-1">
<p>
You can't do that. In a kernel module you can only use kernel functions, which are the functions you can see in /proc/kallsyms.
</p>
</div>
</div>

<div id="outline-container-org9ffb1c0" class="outline-3">
<h3 id="org9ffb1c0"><span class="section-number-3">19.2.</span> Disabling interrupts</h3>
<div class="outline-text-3" id="text-19-2">
<p>
You might need to do this for a short time and that is OK, but if you don't enable them afterwards, your system will be stuck and you'll have to power it off.
</p>
</div>
</div>

<div id="outline-container-org86cb6f3" class="outline-3">
<h3 id="org86cb6f3"><span class="section-number-3">19.3.</span> Sticking your head inside a large carnivore</h3>
<div class="outline-text-3" id="text-19-3">
<p>
I probably don't have to warn you about this, but I figured I will anyway, just in case.
</p>
</div>
</div>
</div>

<div id="outline-container-orge44db4c" class="outline-2">
<h2 id="orge44db4c"><span class="section-number-2">20.</span> Where To Go From Here?</h2>
<div class="outline-text-2" id="text-20">
<p>
I could easily have squeezed a few more chapters into this book. I could have added a chapter about creating new file systems, or about adding new protocol stacks (as if there's a need for that &#x2013; you'd have to dig underground to find a protocol stack not supported by Linux). I could have added explanations of the kernel mechanisms we haven't touched upon, such as bootstrapping or the disk interface.
</p>

<p>
However, I chose not to. My purpose in writing this book was to provide initiation into the mysteries of kernel module programming and to teach the common techniques for that purpose. For people seriously interested in kernel programming, I recommend <a href="https://kernelnewbies.org">kernelnewbies.org</a> and the <i>Documentation</i> subdirectory within the kernel source code which isn't always easy to understand but can be a starting point for further investigation. Also, as Linus said, the best way to learn the kernel is to read the source code yourself.
</p>

<p>
If you're interested in more examples of short kernel modules then searching on sites such as Github and Gitlab is a good way to start, although there is a lot of duplication of older LKMPG examples which may not compile with newer kernel versions. You will also be able to find examples of the use of kernel modules to attack or compromise systems or exfiltrate data and those can be useful for thinking about how to defend systems and learning about existing security mechanisms within the kernel.
</p>

<p>
I hope I have helped you in your quest to become a better programmer, or at least to have fun through technology. And, if you do write useful kernel modules, I hope you publish them under the GPL, so I can use them too.
</p>

<p>
If you'd like to contribute to this guide, notice anything glaringly wrong, or just want to add extra sarcastic remarks perhaps involving monkeys or some other kind of animal then fire an email to bob@libreserver.org and you may be able to get commit access to <a href="https://gitlab.com/bashrc2/LKMPG">https://gitlab.com/bashrc2/LKMPG</a>.
</p>

<p>
Happy hacking.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram</p>
<p class="date">Created: 2021-09-18 Sat 18:40</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
